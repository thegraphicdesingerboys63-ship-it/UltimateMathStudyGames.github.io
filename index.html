<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Game Hub - 50+ Games</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .username-btn {
            margin-top: 15px;
            padding: 10px 25px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
            transition: transform 0.2s;
        }

        .username-btn:hover {
            transform: scale(1.05);
        }

        .container {
            max-width: 1400px;
            margin: 40px auto;
            padding: 20px;
        }

        .search-bar {
            width: 100%;
            padding: 15px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 30px;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .game-card h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .game-card p {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .game-card .play-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
        }

        .game-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            padding: 20px;
        }

        .game-screen.active {
            display: flex;
            flex-direction: column;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
        }

        .game-title {
            font-size: 2em;
        }

        .shop-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            border: none;
            padding: 10px 25px;
            border-radius: 20px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            animation: shopPulse 2s infinite;
        }

        @keyframes shopPulse {
            0%, 100% { 
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 4px 25px rgba(255, 215, 0, 0.8);
                transform: scale(1.05);
            }
        }

        .shop-btn:hover {
            transform: scale(1.1);
            animation: none;
            box-shadow: 0 6px 30px rgba(255, 215, 0, 0.9);
        }

        .coins-display {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.1em;
            border: 2px solid #ffd700;
        }

        .close-btn {
            background: #ff4444;
            border: none;
            padding: 10px 25px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1em;
        }

        .game-canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 3px solid #00ff88;
            border-radius: 10px;
            background: #000;
        }

        .game-info {
            text-align: center;
            margin-top: 20px;
            font-size: 1.2em;
        }

        .category-filter {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .filter-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .filter-btn:hover, .filter-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .username-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .username-modal.active {
            display: flex;
        }

        .username-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }

        .username-content h2 {
            margin-bottom: 20px;
            font-size: 2em;
        }

        .username-content input {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .username-content button {
            padding: 12px 30px;
            font-size: 1.1em;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
        }

        /* Shop Modal */
        .shop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            justify-content: center;
            align-items: center;
        }

        .shop-modal.active {
            display: flex;
        }

        .shop-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .shop-coins {
            background: rgba(255, 215, 0, 0.3);
            padding: 15px 25px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            font-size: 1.5em;
            font-weight: bold;
        }

        .shop-section {
            margin-bottom: 40px;
        }

        /* Update Log Scrollbar */
        #updateLogContent::-webkit-scrollbar {
            width: 8px;
        }

        #updateLogContent::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        #updateLogContent::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
        }

        #updateLogContent::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        .shop-section h3 {
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .skin-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .skin-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.2);
        }

        .skin-card.owned {
            border-color: #00ff88;
        }

        .skin-card.equipped {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .powerup-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .powerup-card:hover {
            transform: translateY(-5px);
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .skin-preview {
            width: 80px;
            height: 80px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            border-radius: 10px;
        }

        .skin-name {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .skin-price {
            color: #ffd700;
            font-weight: bold;
            font-size: 1.2em;
        }

        .skin-status {
            margin-top: 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quest-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .quest-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .quest-item.completed {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
        }

        .quest-info {
            flex: 1;
        }

        .quest-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .quest-progress {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quest-reward {
            background: rgba(255, 215, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.2em;
            border: 2px solid #ffd700;
        }

        /* Quest Notification */
        .quest-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #00ff88 0%, #00d4ff 100%);
            color: #000;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2em;
            z-index: 10000;
            animation: slideIn 0.5s ease-out, slideOut 0.5s ease-in 2.5s;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Custom Games Modal */
        .custom-games-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            justify-content: center;
            align-items: center;
        }

        .custom-games-modal.active {
            display: flex;
        }

        .custom-games-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .custom-game-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            margin: 15px 0;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .custom-game-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .custom-game-info h3 {
            margin: 0 0 10px 0;
            font-size: 1.5em;
        }

        .custom-game-actions {
            display: flex;
            gap: 10px;
        }

        .custom-game-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .custom-game-actions button:hover {
            transform: scale(1.05);
        }

        .play-custom-btn {
            background: #00ff88;
            color: #000;
        }

        .edit-custom-btn {
            background: #ffaa00;
            color: #000;
        }

        .delete-custom-btn {
            background: #ff4444;
            color: #fff;
        }

        .create-game-btn {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #00ff88 0%, #00d4ff 100%);
            border: none;
            border-radius: 15px;
            font-size: 1.3em;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        .create-game-btn:hover {
            transform: scale(1.02);
        }

        /* Game Creator Modal */
        .game-creator-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 4000;
            justify-content: center;
            align-items: center;
        }

        .game-creator-modal.active {
            display: flex;
        }

        .game-creator-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .template-card {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .template-card:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .template-card.selected {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
        }

        .template-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .color-picker-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid #fff;
        }

        /* Block-Based Programming */
        .block-section {
            margin-bottom: 20px;
        }

        .block-section-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .setting-block {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setting-block label {
            font-weight: bold;
            margin-right: 15px;
        }

        .setting-block input,
        .setting-block select {
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            min-width: 150px;
        }

        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: 5px;
            border: 3px solid white;
            cursor: pointer;
        }

        /* Scratch-Style Block System */
        .code-block {
            padding: 10px 12px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: move;
            user-select: none;
            font-size: 0.9em;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
            font-weight: 500;
        }

        .code-block:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }

        .code-block.dragging {
            opacity: 0.5;
        }

        .code-block.in-workspace {
            margin: 10px 0;
            cursor: grab;
            position: relative;
        }

        .code-block.in-workspace:active {
            cursor: grabbing;
        }

        .code-block .remove-block {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255,0,0,0.8);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
        }

        .block-input {
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            color: #000;
            font-size: 0.9em;
            margin: 0 4px;
        }

        .block-category h4 {
            font-size: 0.95em;
            margin-bottom: 8px;
        }

        #workspaceBlocks.drag-over {
            background: rgba(0,255,136,0.2) !important;
            border-color: #00ff88 !important;
        }

        /* Professional Calculator Styles */
        .calc-btn-pro {
            padding: 20px;
            font-size: 1.4em;
            font-weight: 500;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .calc-btn-pro:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            filter: brightness(1.2);
        }

        .calc-btn-pro:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
        }

        .calc-btn-pro.calc-number {
            background: linear-gradient(135deg, #4a4a4a, #3a3a3a);
        }

        .calc-btn-pro.calc-operator {
            background: linear-gradient(135deg, #ff9500, #ff8000);
            font-size: 1.6em;
        }

        .calc-btn-adv {
            padding: 12px 8px;
            font-size: 0.9em;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            background: rgba(0,212,255,0.2);
            color: #00d4ff;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(0,212,255,0.3);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .calc-btn-adv:hover {
            background: rgba(0,212,255,0.3);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,212,255,0.3);
        }

        .calc-btn-adv:active {
            transform: translateY(0);
        }

        #calcHistory::-webkit-scrollbar {
            width: 6px;
        }

        #calcHistory::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }

        #calcHistory::-webkit-scrollbar-thumb {
            background: rgba(0,212,255,0.5);
            border-radius: 3px;
        }

        #calcHistory::-webkit-scrollbar-thumb:hover {
            background: rgba(0,212,255,0.7);
        }

        #variablesList::-webkit-scrollbar {
            width: 6px;
        }

        #variablesList::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }

        #variablesList::-webkit-scrollbar-thumb {
            background: rgba(186,85,211,0.5);
            border-radius: 3px;
        }

        #variablesList::-webkit-scrollbar-thumb:hover {
            background: rgba(186,85,211,0.7);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ ULTIMATE GAME HUB</h1>
        <p>50+ Arcade Games - Play Instantly!</p>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
            <button class="username-btn" onclick="openCalculator()" style="background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);">üî¢ CALCULATOR</button>
            <button class="username-btn" onclick="openCloakMenu()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üé≠ TAB CLOAK</button>
            <button class="username-btn" onclick="openUpdateLog()" style="background: linear-gradient(135deg, #f5af19 0%, #f12711 100%);">üìã UPDATES</button>
            <button class="username-btn" onclick="openCustomGames()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">‚öôÔ∏è MY GAMES</button>
            <button class="username-btn" onclick="openUsernameModal()">üë§ Player: <span id="displayUsername">Guest</span></button>
        </div>
    </div>

    <div class="container">
        <input type="text" class="search-bar" id="searchBar" placeholder="üîç Search games..." oninput="filterGames()">
        
        <div class="category-filter">
            <button class="filter-btn active" onclick="filterCategory('all')">All Games</button>
            <button class="filter-btn" onclick="filterCategory('arcade')">Arcade</button>
            <button class="filter-btn" onclick="filterCategory('puzzle')">Puzzle</button>
            <button class="filter-btn" onclick="filterCategory('action')">Action</button>
            <button class="filter-btn" onclick="filterCategory('strategy')">Strategy</button>
        </div>

        <div class="games-grid" id="gamesGrid"></div>
    </div>

    <!-- Game Screen -->
    <div class="game-screen" id="gameScreen">
        <div class="game-header">
            <div class="game-title" id="currentGameTitle"></div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <div class="coins-display">ü™ô <span id="gameCoins">0</span></div>
                <button class="shop-btn" onclick="openShop()">üõí SHOP</button>
                <button class="close-btn" onclick="closeGame()">‚úï CLOSE</button>
            </div>
        </div>
        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        <div class="game-info" id="gameInfo"></div>
    </div>

    <!-- Username Modal -->
    <div class="username-modal" id="usernameModal">
        <div class="username-content">
            <h2>üë§ SET USERNAME</h2>
            <p>Current: <strong id="currentUsername">Guest</strong></p>
            <input type="text" id="usernameInput" placeholder="Enter username..." maxlength="20">
            <div>
                <button onclick="saveUsername()">‚úÖ Save</button>
                <button onclick="closeUsernameModal()" style="background: #ff4444; color: white;">‚ùå Cancel</button>
            </div>
        </div>
    </div>

    <!-- Shop Modal -->
    <div class="shop-modal" id="shopModal">
        <div class="shop-content">
            <div class="shop-header">
                <h2>üõí SHOP</h2>
                <div class="shop-coins">ü™ô <span id="shopCoinsDisplay">0</span> Coins</div>
            </div>

            <!-- Power-Ups Section (for Block Puzzle) -->
            <div class="shop-section" id="powerUpsSection" style="display: none;">
                <h3>üí• POWER-UPS</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;">
                    <div class="powerup-card" onclick="buyPowerUp('bomb', 50)">
                        <div style="font-size: 48px;">üí£</div>
                        <div style="font-weight: bold; margin: 10px 0;">Bomb</div>
                        <div style="font-size: 14px; opacity: 0.8; margin-bottom: 10px;">Clears 3√ó3 area</div>
                        <button style="padding: 8px 20px; background: #ff6b6b; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold;">
                            Buy for 50 ü™ô
                        </button>
                    </div>
                    <div class="powerup-card" onclick="buyPowerUp('lightning', 75)">
                        <div style="font-size: 48px;">‚ö°</div>
                        <div style="font-weight: bold; margin: 10px 0;">Lightning</div>
                        <div style="font-size: 14px; opacity: 0.8; margin-bottom: 10px;">Clears entire row</div>
                        <button style="padding: 8px 20px; background: #ffd700; color: black; border: none; border-radius: 10px; cursor: pointer; font-weight: bold;">
                            Buy for 75 ü™ô
                        </button>
                    </div>
                    <div class="powerup-card" onclick="buyPowerUp('hammer', 30)">
                        <div style="font-size: 48px;">üî®</div>
                        <div style="font-weight: bold; margin: 10px 0;">Hammer</div>
                        <div style="font-size: 14px; opacity: 0.8; margin-bottom: 10px;">Remove 1 cell</div>
                        <button style="padding: 8px 20px; background: #00bfff; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold;">
                            Buy for 30 ü™ô
                        </button>
                    </div>
                    <div class="powerup-card" onclick="buyPowerUp('shuffle', 100)">
                        <div style="font-size: 48px;">üîÄ</div>
                        <div style="font-weight: bold; margin: 10px 0;">Shuffle</div>
                        <div style="font-size: 14px; opacity: 0.8; margin-bottom: 10px;">Get new blocks</div>
                        <button style="padding: 8px 20px; background: #9370db; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold;">
                            Buy for 100 ü™ô
                        </button>
                    </div>
                </div>
            </div>

            <div class="shop-section">
                <h3>üé® SKINS</h3>
                <div class="skins-grid" id="skinsGrid"></div>
            </div>

            <div class="shop-section">
                <h3>üéØ QUESTS</h3>
                <div class="quest-list" id="questsList"></div>
            </div>

            <button onclick="closeShop()" style="width: 100%; padding: 15px; margin-top: 20px; background: white; color: #667eea; border: none; border-radius: 20px; font-weight: bold; font-size: 1.2em; cursor: pointer;">
                CLOSE
            </button>
        </div>
    </div>

    <!-- Custom Games Modal -->
    <div class="custom-games-modal" id="customGamesModal">
        <div class="custom-games-content">
            <h2 style="text-align: center; margin-bottom: 30px;">‚öôÔ∏è MY CUSTOM GAMES</h2>
            
            <button class="create-game-btn" onclick="openGameCreator()">+ CREATE NEW GAME</button>
            
            <div id="customGamesList"></div>

            <button onclick="closeCustomGames()" style="width: 100%; padding: 15px; margin-top: 30px; background: white; color: #667eea; border: none; border-radius: 20px; font-weight: bold; font-size: 1.2em; cursor: pointer;">
                CLOSE
            </button>
        </div>
    </div>

    <!-- Game Creator Modal - Scratch Style -->
    <div class="game-creator-modal" id="gameCreatorModal">
        <div class="game-creator-content" style="max-width: 95%; width: 1400px; height: 90vh;">
            <h2 style="text-align: center; margin-bottom: 15px;">üé® GAME CREATOR STUDIO - Block Programming</h2>
            
            <div style="display: grid; grid-template-columns: 250px 1fr 350px; gap: 15px; height: calc(100% - 120px);">
                <!-- Left - Block Palette (Scratch Style) -->
                <div style="background: rgba(0,0,0,0.3); border-radius: 15px; padding: 15px; overflow-y: auto;">
                    <h3 style="margin-top: 0; color: #00ff88;">üì¶ BLOCKS</h3>
                    
                    <div class="block-category">
                        <h4 style="color: #4A90E2; margin: 15px 0 10px 0;">üéÆ Game Setup</h4>
                        <div class="code-block" draggable="true" data-block="name" style="background: #4A90E2;">
                            <strong>Game Name:</strong> <input type="text" class="block-input" placeholder="My Game" style="width: 120px;">
                        </div>
                        <div class="code-block" draggable="true" data-block="icon" style="background: #4A90E2;">
                            <strong>Icon:</strong> <input type="text" class="block-input" placeholder="üéÆ" maxlength="2" style="width: 50px;">
                        </div>
                        <div class="code-block" draggable="true" data-block="description" style="background: #4A90E2;">
                            <strong>Description:</strong> <input type="text" class="block-input" placeholder="Fun game!" style="width: 140px;">
                        </div>
                    </div>

                    <div class="block-category">
                        <h4 style="color: #E25D4A; margin: 15px 0 10px 0;">üéØ Player</h4>
                        <div class="code-block" draggable="true" data-block="player-color" style="background: #E25D4A;">
                            <strong>Player Color:</strong> <input type="color" class="block-input" value="#00ff88">
                        </div>
                        <div class="code-block" draggable="true" data-block="player-size" style="background: #E25D4A;">
                            <strong>Size:</strong> <input type="number" class="block-input" value="20" min="10" max="50" style="width: 60px;">
                        </div>
                        <div class="code-block" draggable="true" data-block="player-speed" style="background: #E25D4A;">
                            <strong>Speed:</strong> <input type="number" class="block-input" value="5" min="1" max="10" style="width: 60px;">
                        </div>
                    </div>

                    <div class="block-category">
                        <h4 style="color: #E2A54A; margin: 15px 0 10px 0;">üé≤ Game Type</h4>
                        <div class="code-block" draggable="true" data-block="type-clicker" style="background: #E2A54A;">
                            üñ±Ô∏è Clicker Game
                        </div>
                        <div class="code-block" draggable="true" data-block="type-catcher" style="background: #E2A54A;">
                            üéØ Catcher Game
                        </div>
                        <div class="code-block" draggable="true" data-block="type-avoider" style="background: #E2A54A;">
                            ‚ö° Avoider Game
                        </div>
                        <div class="code-block" draggable="true" data-block="type-platformer" style="background: #E2A54A;">
                            üèÉ Platformer Game
                        </div>
                    </div>

                    <div class="block-category">
                        <h4 style="color: #9B4AE2; margin: 15px 0 10px 0;">üåà Colors & Theme</h4>
                        <div class="code-block" draggable="true" data-block="bg-color" style="background: #9B4AE2;">
                            <strong>Background:</strong> <input type="color" class="block-input" value="#000000">
                        </div>
                        <div class="code-block" draggable="true" data-block="target-color" style="background: #9B4AE2;">
                            <strong>Target Color:</strong> <input type="color" class="block-input" value="#ff4444">
                        </div>
                    </div>

                    <div class="block-category">
                        <h4 style="color: #4AE2C6; margin: 15px 0 10px 0;">‚öôÔ∏è Settings</h4>
                        <div class="code-block" draggable="true" data-block="time-limit" style="background: #4AE2C6;">
                            <strong>Time Limit:</strong> <input type="number" class="block-input" value="30" min="10" max="120" style="width: 60px;">s
                        </div>
                        <div class="code-block" draggable="true" data-block="points-per" style="background: #4AE2C6;">
                            <strong>Points Per:</strong> <input type="number" class="block-input" value="10" min="1" max="100" style="width: 60px;">
                        </div>
                        <div class="code-block" draggable="true" data-block="difficulty" style="background: #4AE2C6;">
                            <strong>Difficulty:</strong>
                            <select class="block-input" style="width: 80px;">
                                <option>Easy</option>
                                <option selected>Normal</option>
                                <option>Hard</option>
                            </select>
                        </div>
                    </div>

                    <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,136,0.2); border-radius: 10px; font-size: 0.85em;">
                        üí° <strong>Tip:</strong> Drag blocks to the workspace to build your game!
                    </div>
                </div>

                <!-- Middle - Workspace (Scratch Style) -->
                <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 20px; overflow-y: auto;" id="blockWorkspace">
                    <h3 style="margin-top: 0; text-align: center; color: #00ff88;">üìù WORKSPACE</h3>
                    <div id="workspaceBlocks" style="min-height: 400px; background: rgba(0,0,0,0.2); border-radius: 10px; padding: 15px; border: 2px dashed rgba(255,255,255,0.3);">
                        <p style="text-align: center; opacity: 0.5; margin-top: 100px;">Drag blocks here to start building your game!</p>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0,255,136,0.1); border-radius: 10px;">
                        <h4 style="margin-top: 0;">üìã Quick Start Templates:</h4>
                        <button onclick="loadTemplate('clicker')" style="margin: 5px; padding: 8px 15px; background: #4A90E2; border: none; border-radius: 8px; color: white; cursor: pointer;">üñ±Ô∏è Clicker</button>
                        <button onclick="loadTemplate('catcher')" style="margin: 5px; padding: 8px 15px; background: #E25D4A; border: none; border-radius: 8px; color: white; cursor: pointer;">üéØ Catcher</button>
                        <button onclick="loadTemplate('avoider')" style="margin: 5px; padding: 8px 15px; background: #E2A54A; border: none; border-radius: 8px; color: white; cursor: pointer;">‚ö° Avoider</button>
                        <button onclick="clearWorkspace()" style="margin: 5px; padding: 8px 15px; background: #ff4444; border: none; border-radius: 8px; color: white; cursor: pointer;">üóëÔ∏è Clear All</button>
                    </div>
                </div>

                <!-- Right - Live Preview -->
                <div style="background: rgba(0,0,0,0.3); border-radius: 15px; padding: 15px; overflow-y: auto;">
                    <h3 style="margin-top: 0; text-align: center; color: #00ff88;">üëÅÔ∏è LIVE PREVIEW</h3>
                    
                    <!-- Game Card Preview -->
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <div style="font-size: 3em; text-align: center; margin-bottom: 10px;" id="previewIcon">üéÆ</div>
                        <h3 style="text-align: center; margin: 10px 0; font-size: 1.2em;" id="previewName">My Game</h3>
                        <p style="text-align: center; opacity: 0.8; margin: 10px 0; font-size: 0.9em;" id="previewDesc">Drag blocks to workspace!</p>
                    </div>

                    <!-- Mini Game Preview -->
                    <div style="background: #000; border-radius: 10px; overflow: hidden; margin-bottom: 15px;">
                        <canvas id="previewCanvas" width="320" height="240" style="width: 100%; height: auto; display: block;"></canvas>
                    </div>

                    <!-- Block Count -->
                    <div style="padding: 10px; background: rgba(0,255,136,0.2); border-radius: 10px; margin-bottom: 10px; font-size: 0.9em;">
                        <strong>üìä Blocks in Workspace:</strong>
                        <div id="blockCount" style="font-size: 1.5em; text-align: center; margin-top: 5px;">0</div>
                    </div>

                    <!-- Game Stats -->
                    <div style="padding: 10px; background: rgba(255,255,136,0.2); border-radius: 10px; font-size: 0.85em;" id="gameStats">
                        <strong>‚öôÔ∏è Game Configuration:</strong><br>
                        <div style="margin-top: 5px; line-height: 1.6;">
                            Type: <span id="statType">Not set</span><br>
                            Player: <span id="statPlayer">Default</span><br>
                            Theme: <span id="statTheme">Default</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom Buttons -->
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="saveBlockGame()" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #00ff88, #00d4ff); color: #000; border: none; border-radius: 12px; font-weight: bold; font-size: 1.2em; cursor: pointer;">
                    üíæ SAVE GAME
                </button>
                <button onclick="testBlockGame()" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #667eea, #764ba2); color: #fff; border: none; border-radius: 12px; font-weight: bold; font-size: 1.2em; cursor: pointer;">
                    ‚ñ∂Ô∏è TEST GAME
                </button>
                <button onclick="closeGameCreator()" style="padding: 15px 30px; background: #ff4444; color: #fff; border: none; border-radius: 12px; font-weight: bold; font-size: 1.2em; cursor: pointer;">
                    ‚úï CLOSE
                </button>
            </div>
        </div>
    </div>

    <!-- Advanced Calculator Modal -->
    <div class="username-modal" id="calculatorModal">
        <div class="username-content" style="max-width: 500px; background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%); padding: 25px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0; color: #00d4ff;">üî¢ Scientific Calculator</h2>
                <button onclick="toggleCalcMode()" id="calcModeBtn" style="padding: 8px 15px; background: rgba(0,212,255,0.2); border: 1px solid #00d4ff; border-radius: 8px; color: #00d4ff; cursor: pointer; font-size: 0.9em;">
                    Advanced Mode
                </button>
            </div>
            
            <div style="background: #000; padding: 20px; border-radius: 15px; box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);">
                <!-- Secondary Display (shows previous calculation) -->
                <div id="calcSecondary" style="text-align: right; font-size: 0.9em; color: #888; margin-bottom: 5px; min-height: 20px; font-family: 'Courier New', monospace;">
                    
                </div>
                
                <!-- Main Display -->
                <div id="calcDisplay" style="text-align: right; font-size: 2.5em; font-weight: 300; color: #00ff88; min-height: 70px; word-wrap: break-word; font-family: 'Courier New', monospace; display: flex; align-items: center; justify-content: flex-end;">
                    0
                </div>
                
                <!-- Memory Indicators -->
                <div style="display: flex; gap: 10px; margin-top: 10px; font-size: 0.8em;">
                    <span id="memoryIndicator" style="color: #888; display: none;">M</span>
                    <span id="angleMode" style="color: #00d4ff; margin-left: auto;">DEG</span>
                </div>
            </div>
            
            <!-- Advanced Mode Panel (Hidden by default) -->
            <div id="advancedPanel" style="display: none; margin-top: 15px; background: rgba(0,212,255,0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0,212,255,0.3);">
                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;">
                    <!-- Row 1: Trigonometry -->
                    <button onclick="calcFunc('sin')" class="calc-btn-adv">sin</button>
                    <button onclick="calcFunc('cos')" class="calc-btn-adv">cos</button>
                    <button onclick="calcFunc('tan')" class="calc-btn-adv">tan</button>
                    <button onclick="calcFunc('asin')" class="calc-btn-adv">sin‚Åª¬π</button>
                    <button onclick="calcFunc('acos')" class="calc-btn-adv">cos‚Åª¬π</button>
                    
                    <!-- Row 2: Logarithms & Constants -->
                    <button onclick="calcFunc('log')" class="calc-btn-adv">log</button>
                    <button onclick="calcFunc('ln')" class="calc-btn-adv">ln</button>
                    <button onclick="calcFunc('exp')" class="calc-btn-adv">eÀ£</button>
                    <button onclick="calcInput('Math.PI')" class="calc-btn-adv">œÄ</button>
                    <button onclick="calcInput('Math.E')" class="calc-btn-adv">e</button>
                    
                    <!-- Row 3: Power & Root -->
                    <button onclick="calcFunc('sqrt')" class="calc-btn-adv">‚àöx</button>
                    <button onclick="calcFunc('cbrt')" class="calc-btn-adv">‚àõx</button>
                    <button onclick="calcInput('**')" class="calc-btn-adv">x ∏</button>
                    <button onclick="calcFunc('pow10')" class="calc-btn-adv">10À£</button>
                    <button onclick="calcInput('**2')" class="calc-btn-adv">x¬≤</button>
                    
                    <!-- Row 4: Memory & More -->
                    <button onclick="memoryStore()" class="calc-btn-adv">MS</button>
                    <button onclick="memoryRecall()" class="calc-btn-adv">MR</button>
                    <button onclick="memoryClear()" class="calc-btn-adv">MC</button>
                    <button onclick="memoryAdd()" class="calc-btn-adv">M+</button>
                    <button onclick="toggleAngle()" class="calc-btn-adv" id="angleBtn">RAD</button>
                </div>
            </div>
            
            <!-- Main Calculator Buttons -->
            <div style="margin-top: 15px;">
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                    <!-- Row 1 -->
                    <button onclick="calcClear()" class="calc-btn-pro" style="background: linear-gradient(135deg, #ff4444, #cc0000); font-size: 1em;">AC</button>
                    <button onclick="calcToggleSign()" class="calc-btn-pro" style="background: linear-gradient(135deg, #666, #444);">¬±</button>
                    <button onclick="calcInput('%')" class="calc-btn-pro" style="background: linear-gradient(135deg, #666, #444);">%</button>
                    <button onclick="calcInput('/')" class="calc-btn-pro calc-operator">√∑</button>
                    
                    <!-- Row 2 -->
                    <button onclick="calcInput('7')" class="calc-btn-pro calc-number">7</button>
                    <button onclick="calcInput('8')" class="calc-btn-pro calc-number">8</button>
                    <button onclick="calcInput('9')" class="calc-btn-pro calc-number">9</button>
                    <button onclick="calcInput('*')" class="calc-btn-pro calc-operator">√ó</button>
                    
                    <!-- Row 3 -->
                    <button onclick="calcInput('4')" class="calc-btn-pro calc-number">4</button>
                    <button onclick="calcInput('5')" class="calc-btn-pro calc-number">5</button>
                    <button onclick="calcInput('6')" class="calc-btn-pro calc-number">6</button>
                    <button onclick="calcInput('-')" class="calc-btn-pro calc-operator">‚àí</button>
                    
                    <!-- Row 4 -->
                    <button onclick="calcInput('1')" class="calc-btn-pro calc-number">1</button>
                    <button onclick="calcInput('2')" class="calc-btn-pro calc-number">2</button>
                    <button onclick="calcInput('3')" class="calc-btn-pro calc-number">3</button>
                    <button onclick="calcInput('+')" class="calc-btn-pro calc-operator">+</button>
                    
                    <!-- Row 5 -->
                    <button onclick="calcInput('0')" class="calc-btn-pro calc-number" style="grid-column: span 2; font-size: 1.3em;">0</button>
                    <button onclick="calcInput('.')" class="calc-btn-pro calc-number">.</button>
                    <button onclick="calcEquals()" class="calc-btn-pro" style="background: linear-gradient(135deg, #00ff88, #00cc66); color: #000; font-size: 1.5em; font-weight: bold;">=</button>
                </div>
                
                <!-- Additional Functions Row -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px;">
                    <button onclick="calcInput('(')" class="calc-btn-pro" style="background: linear-gradient(135deg, #667eea, #764ba2);">(</button>
                    <button onclick="calcInput(')')" class="calc-btn-pro" style="background: linear-gradient(135deg, #667eea, #764ba2);">)</button>
                    <button onclick="calcDelete()" class="calc-btn-pro" style="background: linear-gradient(135deg, #ff8844, #ff6622);">‚å´</button>
                    <button onclick="calcFunc('fact')" class="calc-btn-pro" style="background: linear-gradient(135deg, #667eea, #764ba2);">n!</button>
                </div>
            </div>
            
            <!-- Variables Panel -->
            <div style="margin-top: 15px; background: rgba(138,43,226,0.1); border-radius: 10px; padding: 15px; border: 1px solid rgba(138,43,226,0.3);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="color: #ba55d3; font-size: 0.9em; font-weight: bold;">üìä VARIABLES</span>
                    <button onclick="showVariableInput()" style="padding: 5px 10px; background: rgba(138,43,226,0.2); border: 1px solid #ba55d3; border-radius: 5px; color: #ba55d3; cursor: pointer; font-size: 0.8em;">+ Add Variable</button>
                </div>
                
                <!-- Variable Input Form (Hidden by default) -->
                <div id="variableInput" style="display: none; margin-bottom: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <input type="text" id="varName" placeholder="Variable name (e.g., x)" maxlength="10" style="width: 100px; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid #ba55d3; border-radius: 5px; color: white; margin-right: 5px; font-family: 'Courier New', monospace;">
                    <input type="text" id="varValue" placeholder="Value" style="width: 100px; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid #ba55d3; border-radius: 5px; color: white; margin-right: 5px; font-family: 'Courier New', monospace;">
                    <button onclick="addVariable()" style="padding: 8px 12px; background: #ba55d3; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 0.85em;">Save</button>
                    <button onclick="hideVariableInput()" style="padding: 8px 12px; background: rgba(255,68,68,0.5); border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 0.85em;">Cancel</button>
                </div>
                
                <!-- Variables List -->
                <div id="variablesList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; max-height: 120px; overflow-y: auto;">
                    <div style="color: #888; text-align: center; padding: 15px; grid-column: span 2; font-size: 0.85em;">No variables yet</div>
                </div>
            </div>
            
            <!-- History Panel -->
            <div style="margin-top: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; border: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="color: #888; font-size: 0.9em; font-weight: bold;">üìú HISTORY</span>
                    <button onclick="clearCalcHistory()" style="padding: 5px 10px; background: rgba(255,68,68,0.2); border: 1px solid #ff4444; border-radius: 5px; color: #ff4444; cursor: pointer; font-size: 0.8em;">Clear</button>
                </div>
                <div id="calcHistory" style="max-height: 120px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.85em;">
                    <div style="color: #666; text-align: center; padding: 20px;">No calculations yet</div>
                </div>
            </div>
            
            <button onclick="closeCalculator()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #00d4ff, #0099ff); color: white; border: none; border-radius: 10px; font-weight: bold; font-size: 1.1em; cursor: pointer; margin-top: 15px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                CLOSE
            </button>
        </div>
    </div>

    <!-- Update Log Modal -->
    <div class="shop-modal" id="updateLogModal">
        <div class="shop-content" style="max-width: 700px;">
            <h2 style="text-align: center; margin-bottom: 20px;">üìã UPDATE LOG</h2>
            
            <div id="updateLogContent" style="max-height: 500px; overflow-y: auto; padding-right: 10px;">
                <!-- Version 1.5 - Current -->
                <div style="background: rgba(255,255,255,0.05); border-left: 4px solid #00ff88; padding: 20px; margin-bottom: 20px; border-radius: 10px;">
                    <h3 style="color: #00ff88; margin: 0 0 10px 0;">üéÆ Version 1.5 - Latest Update</h3>
                    <p style="color: #888; margin: 0 0 15px 0; font-size: 14px;">January 2026</p>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">‚ú® New Games Added:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>üß© <strong>Block Puzzle</strong> - Tetris-style block placement with power-ups!</li>
                        <li>üî¢ <strong>Number Match</strong> - Classic 2048 gameplay</li>
                        <li>üß† <strong>Pattern Memory</strong> - Simon Says style memory challenge</li>
                        <li>üé® <strong>Color Sort</strong> - Ball sorting puzzle game</li>
                        <li>üéñÔ∏è <strong>Tank Battle</strong> - Like Awesome Tanks! Arena combat with destructible walls!</li>
                        <li>üèóÔ∏è <strong>Tower Defense</strong> - Like Blooket TD2! Multiple lanes and varied towers!</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üî• Major Features:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>üí∞ <strong>Block Puzzle Shop</strong> - Buy power-ups with earned coins!</li>
                        <li>üí£ <strong>4 Power-ups</strong> - Bomb, Lightning, Hammer, Shuffle</li>
                        <li>üè™ <strong>In-Game Currency</strong> - Earn and spend coins in Block Puzzle</li>
                        <li>üìã <strong>Update Log</strong> - Track all updates and new games!</li>
                        <li>üéñÔ∏è <strong>Tank Battle Remastered</strong> - Levels, bases, destructible walls, upgrades!</li>
                        <li>üèóÔ∏è <strong>Tower Defense Remastered</strong> - 3 lanes, 4 tower types, varied enemies!</li>
                        <li>üé≠ <strong>Tab Cloak Fixed</strong> - No more security errors!</li>
                        <li>‚ö° <strong>Speed Runner Rebalanced</strong> - Much more playable!</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üêõ Bugs Fixed:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>Fixed Tunnel Rush IndexSizeError crashes</li>
                        <li>Fixed Zig Zag instant game over</li>
                        <li>Fixed restart buttons returning to hub instead of restarting</li>
                        <li>Fixed Tab Cloak security errors</li>
                        <li>Fixed Speed Runner difficulty (was nearly impossible)</li>
                        <li>Fixed Color Sort navigation issues</li>
                        <li>Fixed Tower Defense PATH array syntax error</li>
                        <li>General performance improvements</li>
                        <li>Improved game stability</li>
                        <li>Better collision detection</li>
                    </ul>
                </div>

                <!-- Version 1.4 -->
                <div style="background: rgba(255,255,255,0.05); border-left: 4px solid #667eea; padding: 20px; margin-bottom: 20px; border-radius: 10px;">
                    <h3 style="color: #667eea; margin: 0 0 10px 0;">üéÆ Version 1.4</h3>
                    <p style="color: #888; margin: 0 0 15px 0; font-size: 14px;">December 2025</p>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">‚ú® New Games Added:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>üöÄ <strong>Tunnel Rush</strong> - Lane-based dodging game</li>
                        <li>‚ö° <strong>Zig Zag</strong> - Bouncing ball platformer</li>
                        <li>üèÄ <strong>Bounce Master</strong> - Perfect timing bounces</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üî• Features:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>üî¢ Advanced Calculator with variables</li>
                        <li>üé≠ Tab Cloak system</li>
                        <li>‚ú® Particle effects in games</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üêõ Bugs Fixed:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>General stability improvements</li>
                        <li>Performance optimizations</li>
                    </ul>
                </div>

                <!-- Version 1.3 -->
                <div style="background: rgba(255,255,255,0.05); border-left: 4px solid #f093fb; padding: 20px; margin-bottom: 20px; border-radius: 10px;">
                    <h3 style="color: #f093fb; margin: 0 0 10px 0;">üéÆ Version 1.3</h3>
                    <p style="color: #888; margin: 0 0 15px 0; font-size: 14px;">November 2025</p>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">‚ú® New Games Added:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>‚≠ï <strong>Circle Dash</strong> - Navigate circular obstacles</li>
                        <li>üî¥ <strong>Laser Dodge</strong> - Avoid laser beams</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üî• Features:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>üé® Visual Game Creator (Scratch-style)</li>
                        <li>üè™ Shop system with skins</li>
                        <li>üéØ Quest system</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üêõ Bugs Fixed:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>Game collision improvements</li>
                        <li>UI responsiveness fixes</li>
                    </ul>
                </div>

                <!-- Version 1.2 -->
                <div style="background: rgba(255,255,255,0.05); border-left: 4px solid #ffd700; padding: 20px; margin-bottom: 20px; border-radius: 10px;">
                    <h3 style="color: #ffd700; margin: 0 0 10px 0;">üéÆ Version 1.2</h3>
                    <p style="color: #888; margin: 0 0 15px 0; font-size: 14px;">October 2025</p>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">‚ú® New Games Added:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>üîÑ <strong>Gravity Flip</strong> - Geometry Dash style</li>
                        <li>üéØ <strong>Neon Breaker</strong> - Brick breaker with power-ups</li>
                        <li>‚ö° <strong>Speed Runner</strong> - Endless runner</li>
                        <li>ü¶ò <strong>Pixel Jump</strong> - Platformer challenge</li>
                        <li>üåà <strong>Color Switch</strong> - Color matching game</li>
                    </ul>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üêõ Bugs Fixed:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>Initial release bug fixes</li>
                        <li>Performance improvements</li>
                    </ul>
                </div>

                <!-- Version 1.1 -->
                <div style="background: rgba(255,255,255,0.05); border-left: 4px solid #888; padding: 20px; margin-bottom: 20px; border-radius: 10px;">
                    <h3 style="color: #888; margin: 0 0 10px 0;">üéÆ Version 1.1</h3>
                    <p style="color: #888; margin: 0 0 15px 0; font-size: 14px;">September 2025</p>
                    
                    <h4 style="color: white; margin: 15px 0 10px 0;">üéâ Initial Release:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: rgba(255,255,255,0.8);">
                        <li>Game hub system created</li>
                        <li>Basic UI and navigation</li>
                        <li>Category filtering</li>
                        <li>Search functionality</li>
                    </ul>
                </div>
            </div>
            
            <button onclick="closeUpdateLog()" style="width: 100%; padding: 15px; margin-top: 20px; background: white; color: #667eea; border: none; border-radius: 20px; font-weight: bold; font-size: 1.2em; cursor: pointer;">
                CLOSE
            </button>
        </div>
    </div>

    <!-- Tab Cloak Menu -->
    <div class="username-modal" id="cloakModal">
        <div class="username-content" style="max-width: 500px;">
            <h2>üé≠ TAB CLOAK</h2>
            <p style="margin: 15px 0; opacity: 0.9;">Disguise this tab to look like something else!</p>
            
            <div style="display: grid; gap: 10px; margin: 20px 0;">
                <button onclick="setCloak('google-classroom')" style="padding: 15px; background: #4CAF50; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    üìö Google Classroom
                </button>
                <button onclick="setCloak('google-drive')" style="padding: 15px; background: #1a73e8; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    üìÅ Google Drive
                </button>
                <button onclick="setCloak('google-docs')" style="padding: 15px; background: #4285F4; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    üìù Google Docs
                </button>
                <button onclick="setCloak('canvas')" style="padding: 15px; background: #E13F2B; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    üé® Canvas LMS
                </button>
                <button onclick="setCloak('schoology')" style="padding: 15px; background: #2B5797; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    üè´ Schoology
                </button>
                <button onclick="setCloak('reset')" style="padding: 15px; background: #ff4444; color: white; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    üîÑ Reset to Normal
                </button>
            </div>
            
            <button onclick="closeCloakMenu()" style="width: 100%; padding: 12px; background: white; color: #667eea; border: none; border-radius: 10px; font-weight: bold; font-size: 1em; cursor: pointer; margin-top: 10px;">
                CLOSE
            </button>
        </div>
    </div>

    <script>
        // Game definitions
        const games = [
            // ARCADE GAMES
            {id: 1, name: 'Gravity Flip', desc: 'Flip gravity to avoid obstacles!', category: 'arcade', icon: 'üîÑ'},
            {id: 2, name: 'Neon Breaker', desc: 'Break all the neon blocks!', category: 'arcade', icon: 'üéØ'},
            {id: 3, name: 'Speed Runner', desc: 'How fast can you run?', category: 'arcade', icon: '‚ö°'},
            {id: 4, name: 'Pixel Jump', desc: 'Jump through pixel worlds!', category: 'arcade', icon: 'ü¶ò'},
            {id: 5, name: 'Color Switch', desc: 'Match the colors!', category: 'arcade', icon: 'üåà'},
            {id: 6, name: 'Circle Dash', desc: 'Dash in circles!', category: 'arcade', icon: '‚≠ï'},
            {id: 7, name: 'Laser Dodge', desc: 'Dodge the lasers!', category: 'arcade', icon: 'üî¥'},
            {id: 8, name: 'Bounce Master', desc: 'Perfect your bounces!', category: 'arcade', icon: 'üèÄ'},
            {id: 9, name: 'Tunnel Rush', desc: 'Rush through tunnels!', category: 'arcade', icon: 'üöÄ'},
            {id: 10, name: 'Zig Zag', desc: 'Stay on the zig zag path!', category: 'arcade', icon: '‚ö°'},
            
            // PUZZLE GAMES
            {id: 11, name: 'Block Puzzle', desc: 'Fit the blocks!', category: 'puzzle', icon: 'üß©'},
            {id: 12, name: 'Number Match', desc: 'Match the numbers!', category: 'puzzle', icon: 'üî¢'},
            {id: 13, name: 'Pattern Memory', desc: 'Remember the pattern!', category: 'puzzle', icon: 'üß†'},
            {id: 14, name: 'Color Sort', desc: 'Sort by colors!', category: 'puzzle', icon: 'üé®'},
            {id: 15, name: 'Tank Battle', desc: 'Destroy enemy tanks!', category: 'action', icon: 'üéñÔ∏è'},
            {id: 16, name: 'Tower Defense', desc: 'Build defensive towers!', category: 'strategy', icon: 'üèóÔ∏è'},
            {id: 17, name: 'Connect Dots', desc: 'Connect all dots!', category: 'puzzle', icon: '‚ö´'},
            {id: 16, name: 'Shape Shifter', desc: 'Match the shapes!', category: 'puzzle', icon: 'üî∑'},
            {id: 17, name: 'Line Puzzle', desc: 'Draw the line!', category: 'puzzle', icon: 'üìè'},
            {id: 18, name: 'Tile Match', desc: 'Match tiles to clear!', category: 'puzzle', icon: 'üé¥'},
            {id: 19, name: 'Sudoku Mini', desc: 'Quick sudoku!', category: 'puzzle', icon: 'üî¢'},
            {id: 20, name: 'Maze Runner', desc: 'Find the exit!', category: 'puzzle', icon: 'üó∫Ô∏è'},
            
            // ACTION GAMES
            {id: 21, name: 'Space Shooter', desc: 'Shoot the asteroids!', category: 'action', icon: 'üöÄ'},
            {id: 22, name: 'Ninja Slash', desc: 'Slash with precision!', category: 'action', icon: '‚öîÔ∏è'},
            {id: 24, name: 'Asteroid Field', desc: 'Navigate asteroids!', category: 'action', icon: '‚òÑÔ∏è'},
            {id: 25, name: 'Plane Combat', desc: 'Dogfight in the sky!', category: 'action', icon: '‚úàÔ∏è'},
            {id: 26, name: 'Robot Wars', desc: 'Battle robots!', category: 'action', icon: 'ü§ñ'},
            {id: 27, name: 'Zombie Survival', desc: 'Survive the zombies!', category: 'action', icon: 'üßü'},
            {id: 28, name: 'Arrow Defense', desc: 'Defend with arrows!', category: 'action', icon: 'üèπ'},
            {id: 29, name: 'Boss Rush', desc: 'Fight epic bosses!', category: 'action', icon: 'üëπ'},
            {id: 30, name: 'Pixel Fighter', desc: 'Pixel combat!', category: 'action', icon: 'ü•ä'},
            
            // STRATEGY GAMES
            {id: 32, name: 'Chess Mini', desc: 'Quick chess!', category: 'strategy', icon: '‚ôüÔ∏è'},
            {id: 33, name: 'Base Builder', desc: 'Build your base!', category: 'strategy', icon: 'üè∞'},
            {id: 34, name: 'Resource Manager', desc: 'Manage resources!', category: 'strategy', icon: 'üíé'},
            {id: 35, name: 'Card Battle', desc: 'Strategic cards!', category: 'strategy', icon: 'üÉè'},
            {id: 36, name: 'Army Control', desc: 'Command your army!', category: 'strategy', icon: '‚öîÔ∏è'},
            {id: 37, name: 'Territory War', desc: 'Capture territory!', category: 'strategy', icon: 'üó∫Ô∏è'},
            {id: 38, name: 'Evolution Game', desc: 'Evolve your species!', category: 'strategy', icon: 'ü¶é'},
            {id: 39, name: 'Kingdom Builder', desc: 'Build a kingdom!', category: 'strategy', icon: 'üëë'},
            {id: 40, name: 'Trade Master', desc: 'Master trading!', category: 'strategy', icon: 'üí∞'},
            
            // MORE ARCADE
            {id: 41, name: 'Flappy Clone', desc: 'Flap through pipes!', category: 'arcade', icon: 'üê¶'},
            {id: 42, name: 'Cube Jumper', desc: 'Jump the cubes!', category: 'arcade', icon: 'üì¶'},
            {id: 43, name: 'Spiral Climb', desc: 'Climb the spiral!', category: 'arcade', icon: 'üåÄ'},
            {id: 44, name: 'Coin Collector', desc: 'Collect all coins!', category: 'arcade', icon: 'ü™ô'},
            {id: 45, name: 'Sky Diver', desc: 'Dive through clouds!', category: 'arcade', icon: 'ü™Ç'},
            {id: 46, name: 'Rocket League', desc: 'Score with rockets!', category: 'arcade', icon: 'üöÄ'},
            {id: 47, name: 'Ping Pong Pro', desc: 'Master ping pong!', category: 'arcade', icon: 'üèì'},
            {id: 48, name: 'Race Track', desc: 'Race to the finish!', category: 'arcade', icon: 'üèÅ'},
            {id: 49, name: 'Ball Drop', desc: 'Drop the balls!', category: 'arcade', icon: '‚öΩ'},
            {id: 17, name: 'Pixel Painter', desc: 'Create pixel art!', category: 'creative', icon: 'üé®'},
        ];

        // Username management
        let currentUsername = localStorage.getItem('ultimateHubUsername') || 'Guest';
        document.getElementById('displayUsername').textContent = currentUsername;

        function openUsernameModal() {
            document.getElementById('usernameModal').classList.add('active');
            document.getElementById('currentUsername').textContent = currentUsername;
            document.getElementById('usernameInput').value = '';
        }

        function closeUsernameModal() {
            document.getElementById('usernameModal').classList.remove('active');
        }

        // Global Chat System
        let chatRefreshInterval = null;

        function openChat() {
            if (currentUsername === 'Guest') {
                alert('Please set a username first to use chat!');
                openUsernameModal();
                return;
            }

            document.getElementById('chatModal').classList.add('active');
            loadChatMessages();
            updateOnlineCount();
            
            // Auto-refresh chat every 3 seconds
            chatRefreshInterval = setInterval(() => {
                loadChatMessages();
                updateOnlineCount();
            }, 3000);
        }

        function closeChat() {
            document.getElementById('chatModal').classList.remove('active');
            if (chatRefreshInterval) {
                clearInterval(chatRefreshInterval);
                chatRefreshInterval = null;
            }
        }

        function getChatMessages() {
            const saved = localStorage.getItem('globalChat');
            return saved ? JSON.parse(saved) : [];
        }

        function saveChatMessages(messages) {
            // Keep only last 100 messages
            if (messages.length > 100) {
                messages = messages.slice(-100);
            }
            localStorage.setItem('globalChat', JSON.stringify(messages));
        }

        function sendMessage() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();

            if (!text) return;

            if (currentUsername === 'Guest') {
                alert('Please set a username first!');
                return;
            }

            const message = {
                id: Date.now(),
                username: currentUsername,
                text: text,
                timestamp: new Date().toISOString()
            };

            let messages = getChatMessages();
            messages.push(message);
            saveChatMessages(messages);

            input.value = '';
            loadChatMessages();
            
            // Scroll to bottom
            const container = document.getElementById('chatMessages');
            container.scrollTop = container.scrollHeight;
        }

        function loadChatMessages() {
            const messages = getChatMessages();
            const container = document.getElementById('chatMessages');
            
            if (messages.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; opacity: 0.7; padding: 40px 20px;">
                        <p style="font-size: 1.2em; margin-bottom: 10px;">üåç Welcome to Global Chat!</p>
                        <p style="font-size: 0.9em;">Be the first to say something!</p>
                    </div>
                `;
                return;
            }

            // Get scroll position
            const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

            container.innerHTML = '';
            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message ' + (msg.username === currentUsername ? 'own' : 'other');
                
                const date = new Date(msg.timestamp);
                const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                messageDiv.innerHTML = `
                    <div class="chat-username">${msg.username === currentUsername ? 'You' : msg.username}</div>
                    <div class="chat-text">${escapeHtml(msg.text)}</div>
                    <div class="chat-time">${timeStr}</div>
                `;
                
                container.appendChild(messageDiv);
            });

            // Auto-scroll if was at bottom
            if (wasAtBottom) {
                container.scrollTop = container.scrollHeight;
            }
        }

        function updateOnlineCount() {
            // Simulate online count (in reality, would need a server)
            // Count unique users who sent messages in last 5 minutes
            const messages = getChatMessages();
            const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
            
            const recentUsers = new Set();
            messages.forEach(msg => {
                const msgTime = new Date(msg.timestamp).getTime();
                if (msgTime > fiveMinutesAgo) {
                    recentUsers.add(msg.username);
                }
            });

            // Add current user
            if (currentUsername !== 'Guest') {
                recentUsers.add(currentUsername);
            }

            document.getElementById('onlineCount').textContent = recentUsers.size;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function saveUsername() {
            const input = document.getElementById('usernameInput').value.trim();
            if (!input) {
                alert('Please enter a username!');
                return;
            }
            
            // Simple validation: just check it's not empty and not "Guest"
            if (input.toLowerCase() === 'guest') {
                alert('Cannot use "Guest" as username. Please choose a different name.');
                return;
            }
            
            // Update leaderboards with new username if user is changing their name (local only)
            if (currentUsername !== 'Guest' && currentUsername.toLowerCase() !== input.toLowerCase()) {
                for (let gameId = 1; gameId <= 50; gameId++) {
                    let leaderboard = getLocalLeaderboard(gameId);
                    let updated = false;
                    
                    leaderboard = leaderboard.map(entry => {
                        if (entry.username.toLowerCase() === currentUsername.toLowerCase()) {
                            updated = true;
                            return {
                                ...entry,
                                username: input
                            };
                        }
                        return entry;
                    });
                    
                    if (updated) {
                        const key = 'leaderboard_game_' + gameId;
                        localStorage.setItem(key, JSON.stringify(leaderboard));
                    }
                }
            }
            
            currentUsername = input;
            localStorage.setItem('ultimateHubUsername', currentUsername);
            document.getElementById('displayUsername').textContent = currentUsername;
            closeUsernameModal();
            showNotification(`Username set to: ${currentUsername}`);
        }

        // Custom Games Management
        let editingGameId = null;

        function getCustomGames() {
            const saved = localStorage.getItem('customGames');
            return saved ? JSON.parse(saved) : [];
        }

        function saveCustomGames(games) {
            localStorage.setItem('customGames', JSON.stringify(games));
        }

        function openCustomGames() {
            document.getElementById('customGamesModal').classList.add('active');
            renderCustomGames();
        }

        function closeCustomGames() {
            document.getElementById('customGamesModal').classList.remove('active');
        }

        // Scratch-Style Block System
        let workspaceBlocks = [];
        let draggedBlock = null;

        // Initialize drag and drop
        function initBlockSystem() {
            const workspace = document.getElementById('workspaceBlocks');
            
            // Make blocks draggable
            document.querySelectorAll('.code-block[draggable="true"]').forEach(block => {
                block.addEventListener('dragstart', handleDragStart);
                block.addEventListener('dragend', handleDragEnd);
            });

            // Workspace drop handlers
            workspace.addEventListener('dragover', handleDragOver);
            workspace.addEventListener('drop', handleDrop);
            workspace.addEventListener('dragleave', handleDragLeave);
        }

        function handleDragStart(e) {
            draggedBlock = e.target.cloneNode(true);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'copy';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            document.getElementById('workspaceBlocks').classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (e.target.id === 'workspaceBlocks') {
                document.getElementById('workspaceBlocks').classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const workspace = document.getElementById('workspaceBlocks');
            workspace.classList.remove('drag-over');

            if (draggedBlock) {
                // Clear placeholder text if first block
                if (workspaceBlocks.length === 0) {
                    workspace.innerHTML = '';
                }

                // Add block to workspace
                draggedBlock.classList.add('in-workspace');
                draggedBlock.removeAttribute('draggable');
                
                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-block';
                removeBtn.innerHTML = '‚úï';
                removeBtn.onclick = function() {
                    this.parentElement.remove();
                    updateBlockCount();
                    updateBlockGamePreview();
                };
                draggedBlock.appendChild(removeBtn);

                // Add change listeners to inputs
                draggedBlock.querySelectorAll('input, select').forEach(input => {
                    input.addEventListener('input', updateBlockGamePreview);
                    input.addEventListener('change', updateBlockGamePreview);
                });

                workspace.appendChild(draggedBlock);
                workspaceBlocks.push(draggedBlock);
                updateBlockCount();
                updateBlockGamePreview();
                draggedBlock = null;
            }
        }

        function updateBlockCount() {
            const count = document.getElementById('workspaceBlocks').children.length;
            document.getElementById('blockCount').textContent = count;
        }

        function updateBlockGamePreview() {
            const blocks = document.getElementById('workspaceBlocks').children;
            let config = {
                name: 'My Game',
                icon: 'üéÆ',
                description: 'Custom game',
                playerColor: '#00ff88',
                playerSize: 20,
                playerSpeed: 5,
                bgColor: '#000000',
                targetColor: '#ff4444',
                timeLimit: 30,
                pointsPer: 10,
                difficulty: 'Normal',
                gameType: null
            };

            // Read blocks
            for (let block of blocks) {
                const blockType = block.getAttribute('data-block');
                const inputs = block.querySelectorAll('.block-input');

                switch(blockType) {
                    case 'name':
                        if (inputs[0]) config.name = inputs[0].value || 'My Game';
                        break;
                    case 'icon':
                        if (inputs[0]) config.icon = inputs[0].value || 'üéÆ';
                        break;
                    case 'description':
                        if (inputs[0]) config.description = inputs[0].value || 'Custom game';
                        break;
                    case 'player-color':
                        if (inputs[0]) config.playerColor = inputs[0].value;
                        break;
                    case 'player-size':
                        if (inputs[0]) config.playerSize = parseInt(inputs[0].value) || 20;
                        break;
                    case 'player-speed':
                        if (inputs[0]) config.playerSpeed = parseInt(inputs[0].value) || 5;
                        break;
                    case 'bg-color':
                        if (inputs[0]) config.bgColor = inputs[0].value;
                        break;
                    case 'target-color':
                        if (inputs[0]) config.targetColor = inputs[0].value;
                        break;
                    case 'time-limit':
                        if (inputs[0]) config.timeLimit = parseInt(inputs[0].value) || 30;
                        break;
                    case 'points-per':
                        if (inputs[0]) config.pointsPer = parseInt(inputs[0].value) || 10;
                        break;
                    case 'difficulty':
                        if (inputs[0]) config.difficulty = inputs[0].value;
                        break;
                    case 'type-clicker':
                        config.gameType = 'clicker';
                        break;
                    case 'type-catcher':
                        config.gameType = 'catcher';
                        break;
                    case 'type-avoider':
                        config.gameType = 'avoider';
                        break;
                    case 'type-platformer':
                        config.gameType = 'platformer';
                        break;
                }
            }

            // Update preview
            document.getElementById('previewIcon').textContent = config.icon;
            document.getElementById('previewName').textContent = config.name;
            document.getElementById('previewDesc').textContent = config.description;

            // Update stats
            document.getElementById('statType').textContent = config.gameType || 'Not set';
            document.getElementById('statPlayer').textContent = `${config.playerSize}px, Speed ${config.playerSpeed}`;
            document.getElementById('statTheme').textContent = `BG: ${config.bgColor}`;

            // Simple preview on canvas
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = config.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player preview
            ctx.fillStyle = config.playerColor;
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, config.playerSize, 0, Math.PI * 2);
            ctx.fill();

            // Draw target
            if (config.gameType === 'clicker') {
                ctx.fillStyle = config.targetColor;
                ctx.fillRect(canvas.width / 2 - 30, 50, 60, 60);
            }
        }

        function clearWorkspace() {
            if (confirm('Clear all blocks from workspace?')) {
                document.getElementById('workspaceBlocks').innerHTML = '<p style="text-align: center; opacity: 0.5; margin-top: 100px;">Drag blocks here to start building your game!</p>';
                workspaceBlocks = [];
                updateBlockCount();
            }
        }

        function loadTemplate(type) {
            clearWorkspace();
            // Auto-add blocks for template
            showNotification(`Loading ${type} template...`);
            // This would add appropriate blocks automatically
        }

        function saveBlockGame() {
            const blocks = document.getElementById('workspaceBlocks').children;
            if (blocks.length === 0) {
                alert('Add blocks to workspace first!');
                return;
            }

            // Build config from blocks (same as updateBlockGamePreview)
            let config = {
                name: 'My Game',
                icon: 'üéÆ',
                description: 'Custom game',
                gameType: 'clicker',
                settings: {}
            };

            for (let block of blocks) {
                const blockType = block.getAttribute('data-block');
                const inputs = block.querySelectorAll('.block-input');
                // Collect settings...
            }

            // Save using existing system
            const customGames = JSON.parse(localStorage.getItem('customGames') || '[]');
            customGames.push({
                id: Date.now(),
                ...config
            });
            localStorage.setItem('customGames', JSON.stringify(customGames));

            showNotification('Game saved! üíæ');
            closeGameCreator();
            renderCustomGames();
        }

        function testBlockGame() {
            showNotification('Test game coming soon! (Preview shows how it looks)');
        }

        function openGameCreator(gameId = null) {
            editingGameId = gameId;
            document.getElementById('gameCreatorModal').classList.add('active');
            
            // Initialize block system
            setTimeout(() => {
                initBlockSystem();
                clearWorkspace();
                updateBlockGamePreview();
            }, 100);
            
            if (gameId !== null) {
                // Load existing game for editing - convert to blocks
                const games = getCustomGames();
                const game = games.find(g => g.id === gameId);
                if (game) {
                    showNotification('Game loaded! (Edit by changing blocks)');
                    // Could auto-populate workspace with blocks here
                }
            }
        }
        function closeGameCreator() {
            document.getElementById('gameCreatorModal').classList.remove('active');
            editingGameId = null;
        }

        // Update preview as user types

        function deleteCustomGame(gameId) {
            if (!confirm('Are you sure you want to delete this game? This cannot be undone!')) {
                return;
            }

            let games = getCustomGames();
            games = games.filter(g => g.id !== gameId);
            saveCustomGames(games);
            renderCustomGames();
            showNotification('Game deleted!');
        }

        function playCustomGame(gameId) {
            const games = getCustomGames();
            const game = games.find(g => g.id === gameId);
            if (!game) return;

            // Set up custom game as current game
            currentGame = {
                id: 'custom_' + gameId,
                name: game.name,
                icon: game.icon,
                description: game.description
            };

            document.getElementById('currentGameTitle').textContent = `${game.icon} ${game.name}`;
            document.getElementById('gameScreen').classList.add('active');
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Update coins display (custom games don't have coins/shop)
            document.getElementById('gameCoins').textContent = '0';
            document.querySelector('.shop-btn').style.display = 'none';

            // Generate and run game based on type and settings
            try {
                if (game.gameType === 'clicker') {
                    runClickerGame(game.settings);
                } else if (game.gameType === 'catcher') {
                    runCatcherGame(game.settings);
                } else if (game.gameType === 'avoider') {
                    runAvoiderGame(game.settings);
                } else if (game.gameType === 'jumper') {
                    runJumperGame(game.settings);
                } else if (game.gameType === 'shooter') {
                    runShooterGame(game.settings);
                }
            } catch (error) {
                alert('Error running game: ' + error.message);
                console.error('Custom game error:', error);
            }

            closeCustomGames();
        }

        function playCustomGameDirect(game) {
            currentGame = {
                id: 'test',
                name: game.name,
                icon: game.icon
            };

            document.getElementById('currentGameTitle').textContent = `${game.icon} ${game.name}`;
            document.getElementById('gameScreen').classList.add('active');
            document.getElementById('gameCreatorModal').classList.remove('active');
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            document.getElementById('gameCoins').textContent = '0';
            document.querySelector('.shop-btn').style.display = 'none';

            try {
                if (game.gameType === 'clicker') {
                    runClickerGame(game.settings);
                } else if (game.gameType === 'catcher') {
                    runCatcherGame(game.settings);
                } else if (game.gameType === 'avoider') {
                    runAvoiderGame(game.settings);
                } else if (game.gameType === 'collector') {
                    runCollectorGame(game.settings);
                } else if (game.gameType === 'reaction') {
                    runReactionGame(game.settings);
                }
            } catch (error) {
                alert('Error running game: ' + error.message);
                console.error('Custom game error:', error);
            }
        }

        // CLICKER GAME TEMPLATE
        function runClickerGame(settings) {
            const bgColor = settings.bgColor || '#000000';
            const targetColor = settings.targetColor || '#00ff88';
            const targetSize = parseInt(settings.targetSize) || 50;
            const basePointsPerClick = parseInt(settings.pointsPerClick) || 1;
            const timeLimit = parseInt(settings.timeLimit) || 30;
            const targetType = settings.targetType || 'circle';
            const enableUpgrades = settings.enableUpgrades === 'true';
            
            let score = 0;
            let coins = 0;
            let timeLeft = timeLimit;
            let pointsPerClick = basePointsPerClick;
            let clickMultiplier = 1;
            let autoClicker = 0;
            let currentSize = targetSize;
            
            let target = {
                x: Math.random() * (canvas.width - currentSize) + currentSize/2,
                y: Math.random() * (canvas.height - currentSize) + currentSize/2
            };

            // Upgrades
            const upgrades = [
                { id: 'double', name: '2x Points', cost: 50, owned: false, effect: () => clickMultiplier = 2 },
                { id: 'triple', name: '3x Points', cost: 150, owned: false, effect: () => clickMultiplier = 3 },
                { id: 'mega', name: '5x Points', cost: 400, owned: false, effect: () => clickMultiplier = 5 },
                { id: 'auto1', name: 'Auto Click +1/s', cost: 100, owned: false, effect: () => autoClicker += 1 },
                { id: 'auto5', name: 'Auto Click +5/s', cost: 300, owned: false, effect: () => autoClicker += 5 },
                { id: 'bigger', name: 'Bigger Target', cost: 75, owned: false, effect: () => currentSize += 20 },
            ];

            const clickHandler = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if clicking upgrade button
                if (enableUpgrades && y > 420) {
                    const upgradeIndex = Math.floor(x / 135);
                    if (upgradeIndex < upgrades.length) {
                        const upgrade = upgrades[upgradeIndex];
                        if (!upgrade.owned && coins >= upgrade.cost) {
                            coins -= upgrade.cost;
                            upgrade.owned = true;
                            upgrade.effect();
                        }
                    }
                    return;
                }
                
                const dist = Math.hypot(x - target.x, y - target.y);
                if (dist < currentSize) {
                    const points = pointsPerClick * clickMultiplier;
                    score += points;
                    coins += Math.floor(points / 5);
                    target.x = Math.random() * (canvas.width - currentSize) + currentSize/2;
                    target.y = Math.random() * ((enableUpgrades ? 400 : 600) - currentSize) + currentSize/2;
                    
                    // Particle effect
                    for (let i = 0; i < 5; i++) {
                        particles.push({
                            x: target.x,
                            y: target.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 20,
                            color: targetColor
                        });
                    }
                }
            };

            canvas.addEventListener('click', clickHandler);

            let particles = [];
            let lastAutoClick = Date.now();

            const timer = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    canvas.removeEventListener('click', clickHandler);
                }
            }, 1000);

            function update() {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (timeLeft <= 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 40);
                    ctx.font = '30px Arial';
                    ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 20);
                    ctx.fillText(`Coins Earned: ${coins}`, canvas.width/2, canvas.height/2 + 60);
                    ctx.textAlign = 'left';
                    return;
                }

                // Auto clicker
                if (autoClicker > 0 && Date.now() - lastAutoClick > 1000) {
                    score += autoClicker * pointsPerClick * clickMultiplier;
                    coins += Math.floor((autoClicker * pointsPerClick * clickMultiplier) / 5);
                    lastAutoClick = Date.now();
                }

                // Update particles
                particles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                // Draw particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 20;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw target
                ctx.fillStyle = targetColor;
                ctx.shadowColor = targetColor;
                ctx.shadowBlur = 20;
                
                if (targetType === 'circle') {
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                } else if (targetType === 'square') {
                    ctx.fillRect(target.x - currentSize, target.y - currentSize, currentSize * 2, currentSize * 2);
                } else if (targetType === 'star') {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                        const x = target.x + Math.cos(angle) * currentSize;
                        const y = target.y + Math.sin(angle) * currentSize;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;

                // Draw UI
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(5, 5, 350, 110);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${score}`, 15, 35);
                ctx.fillText(`Time: ${timeLeft}s`, 15, 65);
                ctx.fillText(`Coins: ${coins}ü™ô`, 15, 95);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width - 260, 5, 255, 110);
                
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(`Click Power: ${pointsPerClick * clickMultiplier}`, canvas.width - 250, 30);
                if (autoClicker > 0) {
                    ctx.fillText(`Auto: +${autoClicker}/s`, canvas.width - 250, 55);
                }
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.fillText('Click the target!', canvas.width - 250, 80);
                if (enableUpgrades) {
                    ctx.fillText('Buy upgrades below!', canvas.width - 250, 100);
                }

                // Draw upgrades
                if (enableUpgrades) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(0, 420, canvas.width, 180);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('‚¨ÜÔ∏è UPGRADES', 15, 445);
                    
                    upgrades.forEach((upgrade, i) => {
                        const x = 10 + i * 135;
                        const y = 460;
                        
                        if (upgrade.owned) {
                            ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                        } else if (coins >= upgrade.cost) {
                            ctx.fillStyle = 'rgba(255, 255, 136, 0.2)';
                        } else {
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
                        }
                        
                        ctx.fillRect(x, y, 125, 120);
                        ctx.strokeStyle = upgrade.owned ? '#00ff88' : (coins >= upgrade.cost ? '#ffff88' : '#666');
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, y, 125, 120);
                        
                        ctx.fillStyle = upgrade.owned ? '#00ff88' : '#fff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(upgrade.name, x + 62, y + 25);
                        
                        if (upgrade.owned) {
                            ctx.font = 'bold 16px Arial';
                            ctx.fillText('‚úì OWNED', x + 62, y + 70);
                        } else {
                            ctx.font = 'bold 18px Arial';
                            ctx.fillStyle = coins >= upgrade.cost ? '#ffff00' : '#999';
                            ctx.fillText(`${upgrade.cost}ü™ô`, x + 62, y + 60);
                            ctx.font = '12px Arial';
                            ctx.fillStyle = coins >= upgrade.cost ? '#fff' : '#666';
                            ctx.fillText('CLICK TO BUY', x + 62, y + 80);
                        }
                        
                        ctx.textAlign = 'left';
                    });
                }

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // CATCHER GAME TEMPLATE
        function runCatcherGame(settings) {
            const bgColor = settings.bgColor || '#000000';
            const basketColor = settings.basketColor || '#00ff88';
            const basketSize = parseInt(settings.basketSize) || 80;
            const goodItem = settings.goodItem || '‚≠ê';
            const badItem = settings.badItem || 'üí£';
            const fallSpeed = parseInt(settings.fallSpeed) || 3;
            const goodPoints = parseInt(settings.goodPoints) || 10;
            const badPoints = parseInt(settings.badPoints) || -5;

            let basket = {x: 400, y: 550, w: basketSize, h: 20};
            let items = [];
            let score = 0;
            let gameOver = false;

            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                basket.x = e.clientX - rect.left - basket.w / 2;
            };

            function spawnItem() {
                if (Math.random() < 0.02) {
                    items.push({
                        x: Math.random() * (canvas.width - 40) + 20,
                        y: -40,
                        type: Math.random() < 0.7 ? 'good' : 'bad',
                        icon: Math.random() < 0.7 ? goodItem : badItem
                    });
                }
            }

            function update() {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (gameOver) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2);
                    ctx.font = '30px Arial';
                    ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 50);
                    ctx.textAlign = 'left';
                    return;
                }

                spawnItem();

                // Move and check items
                items.forEach((item, i) => {
                    item.y += fallSpeed;

                    if (item.y > canvas.height) {
                        items.splice(i, 1);
                    }

                    // Catch check
                    if (item.y + 20 > basket.y && item.x > basket.x && item.x < basket.x + basket.w) {
                        if (item.type === 'good') {
                            score += goodPoints;
                        } else {
                            score += badPoints;
                            if (score < 0) gameOver = true;
                        }
                        items.splice(i, 1);
                    }
                });

                // Draw items
                ctx.font = '40px Arial';
                items.forEach(item => {
                    ctx.fillText(item.icon, item.x - 20, item.y);
                });

                // Draw basket
                ctx.fillStyle = basketColor;
                ctx.fillRect(basket.x, basket.y, basket.w, basket.h);

                // UI
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${score}`, 20, 40);

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // AVOIDER GAME TEMPLATE
        function runAvoiderGame(settings) {
            const bgColor = settings.bgColor || '#000000';
            const playerColor = settings.playerColor || '#00ff88';
            const obstacleColor = settings.obstacleColor || '#ff4444';
            const playerSize = parseInt(settings.playerSize) || 30;
            const obstacleSpeed = parseInt(settings.obstacleSpeed) || 3;

            let player = {x: 400, y: 300, size: playerSize};
            let obstacles = [];
            let score = 0;
            let gameOver = false;

            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                player.x = e.clientX - rect.left;
                player.y = e.clientY - rect.top;
            };

            function spawnObstacle() {
                if (Math.random() < 0.02) {
                    const side = Math.floor(Math.random() * 4);
                    let x, y, vx, vy;
                    
                    if (side === 0) { x = Math.random() * canvas.width; y = -20; vx = 0; vy = obstacleSpeed; }
                    else if (side === 1) { x = canvas.width + 20; y = Math.random() * canvas.height; vx = -obstacleSpeed; vy = 0; }
                    else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 20; vx = 0; vy = -obstacleSpeed; }
                    else { x = -20; y = Math.random() * canvas.height; vx = obstacleSpeed; vy = 0; }
                    
                    obstacles.push({x, y, vx, vy, size: 30});
                }
            }

            function update() {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (gameOver) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2);
                    ctx.font = '30px Arial';
                    ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 50);
                    ctx.textAlign = 'left';
                    return;
                }

                spawnObstacle();
                score++;

                obstacles.forEach((obs, i) => {
                    obs.x += obs.vx;
                    obs.y += obs.vy;

                    if (obs.x < -50 || obs.x > canvas.width + 50 || obs.y < -50 || obs.y > canvas.height + 50) {
                        obstacles.splice(i, 1);
                    }

                    // Collision
                    const dist = Math.hypot(player.x - obs.x, player.y - obs.y);
                    if (dist < player.size + obs.size) {
                        gameOver = true;
                    }

                    // Draw obstacle
                    ctx.fillStyle = obstacleColor;
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, obs.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw player
                ctx.fillStyle = playerColor;
                ctx.shadowColor = playerColor;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // UI
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${Math.floor(score / 10)}`, 20, 40);

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // COLLECTOR GAME TEMPLATE
        function runCollectorGame(settings) {
            runCatcherGame(settings); // Same as catcher
        }

        // REACTION GAME TEMPLATE
        function runReactionGame(settings) {
            runClickerGame(settings); // Same as clicker
        }

        function renderCustomGames() {
            const games = getCustomGames();
            const container = document.getElementById('customGamesList');
            let score = 0;
            let timeLeft = s.timeLimit;
            let target = {x: 400, y: 300, size: s.targetSize};
            let gameOver = false;

            function randomizeTarget() {
                target.x = s.targetSize + Math.random() * (canvas.width - s.targetSize * 2);
                target.y = s.targetSize + Math.random() * (canvas.height - s.targetSize * 2);
            }

            canvas.onclick = (e) => {
                if (gameOver) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const dist = Math.hypot(x - target.x, y - target.y);
                if (dist < target.size) {
                    score += s.pointsPerClick;
                    randomizeTarget();
                }
            };

            setInterval(() => {
                if (!gameOver) timeLeft--;
                if (timeLeft <= 0) gameOver = true;
            }, 1000);

            function update() {
                ctx.fillStyle = s.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!gameOver) {
                    // Draw target
                    ctx.fillStyle = s.targetColor;
                    ctx.shadowColor = s.targetColor;
                    ctx.shadowBlur = 20;
                    if (s.targetType === 'circle') {
                        ctx.beginPath();
                        ctx.arc(target.x, target.y, target.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (s.targetType === 'square') {
                        ctx.fillRect(target.x - target.size, target.y - target.size, target.size * 2, target.size * 2);
                    } else if (s.targetType === 'star') {
                        drawStar(ctx, target.x, target.y, 5, target.size, target.size/2);
                    }
                    ctx.shadowBlur = 0;

                    // Draw UI
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 30px Arial';
                    ctx.fillText('Score: ' + score, 20, 40);
                    ctx.fillText('Time: ' + timeLeft, 20, 80);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '35px Arial';
                    ctx.fillText('Final Score: ' + score, canvas.width/2, canvas.height/2 + 30);
                    ctx.textAlign = 'left';
                    return;
                }

                gameLoop = requestAnimationFrame(update);
            }
            update();
        }

        function runCatcherGame(s) {
            let score = 0;
            let basket = {x: 360, y: 520, w: s.basketSize, h: 20};
            let items = [];
            let gameOver = false;

            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                basket.x = e.clientX - rect.left - basket.w/2;
            };

            function spawnItem() {
                if (Math.random() < 0.02 && !gameOver) {
                    items.push({
                        x: Math.random() * (canvas.width - 40),
                        y: -40,
                        good: Math.random() < 0.7,
                        size: 30
                    });
                }
            }

            function update() {
                ctx.fillStyle = s.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!gameOver) {
                    spawnItem();

                    // Update items
                    items.forEach((item, i) => {
                        item.y += s.fallSpeed;
                        if (item.y > canvas.height) {
                            items.splice(i, 1);
                        }

                        // Check catch
                        if (item.y + item.size > basket.y && item.y < basket.y + basket.h &&
                            item.x + item.size > basket.x && item.x < basket.x + basket.w) {
                            items.splice(i, 1);
                            if (item.good) {
                                score += s.goodPoints;
                            } else {
                                score += s.badPoints;
                                if (score < 0) score = 0;
                            }
                        }
                    });

                    // Draw basket
                    ctx.fillStyle = s.basketColor;
                    ctx.fillRect(basket.x, basket.y, basket.w, basket.h);

                    // Draw items
                    items.forEach(item => {
                        ctx.font = '30px Arial';
                        ctx.fillText(item.good ? s.goodItem : s.badItem, item.x, item.y);
                    });

                    // Draw score
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 25px Arial';
                    ctx.fillText('Score: ' + score, 20, 40);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2);
                    ctx.textAlign = 'left';
                    return;
                }

                gameLoop = requestAnimationFrame(update);
            }
            update();
        }

        function runAvoiderGame(s) {
            let player = {x: 400, y: 300, size: s.playerSize};
            let obstacles = [];
            let score = 0;
            let gameOver = false;
            let keys = {};

            document.onkeydown = (e) => keys[e.key] = true;
            document.onkeyup = (e) => keys[e.key] = false;

            function spawnObstacle() {
                if (Math.random() < 0.02 && !gameOver) {
                    obstacles.push({
                        x: canvas.width,
                        y: Math.random() * canvas.height,
                        w: 30,
                        h: 30
                    });
                }
            }

            function update() {
                ctx.fillStyle = s.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!gameOver) {
                    // Move player
                    if (keys['ArrowLeft'] || keys['a']) player.x -= s.moveSpeed;
                    if (keys['ArrowRight'] || keys['d']) player.x += s.moveSpeed;
                    if (keys['ArrowUp'] || keys['w']) player.y -= s.moveSpeed;
                    if (keys['ArrowDown'] || keys['s']) player.y += s.moveSpeed;

                    player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
                    player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

                    spawnObstacle();
                    score++;

                    // Update obstacles
                    obstacles.forEach((obs, i) => {
                        obs.x -= s.obstacleSpeed;
                        if (obs.x + obs.w < 0) obstacles.splice(i, 1);

                        // Collision
                        if (player.x + player.size > obs.x && player.x - player.size < obs.x + obs.w &&
                            player.y + player.size > obs.y && player.y - player.size < obs.y + obs.h) {
                            gameOver = true;
                        }
                    });

                    // Draw player
                    ctx.fillStyle = s.playerColor;
                    ctx.fillRect(player.x - player.size, player.y - player.size, player.size * 2, player.size * 2);

                    // Draw obstacles
                    ctx.fillStyle = s.obstacleColor;
                    obstacles.forEach(obs => ctx.fillRect(obs.x, obs.y, obs.w, obs.h));

                    // Draw score
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 25px Arial';
                    ctx.fillText('Score: ' + Math.floor(score/10), 20, 40);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '30px Arial';
                    ctx.fillText('Score: ' + Math.floor(score/10), canvas.width/2, canvas.height/2 + 30);
                    ctx.textAlign = 'left';
                    return;
                }

                gameLoop = requestAnimationFrame(update);
            }
            update();
        }

        function runJumperGame(s) {
            let player = {x: 100, y: 400, w: 30, h: 30, vy: 0, jumping: false};
            let obstacles = [];
            let score = 0;
            let gameOver = false;

            document.onkeydown = (e) => {
                if ((e.key === ' ' || e.key === 'ArrowUp') && !player.jumping && !gameOver) {
                    player.vy = -s.jumpPower;
                    player.jumping = true;
                }
            };

            function spawnObstacle() {
                if (Math.random() < 0.02 && !gameOver) {
                    obstacles.push({x: canvas.width, y: 400, w: 30, h: 30});
                }
            }

            function update() {
                ctx.fillStyle = s.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!gameOver) {
                    // Gravity
                    player.vy += 0.8;
                    player.y += player.vy;

                    if (player.y >= 400) {
                        player.y = 400;
                        player.vy = 0;
                        player.jumping = false;
                    }

                    spawnObstacle();
                    score++;

                    // Update obstacles
                    obstacles.forEach((obs, i) => {
                        obs.x -= s.gameSpeed;
                        if (obs.x + obs.w < 0) {
                            obstacles.splice(i, 1);
                        }

                        // Collision
                        if (player.x < obs.x + obs.w && player.x + player.w > obs.x &&
                            player.y < obs.y + obs.h && player.y + player.h > obs.y) {
                            gameOver = true;
                        }
                    });

                    // Draw ground
                    ctx.fillStyle = s.groundColor;
                    ctx.fillRect(0, 430, canvas.width, 170);

                    // Draw player
                    ctx.fillStyle = s.playerColor;
                    ctx.fillRect(player.x, player.y, player.w, player.h);

                    // Draw obstacles
                    ctx.fillStyle = s.obstacleColor;
                    obstacles.forEach(obs => ctx.fillRect(obs.x, obs.y, obs.w, obs.h));

                    // Draw score
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 25px Arial';
                    ctx.fillText('Score: ' + Math.floor(score/10), 20, 40);
                } else {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '30px Arial';
                    ctx.fillText('Score: ' + Math.floor(score/10), canvas.width/2, canvas.height/2 + 30);
                    ctx.textAlign = 'left';
                    return;
                }

                gameLoop = requestAnimationFrame(update);
            }
            update();
        }

        function runShooterGame(s) {
            let player = {x: 400, y: 500, w: 40, h: 40};
            let enemies = [];
            let bullets = [];
            let score = 0;
            let gameOver = false;
            let keys = {};

            document.onkeydown = (e) => {
                keys[e.key] = true;
                if (e.key === ' ' && !gameOver) {
                    bullets.push({x: player.x + player.w/2, y: player.y, w: 5, h: 10, vy: -10});
                }
            };
            document.onkeyup = (e) => keys[e.key] = false;

            function spawnEnemy() {
                if (Math.random() < 0.02 && !gameOver) {
                    enemies.push({x: Math.random() * (canvas.width - 40), y: -40, w: 40, h: 40});
                }
            }

            function update() {
                ctx.fillStyle = s.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!gameOver) {
                    // Move player
                    if (keys['ArrowLeft'] || keys['a']) player.x -= s.playerSpeed;
                    if (keys['ArrowRight'] || keys['d']) player.x += s.playerSpeed;
                    player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));

                    spawnEnemy();

                    // Update bullets
                    bullets.forEach((b, i) => {
                        b.y += b.vy;
                        if (b.y < 0) bullets.splice(i, 1);
                    });

                    // Update enemies
                    enemies.forEach((e, i) => {
                        e.y += s.enemySpeed;
                        if (e.y > canvas.height) {
                            enemies.splice(i, 1);
                        }

                        // Check bullet collision
                        bullets.forEach((b, j) => {
                            if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                                enemies.splice(i, 1);
                                bullets.splice(j, 1);
                                score += s.pointsPerHit;
                            }
                        });

                        // Check player collision
                        if (e.x < player.x + player.w && e.x + e.w > player.x &&
                            e.y < player.y + player.h && e.y + e.h > player.y) {
                            gameOver = true;
                        }
                    });

                    // Draw player
                    ctx.fillStyle = s.playerColor;
                    ctx.fillRect(player.x, player.y, player.w, player.h);

                    // Draw bullets
                    ctx.fillStyle = s.bulletColor;
                    bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

                    // Draw enemies
                    ctx.fillStyle = s.enemyColor;
                    enemies.forEach(e => ctx.fillRect(e.x, e.y, e.w, e.h));

                    // Draw score
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 25px Arial';
                    ctx.fillText('Score: ' + score, 20, 40);
                    ctx.fillText('SPACE to shoot', 20, 580);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '30px Arial';
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 30);
                    ctx.textAlign = 'left';
                    return;
                }

                gameLoop = requestAnimationFrame(update);
            }
            update();
        }

        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        function renderCustomGames() {
            const games = getCustomGames();
            const container = document.getElementById('customGamesList');

            if (games.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 40px; opacity: 0.7; font-size: 1.2em;">No custom games yet! Click "Create New Game" to start building.</p>';
                return;
            }

            container.innerHTML = '';
            games.forEach(game => {
                const card = document.createElement('div');
                card.className = 'custom-game-card';
                
                card.innerHTML = `
                    <div class="custom-game-info">
                        <h3>${game.icon} ${game.name}</h3>
                        <p style="opacity: 0.8;">${game.description || 'No description'}</p>
                        <p style="font-size: 0.9em; opacity: 0.6;">Created: ${new Date(game.created).toLocaleDateString()}</p>
                    </div>
                    <div class="custom-game-actions">
                        <button class="play-custom-btn" onclick="playCustomGame(${game.id})">‚ñ∂ PLAY</button>
                        <button class="edit-custom-btn" onclick="openGameCreator(${game.id})">‚úèÔ∏è EDIT</button>
                        <button class="delete-custom-btn" onclick="deleteCustomGame(${game.id})">üóëÔ∏è DELETE</button>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }

        // Coins Management - Game Specific
        function getCoins(gameId) {
            const key = 'playerCoins_game_' + gameId;
            return parseInt(localStorage.getItem(key)) || 0;
        }

        function addCoins(gameId, amount) {
            const key = 'playerCoins_game_' + gameId;
            const current = getCoins(gameId);
            localStorage.setItem(key, current + amount);
            updateCoinsDisplay();
        }

        function spendCoins(gameId, amount) {
            const key = 'playerCoins_game_' + gameId;
            const current = getCoins(gameId);
            if (current >= amount) {
                localStorage.setItem(key, current - amount);
                updateCoinsDisplay();
                return true;
            }
            return false;
        }

        function updateCoinsDisplay() {
            if (!currentGame) return;
            const coins = getCoins(currentGame.id);
            document.getElementById('gameCoins').textContent = coins;
            if (document.getElementById('shopCoinsDisplay')) {
                document.getElementById('shopCoinsDisplay').textContent = coins;
            }
        }

        // Game-Specific Skins
        const gameSkins = {
            // Gravity Flip Skins
            1: [
                {id: 'default', name: 'Default', icon: 'üü©', price: 0, color: '#00ff88'},
                {id: 'red', name: 'Red Cube', icon: 'üü•', price: 100, color: '#ff4444'},
                {id: 'blue', name: 'Blue Cube', icon: 'üü¶', price: 100, color: '#4444ff'},
                {id: 'yellow', name: 'Yellow Cube', icon: 'üü®', price: 150, color: '#ffff44'},
                {id: 'purple', name: 'Purple Cube', icon: 'üü™', price: 150, color: '#ff44ff'},
                {id: 'orange', name: 'Orange Cube', icon: 'üüß', price: 200, color: '#ff8844'},
                {id: 'rainbow', name: 'Rainbow', icon: 'üåà', price: 500, color: 'rainbow'},
                {id: 'gold', name: 'Gold', icon: 'üü°', price: 1000, color: '#ffd700'},
                {id: 'diamond', name: 'Diamond', icon: 'üíé', price: 2000, color: '#00ffff'},
            ],
            // Neon Breaker Skins
            2: [
                {id: 'default', name: 'Default Paddle', icon: 'üü©', price: 0, color: '#00ff88'},
                {id: 'fire', name: 'Fire Paddle', icon: 'üî•', price: 150, color: '#ff4400'},
                {id: 'ice', name: 'Ice Paddle', icon: '‚ùÑÔ∏è', price: 150, color: '#00ddff'},
                {id: 'electric', name: 'Electric', icon: '‚ö°', price: 200, color: '#ffff00'},
                {id: 'plasma', name: 'Plasma', icon: 'üåü', price: 300, color: '#ff00ff'},
                {id: 'neon', name: 'Neon Glow', icon: '‚ú®', price: 500, color: 'rainbow'},
                {id: 'laser', name: 'Laser', icon: 'üî¥', price: 800, color: '#ff0000'},
                {id: 'cosmic', name: 'Cosmic', icon: 'üåå', price: 1500, color: '#4400ff'},
            ],
            // Speed Runner Skins
            3: [
                {id: 'default', name: 'Default Runner', icon: 'üü©', price: 0, color: '#00ff88'},
                {id: 'sonic', name: 'Sonic Speed', icon: 'üí®', price: 100, color: '#0088ff'},
                {id: 'flame', name: 'Flame Trail', icon: 'üî•', price: 150, color: '#ff6600'},
                {id: 'ghost', name: 'Ghost', icon: 'üëª', price: 200, color: '#ffffff'},
                {id: 'ninja', name: 'Ninja', icon: 'ü•∑', price: 250, color: '#000000'},
                {id: 'lightning', name: 'Lightning', icon: '‚ö°', price: 400, color: '#ffff00'},
                {id: 'turbo', name: 'Turbo', icon: 'üöÄ', price: 700, color: '#00ff00'},
                {id: 'quantum', name: 'Quantum', icon: 'üåÄ', price: 1200, color: 'rainbow'},
            ],
            // Pixel Jump Skins
            4: [
                {id: 'default', name: 'Default Jumper', icon: 'üü©', price: 0, color: '#00ff88'},
                {id: 'spring', name: 'Spring Jumper', icon: 'ü¶ò', price: 100, color: '#ff8844'},
                {id: 'cloud', name: 'Cloud Hopper', icon: '‚òÅÔ∏è', price: 150, color: '#ffffff'},
                {id: 'rocket', name: 'Rocket Jump', icon: 'üöÄ', price: 200, color: '#ff4444'},
                {id: 'bouncy', name: 'Super Bouncy', icon: 'üèÄ', price: 300, color: '#ff6600'},
                {id: 'antigravity', name: 'Anti-Gravity', icon: 'üåô', price: 500, color: '#4444ff'},
                {id: 'teleport', name: 'Teleporter', icon: '‚ú®', price: 900, color: 'rainbow'},
            ],
            // Color Switch Skins
            5: [
                {id: 'default', name: 'Default Ball', icon: '‚ö™', price: 0, color: '#ffffff'},
                {id: 'neon', name: 'Neon Ball', icon: 'üî¥', price: 100, color: '#ff0088'},
                {id: 'gradient', name: 'Gradient', icon: 'üåà', price: 200, color: 'rainbow'},
                {id: 'glowing', name: 'Glowing Orb', icon: '‚ú®', price: 250, color: '#ffff00'},
                {id: 'crystal', name: 'Crystal', icon: 'üíé', price: 400, color: '#00ffff'},
                {id: 'star', name: 'Star', icon: '‚≠ê', price: 600, color: '#ffd700'},
                {id: 'galaxy', name: 'Galaxy', icon: 'üåå', price: 1000, color: '#8800ff'},
            ]
        };

        // Game-Specific Quests
        const gameQuests = {
            // Gravity Flip Quests
            1: [
                {id: 'gf_distance_100', name: 'First Steps', desc: 'Reach 100m distance', target: 100, type: 'distance', reward: 50},
                {id: 'gf_distance_500', name: 'Going Far', desc: 'Reach 500m distance', target: 500, type: 'distance', reward: 150},
                {id: 'gf_distance_1000', name: 'Marathon', desc: 'Reach 1000m distance', target: 1000, type: 'distance', reward: 300},
                {id: 'gf_score_500', name: 'Score Seeker', desc: 'Score 500 points', target: 500, type: 'score', reward: 100},
                {id: 'gf_score_1000', name: 'Point Master', desc: 'Score 1000 points', target: 1000, type: 'score', reward: 200},
                {id: 'gf_score_2000', name: 'Score God', desc: 'Score 2000 points', target: 2000, type: 'score', reward: 400},
                {id: 'gf_score_5000', name: 'Gravity Legend', desc: 'Score 5000 points', target: 5000, type: 'score', reward: 1000},
            ],
            // Neon Breaker Quests
            2: [
                {id: 'nb_blocks_50', name: 'Block Breaker', desc: 'Break 50 blocks', target: 50, type: 'blocks', reward: 50},
                {id: 'nb_blocks_200', name: 'Destruction', desc: 'Break 200 blocks', target: 200, type: 'blocks', reward: 150},
                {id: 'nb_score_500', name: 'Breaker Score', desc: 'Score 500 points', target: 500, type: 'score', reward: 100},
                {id: 'nb_score_1000', name: 'High Breaker', desc: 'Score 1000 points', target: 1000, type: 'score', reward: 200},
                {id: 'nb_win', name: 'Victory!', desc: 'Win a game', target: 1, type: 'wins', reward: 300},
                {id: 'nb_perfect', name: 'Perfect Game', desc: 'Win without losing ball', target: 1, type: 'perfect', reward: 500},
            ],
            // Speed Runner Quests
            3: [
                {id: 'sr_distance_100', name: 'Speedster', desc: 'Run 100m', target: 100, type: 'distance', reward: 50},
                {id: 'sr_distance_500', name: 'Speed Demon', desc: 'Run 500m', target: 500, type: 'distance', reward: 150},
                {id: 'sr_obstacles_50', name: 'Dodger', desc: 'Dodge 50 obstacles', target: 50, type: 'obstacles', reward: 100},
                {id: 'sr_obstacles_200', name: 'Master Dodger', desc: 'Dodge 200 obstacles', target: 200, type: 'obstacles', reward: 250},
                {id: 'sr_speed_10', name: 'Fast Runner', desc: 'Reach 10x speed', target: 10, type: 'speed', reward: 200},
                {id: 'sr_speed_15', name: 'Sonic Speed', desc: 'Reach 15x speed', target: 15, type: 'speed', reward: 400},
            ],
            // Pixel Jump Quests
            4: [
                {id: 'pj_height_500', name: 'High Jumper', desc: 'Jump 500m high', target: 500, type: 'height', reward: 50},
                {id: 'pj_height_1000', name: 'Sky High', desc: 'Jump 1000m high', target: 1000, type: 'height', reward: 150},
                {id: 'pj_platforms_50', name: 'Platform Master', desc: 'Land on 50 platforms', target: 50, type: 'platforms', reward: 100},
                {id: 'pj_platforms_200', name: 'Jump King', desc: 'Land on 200 platforms', target: 200, type: 'platforms', reward: 250},
                {id: 'pj_score_500', name: 'Jump Score', desc: 'Score 500 points', target: 500, type: 'score', reward: 100},
                {id: 'pj_score_1500', name: 'Jump Legend', desc: 'Score 1500 points', target: 1500, type: 'score', reward: 300},
            ],
            // Color Switch Quests
            5: [
                {id: 'cs_score_500', name: 'Color Matcher', desc: 'Score 500 points', target: 500, type: 'score', reward: 50},
                {id: 'cs_score_1000', name: 'Color Master', desc: 'Score 1000 points', target: 1000, type: 'score', reward: 150},
                {id: 'cs_switches_50', name: 'Switch Pro', desc: 'Switch colors 50 times', target: 50, type: 'switches', reward: 100},
                {id: 'cs_switches_200', name: 'Switch Legend', desc: 'Switch colors 200 times', target: 200, type: 'switches', reward: 250},
                {id: 'cs_perfect_20', name: 'Perfect Match', desc: 'Match 20 in a row', target: 20, type: 'streak', reward: 300},
            ]
        };

        function getOwnedSkins(gameId) {
            const key = 'ownedSkins_game_' + gameId;
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : ['default'];
        }

        function getEquippedSkin(gameId) {
            const key = 'equippedSkin_game_' + gameId;
            return localStorage.getItem(key) || 'default';
        }

        function getActiveSkin(gameId) {
            const equippedId = getEquippedSkin(gameId);
            const skins = gameSkins[gameId] || [];
            const skin = skins.find(s => s.id === equippedId);
            return skin || null;
        }

        function buySkin(skinId) {
            if (!currentGame) return;
            const gameId = currentGame.id;
            const skins = gameSkins[gameId] || [];
            const skin = skins.find(s => s.id === skinId);
            if (!skin) return;

            const owned = getOwnedSkins(gameId);
            if (owned.includes(skinId)) {
                // Equip
                const key = 'equippedSkin_game_' + gameId;
                localStorage.setItem(key, skinId);
                renderShop();
                showNotification(`Equipped ${skin.name}!`);
            } else {
                // Buy with game-specific coins
                if (spendCoins(gameId, skin.price)) {
                    owned.push(skinId);
                    const key = 'ownedSkins_game_' + gameId;
                    localStorage.setItem(key, JSON.stringify(owned));
                    const equipKey = 'equippedSkin_game_' + gameId;
                    localStorage.setItem(equipKey, skinId);
                    renderShop();
                    showNotification(`Purchased ${skin.name}!`);
                } else {
                    alert(`Not enough coins! You need ${skin.price} coins for this game.`);
                }
            }
        }

        function getCompletedQuests(gameId) {
            const key = 'completedQuests_game_' + gameId;
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : [];
        }

        function checkQuests(gameId, stats) {
            let quests = gameQuests[gameId] || [];
            const completed = getCompletedQuests(gameId);
            let newlyCompleted = [];

            quests.forEach(quest => {
                if (!completed.includes(quest.id)) {
                    let achieved = false;
                    const value = stats[quest.type] || 0;
                    if (value >= quest.target) achieved = true;

                    if (achieved) {
                        completed.push(quest.id);
                        addCoins(gameId, quest.reward);
                        newlyCompleted.push(quest);
                    }
                }
            });

            if (newlyCompleted.length > 0) {
                const key = 'completedQuests_game_' + gameId;
                localStorage.setItem(key, JSON.stringify(completed));
                
                // Generate NEW quests to replace completed ones
                newlyCompleted.forEach(completedQuest => {
                    const newQuest = generateRandomQuest(gameId, completedQuest);
                    if (newQuest) {
                        // Add to gameQuests
                        if (!gameQuests[gameId]) gameQuests[gameId] = [];
                        gameQuests[gameId].push(newQuest);
                        showNotification(`Quest Complete! ${completedQuest.name} +${completedQuest.reward}ü™ô`);
                        showNotification(`üÜï New Quest: ${newQuest.name}`);
                    }
                });
                
                // Save updated quests
                saveCustomQuests(gameId);
            }
        }

        // Generate random quest based on game type
        function generateRandomQuest(gameId, completedQuest) {
            const questId = 'custom_' + gameId + '_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
            
            // Quest templates by game ID
            const questTemplates = {
                1: [ // Gravity Flip
                    {type: 'distance', names: ['Distance Runner', 'Far Traveler', 'Long Journey', 'Endurance Test'], desc: 'Reach {target}m distance'},
                    {type: 'score', names: ['Point Hunter', 'Score Chaser', 'High Scorer', 'Points Master'], desc: 'Score {target} points'},
                ],
                2: [ // Neon Breaker
                    {type: 'blocks', names: ['Block Destroyer', 'Demolition', 'Breaking Bad', 'Block Master'], desc: 'Break {target} blocks'},
                    {type: 'score', names: ['Breaker Points', 'High Breaker', 'Block Score', 'Neon Master'], desc: 'Score {target} points'},
                ],
                3: [ // Speed Runner
                    {type: 'distance', names: ['Speed Demon', 'Fast Runner', 'Quick Feet', 'Sprint Master'], desc: 'Run {target}m'},
                    {type: 'obstacles', names: ['Obstacle Master', 'Dodge King', 'Agility Expert', 'Avoidance Pro'], desc: 'Dodge {target} obstacles'},
                    {type: 'speed', names: ['Speed Boost', 'Velocity King', 'Acceleration', 'Max Speed'], desc: 'Reach {target}x speed'},
                ],
                4: [ // Pixel Jump
                    {type: 'height', names: ['Sky Climber', 'High Rise', 'Altitude King', 'Peak Jumper'], desc: 'Jump {target}m high'},
                    {type: 'platforms', names: ['Platform Pro', 'Landing Expert', 'Jump Master', 'Platform King'], desc: 'Land on {target} platforms'},
                    {type: 'score', names: ['Jump Points', 'Height Score', 'Jumping Legend', 'Air Master'], desc: 'Score {target} points'},
                ],
                5: [ // Color Switch
                    {type: 'score', names: ['Color Expert', 'Rainbow Master', 'Hue Hunter', 'Shade Pro'], desc: 'Score {target} points'},
                    {type: 'perfect', names: ['Perfect Match', 'Color Accuracy', 'Flawless Run', 'Precision King'], desc: 'Get {target} perfect matches'},
                ],
                6: [ // Circle Dash
                    {type: 'score', names: ['Circle Runner', 'Orbit Master', 'Dash King', 'Circular Pro'], desc: 'Score {target} points'},
                    {type: 'combo', names: ['Combo Maker', 'Chain Master', 'Streak King', 'Multi Dodge'], desc: 'Get {target}x combo'},
                ],
                7: [ // Laser Dodge
                    {type: 'score', names: ['Laser Expert', 'Dodge Master', 'Beam Avoider', 'Laser King'], desc: 'Score {target} points'},
                ],
                8: [ // Bounce Master
                    {type: 'score', names: ['Bounce Pro', 'Platform King', 'Jump Expert', 'Bouncer'], desc: 'Score {target} points'},
                    {type: 'perfectBounces', names: ['Perfect Landing', 'Center Master', 'Precision Bounce', 'Bullseye'], desc: 'Get {target} perfect bounces'},
                ],
            };

            const templates = questTemplates[gameId] || questTemplates[1]; // Fallback to game 1 templates
            const template = templates[Math.floor(Math.random() * templates.length)];
            const name = template.names[Math.floor(Math.random() * template.names.length)];
            
            // Scale target based on completed quest
            const baseTarget = completedQuest.target;
            const multiplier = 1.5 + Math.random() * 0.5; // 1.5x to 2x harder
            const newTarget = Math.floor(baseTarget * multiplier);
            
            // Scale reward
            const newReward = Math.floor(completedQuest.reward * 1.2); // 20% more coins
            
            return {
                id: questId,
                name: name,
                desc: template.desc.replace('{target}', newTarget),
                target: newTarget,
                type: template.type,
                reward: newReward
            };
        }

        // Save custom quests to localStorage
        function saveCustomQuests(gameId) {
            const key = 'customQuests_game_' + gameId;
            const customQuests = gameQuests[gameId].filter(q => q.id.startsWith('custom_'));
            if (customQuests.length > 0) {
                localStorage.setItem(key, JSON.stringify(customQuests));
            }
        }

        // Load custom quests from localStorage
        function loadCustomQuests(gameId) {
            const key = 'customQuests_game_' + gameId;
            const saved = localStorage.getItem(key);
            if (saved) {
                const customQuests = JSON.parse(saved);
                if (!gameQuests[gameId]) gameQuests[gameId] = [];
                // Add custom quests that aren't already in the list
                customQuests.forEach(quest => {
                    if (!gameQuests[gameId].find(q => q.id === quest.id)) {
                        gameQuests[gameId].push(quest);
                    }
                });
            }
        }

        // Load custom quests on startup
        for (let i = 1; i <= 50; i++) {
            loadCustomQuests(i);
        }

        function showNotification(message) {
            const notif = document.createElement('div');
            notif.className = 'quest-notification';
            notif.textContent = message;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        // Shop UI
        function openShop() {
            if (!currentGame) return;
            document.getElementById('shopModal').classList.add('active');
            renderShop();
        }

        function closeShop() {
            document.getElementById('shopModal').classList.remove('active');
        }

        function renderShop() {
            if (!currentGame) return;
            const gameId = currentGame.id;
            
            // Update coins display - use Block Puzzle coins for game 11, otherwise use hub coins
            if (gameId === 11) {
                updateBlockPuzzleCoinsDisplay();
            } else {
                updateCoinsDisplay();
            }

            // Show power-ups section only for Block Puzzle (game 11)
            const powerUpsSection = document.getElementById('powerUpsSection');
            if (gameId === 11) {
                powerUpsSection.style.display = 'block';
            } else {
                powerUpsSection.style.display = 'none';
            }

            // Render Skins
            const skinsGrid = document.getElementById('skinsGrid');
            const skins = gameSkins[gameId] || [];
            const owned = getOwnedSkins(gameId);
            const equipped = getEquippedSkin(gameId);
            
            skinsGrid.innerHTML = '';
            if (skins.length === 0) {
                skinsGrid.innerHTML = '<p style="text-align: center; padding: 40px; opacity: 0.7; grid-column: 1/-1;">Skins coming soon for this game!</p>';
            } else {
                skins.forEach(skin => {
                    const isOwned = owned.includes(skin.id);
                    const isEquipped = equipped === skin.id;
                    
                    const card = document.createElement('div');
                    card.className = 'skin-card';
                    if (isOwned) card.classList.add('owned');
                    if (isEquipped) card.classList.add('equipped');
                    
                    card.innerHTML = `
                        <div class="skin-preview" style="background: ${skin.color !== 'rainbow' ? skin.color : 'linear-gradient(135deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)'}">${skin.icon}</div>
                        <div class="skin-name">${skin.name}</div>
                        <div class="skin-price">${isOwned ? (isEquipped ? '‚úì Equipped' : 'Click to Equip') : skin.price + ' ü™ô'}</div>
                    `;
                    
                    card.onclick = () => buySkin(skin.id);
                    skinsGrid.appendChild(card);
                });
            }

            // Render Quests
            const questsList = document.getElementById('questsList');
            const quests = gameQuests[gameId] || [];
            const completed = getCompletedQuests(gameId);
            
            questsList.innerHTML = '';
            if (quests.length === 0) {
                questsList.innerHTML = '<p style="text-align: center; padding: 40px; opacity: 0.7;">Quests coming soon for this game!</p>';
            } else {
                quests.forEach(quest => {
                    const isCompleted = completed.includes(quest.id);
                    
                    const item = document.createElement('div');
                    item.className = 'quest-item';
                    if (isCompleted) item.classList.add('completed');
                    
                    item.innerHTML = `
                        <div class="quest-info">
                            <div class="quest-title">${quest.name}</div>
                            <div class="quest-progress">${quest.desc}</div>
                        </div>
                        <div class="quest-reward">${isCompleted ? '‚úì Done' : '+' + quest.reward + ' ü™ô'}</div>
                    `;
                    
                    questsList.appendChild(item);
                });
            }
        }

        // Buy power-up function (for Block Puzzle)
        function buyPowerUp(type, cost) {
            if (!currentGame || currentGame.id !== 11) return;
            
            // Use Block Puzzle specific coins, not hub currency
            const blockPuzzleCoins = parseInt(localStorage.getItem('blockPuzzleCoins') || '0');
            if (blockPuzzleCoins < cost) {
                showNotification('‚ùå Not enough coins! Play Block Puzzle to earn more!');
                return;
            }
            
            // Deduct coins from Block Puzzle balance
            localStorage.setItem('blockPuzzleCoins', (blockPuzzleCoins - cost).toString());
            
            // Add power-up to localStorage for Block Puzzle
            const powerUpKey = 'blockPuzzlePowerUps';
            const powerUps = JSON.parse(localStorage.getItem(powerUpKey) || '{"bomb":2,"lightning":1,"hammer":3,"shuffle":1}');
            powerUps[type] = (powerUps[type] || 0) + 1;
            localStorage.setItem(powerUpKey, JSON.stringify(powerUps));
            
            // Update display
            updateBlockPuzzleCoinsDisplay();
            
            const names = {
                bomb: 'üí£ Bomb',
                lightning: '‚ö° Lightning',
                hammer: 'üî® Hammer',
                shuffle: 'üîÄ Shuffle'
            };
            showNotification(`‚úÖ Bought ${names[type]}! Use it in game!`);
        }
        
        // Update Block Puzzle coins display in shop
        function updateBlockPuzzleCoinsDisplay() {
            const blockPuzzleCoins = parseInt(localStorage.getItem('blockPuzzleCoins') || '0');
            if (document.getElementById('shopCoinsDisplay')) {
                document.getElementById('shopCoinsDisplay').textContent = blockPuzzleCoins;
            }
        }

        // Render games
        function renderGames(gamesToShow = games) {
            const grid = document.getElementById('gamesGrid');
            grid.innerHTML = '';
            
            gamesToShow.forEach(game => {
                const card = document.createElement('div');
                card.className = 'game-card';
                card.setAttribute('data-category', game.category);
                card.innerHTML = `
                    <h3>${game.icon} ${game.name}</h3>
                    <p>${game.desc}</p>
                    <button class="play-btn" onclick="startGame(${game.id})">‚ñ∂ PLAY</button>
                `;
                grid.appendChild(card);
            });
        }

        // Filter functions
        function filterGames() {
            const search = document.getElementById('searchBar').value.toLowerCase();
            const filtered = games.filter(g => 
                g.name.toLowerCase().includes(search) || 
                g.desc.toLowerCase().includes(search)
            );
            renderGames(filtered);
        }

        let currentCategory = 'all';
        function filterCategory(category) {
            currentCategory = category;
            const buttons = document.querySelectorAll('.filter-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (category === 'all') {
                renderGames();
            } else {
                const filtered = games.filter(g => g.category === category);
                renderGames(filtered);
            }
        }

        // Game engine
        let canvas, ctx, currentGame, gameLoop;

        function startGame(gameId) {
            console.log('Starting game ID:', gameId); // Debug
            currentGame = games.find(g => g.id === gameId);
            if (!currentGame) {
                alert('Error: Game ID ' + gameId + ' not found!');
                return;
            }
            document.getElementById('currentGameTitle').textContent = `${currentGame.icon} ${currentGame.name}`;
            document.getElementById('gameScreen').classList.add('active');
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Update coins display - use Block Puzzle coins for game 11
            if (gameId === 11) {
                const blockPuzzleCoins = parseInt(localStorage.getItem('blockPuzzleCoins') || '0');
                document.getElementById('gameCoins').textContent = blockPuzzleCoins;
            } else {
                updateCoinsDisplay();
            }
            
            // Initialize the specific game
            initGame(gameId);
        }

        function closeGame() {
            document.getElementById('gameScreen').classList.remove('active');
            if (gameLoop) cancelAnimationFrame(gameLoop);
            currentGame = null;
            // Restore shop button
            document.querySelector('.shop-btn').style.display = 'block';
        }

        // Game implementations
        function initGame(gameId) {
            console.log('initGame called with ID:', gameId); // Debug log
            switch(gameId) {
                case 1: initGravityFlip(); break;
                case 2: initNeonBreaker(); break;
                case 3: initSpeedRunner(); break;
                case 4: initPixelJump(); break;
                case 5: initColorSwitch(); break;
                case 6: initCircleDash(); break;
                case 7: initLaserDodge(); break;
                case 8: initBounceMaster(); break;
                case 9: initTunnelRush(); break;
                case 10: initZigZag(); break;
                case 11: initBlockPuzzle(); break;
                case 12: initNumberMatch(); break;
                case 13: initPatternMemory(); break;
                case 14: initColorSort(); break;
                case 15: initTankBattle(); break;
                case 16: initTowerDefense(); break;
                case 17: initPixelPainter(); break;
                // Add more game inits...
                default: initDefaultGame(); break;
            }
        }

        // GAME 1: GRAVITY FLIP (Geometry Dash Style)
        function initGravityFlip() {
            let player = {x: 150, y: 300, w: 30, h: 30, vy: 0, gravity: 1, onGround: false};
            let obstacles = [];
            let score = 0;
            let distance = 0;
            let gameOver = false;
            let speed = 6;
            let baseSpeed = 6;
            let spawnRate = 0.025;
            let keyHandler = null;
            let clickHandler = null;

            // Remove old event listeners
            document.onkeydown = null;
            canvas.onclick = null;

            keyHandler = function(e) {
                if (e.key === ' ' || e.key === 'Spacebar') {
                    e.preventDefault();
                    if (gameOver) {
                        restartGame();
                    } else {
                        player.gravity *= -1;
                        player.vy = 0;
                    }
                }
            };

            clickHandler = function() {
                if (gameOver) {
                    restartGame();
                } else {
                    player.gravity *= -1;
                    player.vy = 0;
                }
            };

            document.addEventListener('keydown', keyHandler);
            canvas.addEventListener('click', clickHandler);

            function restartGame() {
                obstacles = [];
                score = 0;
                distance = 0;
                gameOver = false;
                player.y = 300;
                player.vy = 0;
                player.gravity = 1;
                speed = baseSpeed;
                spawnRate = 0.025;
            }

            function spawnObstacle() {
                // Progressive difficulty - spawn rate increases
                const adjustedSpawnRate = spawnRate + (distance / 10000);
                
                if (Math.random() < adjustedSpawnRate) {
                    const type = Math.random();
                    
                    if (type < 0.25) {
                        // Floor spike
                        obstacles.push({
                            x: canvas.width,
                            y: canvas.height - 60,
                            w: 40,
                            h: 60,
                            type: 'spike',
                            color: '#ff4444'
                        });
                    } else if (type < 0.5) {
                        // Ceiling spike
                        obstacles.push({
                            x: canvas.width,
                            y: 0,
                            w: 40,
                            h: 60,
                            type: 'spike',
                            color: '#ff4444'
                        });
                    } else if (type < 0.75) {
                        // Middle obstacle - gets more common as difficulty increases
                        const minY = 100 + (Math.random() * 50);
                        const maxY = canvas.height - 150 - (Math.random() * 50);
                        obstacles.push({
                            x: canvas.width,
                            y: minY + Math.random() * (maxY - minY),
                            w: 40,
                            h: 40,
                            type: 'block',
                            color: '#ff8800'
                        });
                    } else {
                        // Floating platform
                        obstacles.push({
                            x: canvas.width,
                            y: 150 + Math.random() * 300,
                            w: 80,
                            h: 20,
                            type: 'platform',
                            color: '#00ff88'
                        });
                    }
                }

                // Occasionally spawn combo obstacles (more frequent at higher difficulty)
                const comboChance = 0.005 + (distance / 50000);
                if (Math.random() < comboChance) {
                    obstacles.push({
                        x: canvas.width,
                        y: canvas.height - 60,
                        w: 40,
                        h: 60,
                        type: 'spike',
                        color: '#ff4444'
                    });
                    obstacles.push({
                        x: canvas.width,
                        y: 0,
                        w: 40,
                        h: 60,
                        type: 'spike',
                        color: '#ff4444'
                    });
                }
            }

            function cleanup() {
                document.removeEventListener('keydown', keyHandler);
                canvas.removeEventListener('click', clickHandler);
            }

            function update() {
                if (gameOver) {
                    // Check and complete quests
                    const distanceMeters = Math.floor(distance / 10);
                    checkQuests(1, {
                        distance: distanceMeters,
                        score: score
                    });
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 60);
                    ctx.font = '30px Arial';
                    ctx.fillText('Player: ' + currentUsername, canvas.width/2, canvas.height/2 - 10);
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 30);
                    ctx.fillText('Distance: ' + Math.floor(distance/10) + 'm', canvas.width/2, canvas.height/2 + 70);
                    ctx.font = '25px Arial';
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('SPACE or CLICK to restart!', canvas.width/2, canvas.height/2 + 120);
                    ctx.textAlign = 'left';
                    
                    // Keep the game loop running for restart
                    gameLoop = requestAnimationFrame(update);
                    return;
                }

                // Progressive difficulty - speed increases gradually
                speed = baseSpeed + (distance / 1000);
                
                // Slower gravity physics
                player.vy += player.gravity * 0.35;
                player.vy = Math.max(-10, Math.min(10, player.vy)); // Cap velocity
                player.y += player.vy;

                // Check floor/ceiling collision
                if (player.y <= 0) {
                    player.y = 0;
                    player.vy = 0;
                }
                if (player.y >= canvas.height - player.h) {
                    player.y = canvas.height - player.h;
                    player.vy = 0;
                }

                // Spawn and move obstacles
                spawnObstacle();
                distance++;

                obstacles.forEach((obs, i) => {
                    obs.x -= speed;
                    
                    if (obs.x + obs.w < 0) {
                        obstacles.splice(i, 1);
                        score += 10; // Points for dodging obstacles
                    }

                    // Collision detection
                    if (obs.type !== 'platform') {
                        if (player.x < obs.x + obs.w - 5 && 
                            player.x + player.w > obs.x + 5 &&
                            player.y < obs.y + obs.h - 5 && 
                            player.y + player.h > obs.y + 5) {
                            gameOver = true;
                        }
                    }
                });

                // Draw background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1a1a3e');
                gradient.addColorStop(1, '#0f0f1e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw grid lines (Geometry Dash style)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i - (distance * speed % 50), 0);
                    ctx.lineTo(i - (distance * speed % 50), canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }

                // Draw ground and ceiling
                ctx.fillStyle = '#333';
                ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
                ctx.fillRect(0, 0, canvas.width, 10);

                // Draw obstacles with glow effect
                obstacles.forEach(obs => {
                    if (obs.type === 'spike') {
                        // Draw spike as triangle
                        ctx.fillStyle = obs.color;
                        ctx.shadowColor = obs.color;
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        if (obs.y === 0) {
                            // Ceiling spike (pointing down)
                            ctx.moveTo(obs.x, obs.y);
                            ctx.lineTo(obs.x + obs.w, obs.y);
                            ctx.lineTo(obs.x + obs.w/2, obs.y + obs.h);
                        } else {
                            // Floor spike (pointing up)
                            ctx.moveTo(obs.x, obs.y + obs.h);
                            ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                            ctx.lineTo(obs.x + obs.w/2, obs.y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else if (obs.type === 'block') {
                        // Rotating block
                        ctx.save();
                        ctx.translate(obs.x + obs.w/2, obs.y + obs.h/2);
                        ctx.rotate(distance * 0.02);
                        ctx.fillStyle = obs.color;
                        ctx.shadowColor = obs.color;
                        ctx.shadowBlur = 20;
                        ctx.fillRect(-obs.w/2, -obs.h/2, obs.w, obs.h);
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    } else if (obs.type === 'platform') {
                        ctx.fillStyle = obs.color;
                        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    }
                });

                // Draw player with glow and trail effect
                const equippedSkinId = getEquippedSkin(1);
                const skinsList = gameSkins[1] || [];
                const skinData = skinsList.find(s => s.id === equippedSkinId) || skinsList[0];
                const playerColor = skinData.color;
                
                // Handle rainbow skin
                if (playerColor === 'rainbow') {
                    const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#9400d3'];
                    const colorIndex = Math.floor((distance / 10) % rainbowColors.length);
                    ctx.shadowColor = rainbowColors[colorIndex];
                    ctx.shadowBlur = 20;
                    
                    // Trail effect
                    ctx.fillStyle = rainbowColors[colorIndex] + '55';
                    ctx.fillRect(player.x - 10, player.y, player.w, player.h);
                    ctx.fillRect(player.x - 20, player.y, player.w, player.h);
                    
                    // Player cube with rotation
                    ctx.save();
                    ctx.translate(player.x + player.w/2, player.y + player.h/2);
                    ctx.rotate(distance * 0.05);
                    ctx.fillStyle = rainbowColors[colorIndex];
                    ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                    ctx.strokeStyle = rainbowColors[(colorIndex + 1) % rainbowColors.length];
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-player.w/2, -player.h/2, player.w, player.h);
                    ctx.restore();
                } else {
                    ctx.shadowColor = playerColor;
                    ctx.shadowBlur = 20;
                    
                    // Trail effect
                    ctx.fillStyle = playerColor + '55';
                    ctx.fillRect(player.x - 10, player.y, player.w, player.h);
                    ctx.fillRect(player.x - 20, player.y, player.w, player.h);
                    
                    // Player cube with rotation
                    ctx.save();
                    ctx.translate(player.x + player.w/2, player.y + player.h/2);
                    ctx.rotate(distance * 0.05);
                    ctx.fillStyle = playerColor;
                    ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                    
                    // Determine stroke color (lighter or darker)
                    const isLight = playerColor === '#ffff44' || playerColor === '#ffd700';
                    ctx.strokeStyle = isLight ? '#888' : '#fff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-player.w/2, -player.h/2, player.w, player.h);
                    ctx.restore();
                }
                
                ctx.shadowBlur = 0;

                // Draw UI
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Score: ' + score, 20, 40);
                ctx.fillText('Distance: ' + Math.floor(distance/10) + 'm', 20, 70);
                ctx.fillText('Speed: ' + speed.toFixed(1) + 'x', 20, 100);
                
                // Gravity indicator
                const arrowY = player.gravity > 0 ? 140 : 120;
                ctx.fillText(player.gravity > 0 ? '‚Üì Gravity' : '‚Üë Gravity', 20, arrowY);
                
                // Difficulty level indicator
                const difficultyLevel = Math.floor(distance / 500) + 1;
                ctx.fillStyle = '#ffaa00';
                ctx.fillText('Level: ' + difficultyLevel, 20, 170);

                // Controls hint
                ctx.font = '16px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.textAlign = 'center';
                ctx.fillText('SPACE or CLICK to flip gravity', canvas.width/2, canvas.height - 20);
                ctx.textAlign = 'left';

                gameLoop = requestAnimationFrame(update);
            }

            // Start with a small delay to ensure canvas is ready
            setTimeout(() => update(), 100);

            // Return cleanup function
            return cleanup;
        }

        // GAME 2: NEON BREAKER
        function initNeonBreaker() {
            let paddle = {x: 350, y: 550, w: 100, h: 15};
            let ball = {x: 400, y: 300, vx: 4, vy: -4, r: 8};
            let blocks = [];
            let score = 0;

            // Create blocks
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 10; col++) {
                    blocks.push({
                        x: col * 80 + 5,
                        y: row * 30 + 50,
                        w: 75,
                        h: 25,
                        color: `hsl(${row * 60}, 100%, 50%)`
                    });
                }
            }

            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                paddle.x = e.clientX - rect.left - paddle.w / 2;
            };

            function update() {
                // Ball movement
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Wall collision
                if (ball.x < ball.r || ball.x > canvas.width - ball.r) ball.vx *= -1;
                if (ball.y < ball.r) ball.vy *= -1;

                // Paddle collision
                if (ball.y + ball.r > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.w) {
                    ball.vy = -Math.abs(ball.vy);
                    ball.vx += (ball.x - (paddle.x + paddle.w/2)) * 0.1;
                }

                // Block collision
                blocks.forEach((block, i) => {
                    if (ball.x > block.x && ball.x < block.x + block.w &&
                        ball.y > block.y && ball.y < block.y + block.h) {
                        ball.vy *= -1;
                        blocks.splice(i, 1);
                        score += 10;
                    }
                });

                // Game over
                if (ball.y > canvas.height) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '40px Arial';
                    ctx.fillText('GAME OVER!', canvas.width/2 - 120, canvas.height/2);
                    ctx.fillText('Score: ' + score, canvas.width/2 - 80, canvas.height/2 + 50);
                    return;
                }

                // Draw
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Blocks
                blocks.forEach(block => {
                    ctx.fillStyle = block.color;
                    ctx.fillRect(block.x, block.y, block.w, block.h);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(block.x, block.y, block.w, block.h);
                });

                // Paddle
                ctx.fillStyle = '#00ff88';
                ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

                // Ball
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                ctx.fill();

                // Score
                ctx.font = '20px Arial';
                ctx.fillText('Score: ' + score, 10, 25);

                // Win condition
                if (blocks.length === 0) {
                    ctx.font = '40px Arial';
                    ctx.fillText('YOU WIN!', canvas.width/2 - 100, canvas.height/2);
                    return;
                }

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // GAME 3: SPEED RUNNER
        function initSpeedRunner() {
            let player = {x: 100, y: 400, w: 30, h: 30, vy: 0, jumping: false};
            let obstacles = [];
            let particles = [];
            let speed = 5; // Slower starting speed
            let baseSpeed = 5;
            let distance = 0;
            let score = 0;
            let gameOver = false;
            let keyHandler = null;
            let clickHandler = null;

            keyHandler = (e) => {
                e.preventDefault();
                if (gameOver) {
                    // Restart on any key
                    obstacles = [];
                    particles = [];
                    speed = baseSpeed;
                    distance = 0;
                    score = 0;
                    gameOver = false;
                    player.y = 400;
                    player.vy = 0;
                    player.jumping = false;
                } else if ((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && !player.jumping) {
                    player.vy = -15; // Slightly lower jump
                    player.jumping = true;
                }
            };

            clickHandler = () => {
                if (gameOver) {
                    // Restart on click
                    obstacles = [];
                    particles = [];
                    speed = baseSpeed;
                    distance = 0;
                    score = 0;
                    gameOver = false;
                    player.y = 400;
                    player.vy = 0;
                    player.jumping = false;
                } else if (!player.jumping) {
                    player.vy = -15;
                    player.jumping = true;
                }
            };

            document.addEventListener('keydown', keyHandler);
            canvas.addEventListener('click', clickHandler);

            function spawnObstacle() {
                // Much lower spawn rate - more forgiving
                const spawnChance = 0.012 + (distance / 100000); // Half as frequent
                
                if (Math.random() < spawnChance) {
                    const obstacleType = Math.random();
                    
                    // Much simpler obstacle distribution - mostly easy ones
                    if (obstacleType < 0.7) {
                        // Ground obstacle - single block (MOST COMMON - 70%)
                        obstacles.push({
                            x: canvas.width,
                            y: 400,
                            w: 30,
                            h: 30,
                            type: 'ground',
                            color: '#ff4444'
                        });
                    } else if (obstacleType < 0.9) {
                        // Tall obstacle - must jump (20%)
                        obstacles.push({
                            x: canvas.width,
                            y: 370,
                            w: 30,
                            h: 60,
                            type: 'tall',
                            color: '#ff8800'
                        });
                    } else {
                        // Flying obstacle - rare (10%)
                        obstacles.push({
                            x: canvas.width,
                            y: 330, // Higher up - easier to jump under
                            w: 35,
                            h: 25,
                            type: 'flying',
                            color: '#ff00ff',
                            bobOffset: 0
                        });
                    }
                    
                    // Removed: Double obstacles, spike rows - too hard!
                }
            }

            function createParticle(x, y, color) {
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 30,
                        color: color
                    });
                }
            }

            function update() {
                if (gameOver) {
                    // Save and check quests
                    checkQuests(3, {
                        distance: distance,
                        obstacles: score,
                        speed: Math.floor(speed)
                    });
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 60);
                    ctx.font = '30px Arial';
                    ctx.fillText('Distance: ' + distance + 'm', canvas.width/2, canvas.height/2 - 10);
                    ctx.fillText('Obstacles Dodged: ' + score, canvas.width/2, canvas.height/2 + 30);
                    ctx.fillText('Max Speed: ' + speed.toFixed(1) + 'x', canvas.width/2, canvas.height/2 + 70);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('SPACE or CLICK to restart', canvas.width/2, canvas.height/2 + 120);
                    ctx.textAlign = 'left';
                    
                    // Keep animation loop running for restart
                    gameLoop = requestAnimationFrame(update);
                    return;
                }

                // Gravity
                player.vy += 0.7; // Slightly lower gravity - more hang time
                player.y += player.vy;

                if (player.y >= 400) {
                    player.y = 400;
                    player.vy = 0;
                    player.jumping = false;
                }

                // Much slower speed increase
                speed = baseSpeed + (distance / 500); // Increases 5x slower
                distance++;

                // Spawn obstacles
                spawnObstacle();

                // Update particles
                particles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3; // gravity
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                // Move and update obstacles
                obstacles.forEach((obs, i) => {
                    obs.x -= speed;
                    
                    // Bob flying obstacles (less movement)
                    if (obs.type === 'flying') {
                        obs.bobOffset += 0.08;
                        obs.y = 330 + Math.sin(obs.bobOffset) * 10; // Less bobbing
                    }
                    
                    if (obs.x + obs.w < 0) {
                        obstacles.splice(i, 1);
                        score++;
                        createParticle(50, 50, '#00ff88');
                    }

                    // More forgiving collision detection
                    if (player.x < obs.x + obs.w - 8 && 
                        player.x + player.w > obs.x + 8 &&
                        player.y < obs.y + obs.h - 8 && 
                        player.y + player.h > obs.y + 8) {
                        gameOver = true;
                        createParticle(player.x + player.w/2, player.y + player.h/2, '#ff4444');
                        // Don't remove listeners - need them for restart
                    }
                });

                // Draw background with gradient
                const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                bgGradient.addColorStop(0, '#001a33');
                bgGradient.addColorStop(1, '#000000');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw moving background lines for speed effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 10; i++) {
                    const x = ((distance * speed * 3) % 800) - 800 + i * 100;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x + 100, canvas.height);
                    ctx.stroke();
                }

                // Ground with gradient
                const groundGradient = ctx.createLinearGradient(0, 430, 0, 600);
                groundGradient.addColorStop(0, '#444');
                groundGradient.addColorStop(1, '#222');
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, 430, canvas.width, 170);

                // Ground line
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 430);
                ctx.lineTo(canvas.width, 430);
                ctx.stroke();

                // Draw particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 30;
                    ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
                });
                ctx.globalAlpha = 1;

                // Draw obstacles with glow
                obstacles.forEach(obs => {
                    ctx.shadowColor = obs.color;
                    ctx.shadowBlur = 10;
                    
                    if (obs.type === 'spike') {
                        // Draw spike as triangle
                        ctx.fillStyle = obs.color;
                        ctx.beginPath();
                        ctx.moveTo(obs.x, obs.y + obs.h);
                        ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                        ctx.lineTo(obs.x + obs.w/2, obs.y);
                        ctx.closePath();
                        ctx.fill();
                    } else if (obs.type === 'flying') {
                        // Draw flying enemy
                        ctx.fillStyle = obs.color;
                        ctx.beginPath();
                        ctx.ellipse(obs.x + obs.w/2, obs.y + obs.h/2, obs.w/2, obs.h/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Wings
                        ctx.fillRect(obs.x - 5, obs.y + obs.h/2 - 3, 8, 6);
                        ctx.fillRect(obs.x + obs.w - 3, obs.y + obs.h/2 - 3, 8, 6);
                    } else {
                        // Regular obstacle
                        ctx.fillStyle = obs.color;
                        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                    }
                });
                ctx.shadowBlur = 0;

                // Player with skin and trail
                const equippedSkinId = getEquippedSkin(3);
                const skinsList = gameSkins[3] || [];
                const skinData = skinsList.find(s => s.id === equippedSkinId) || skinsList[0];
                const playerColor = skinData ? skinData.color : '#00ff88';
                
                // Trail effect
                ctx.fillStyle = (playerColor !== 'rainbow' ? playerColor : '#00ff88') + '44';
                for (let i = 1; i <= 3; i++) {
                    ctx.fillRect(player.x - i * 15, player.y, player.w, player.h);
                }
                
                // Player with glow
                ctx.shadowColor = playerColor !== 'rainbow' ? playerColor : '#00ff88';
                ctx.shadowBlur = 20;
                ctx.fillStyle = playerColor !== 'rainbow' ? playerColor : '#00ff88';
                ctx.fillRect(player.x, player.y, player.w, player.h);
                ctx.shadowBlur = 0;
                
                // Player border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(player.x, player.y, player.w, player.h);

                // HUD with background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(5, 5, 250, 100);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 22px Arial';
                ctx.fillText('Distance: ' + distance + 'm', 15, 30);
                ctx.fillText('Dodged: ' + score, 15, 58);
                ctx.fillText('Speed: ' + speed.toFixed(1) + 'x', 15, 86);

                // Speed meter
                const meterWidth = 200;
                const speedPercent = Math.min(speed / 20, 1);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width - meterWidth - 20, 15, meterWidth, 30);
                
                const meterGradient = ctx.createLinearGradient(canvas.width - meterWidth - 20, 0, canvas.width - 20, 0);
                meterGradient.addColorStop(0, '#00ff00');
                meterGradient.addColorStop(0.5, '#ffff00');
                meterGradient.addColorStop(1, '#ff0000');
                ctx.fillStyle = meterGradient;
                ctx.fillRect(canvas.width - meterWidth - 18, 17, (meterWidth - 4) * speedPercent, 26);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - meterWidth - 20, 15, meterWidth, 30);
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPEED METER', canvas.width - meterWidth/2 - 20, 60);
                ctx.textAlign = 'left';

                // Controls hint
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width/2 - 100, canvas.height - 45, 200, 40);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPACE / CLICK to jump', canvas.width/2, canvas.height - 18);
                ctx.textAlign = 'left';

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // GAME 4: PIXEL JUMP
        function initPixelJump() {
            let player = {x: 400, y: 500, w: 30, h: 30, vx: 0, vy: 0, speed: 6};
            let platforms = [{x: 300, y: 530, w: 200, h: 20}];
            let score = 0;
            let cameraY = 0;
            let keyHandler = null;
            let keyUpHandler = null;

            keyHandler = (e) => {
                e.preventDefault();
                if (e.key === 'ArrowLeft' || e.key === 'a') player.vx = -player.speed;
                if (e.key === 'ArrowRight' || e.key === 'd') player.vx = player.speed;
            };

            keyUpHandler = (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'ArrowRight' || e.key === 'd') player.vx = 0;
            };

            document.addEventListener('keydown', keyHandler);
            document.addEventListener('keyup', keyUpHandler);

            function spawnPlatform() {
                if (platforms.length === 0 || platforms[platforms.length - 1].y > cameraY - 200) {
                    const lastPlatform = platforms[platforms.length - 1];
                    
                    // Progressive difficulty - gaps get bigger and platforms get smaller
                    const difficultyFactor = Math.min(score / 50, 1.5); // Caps at 1.5x difficulty
                    
                    // Vertical gap increases with score: 70-100px early, up to 85-115px later
                    const baseGap = 70 + Math.random() * 30;
                    const verticalGap = baseGap + (difficultyFactor * 15);
                    
                    // Horizontal offset increases with difficulty: ¬±200px early, ¬±400px later
                    const maxOffset = 200 + (difficultyFactor * 200);
                    const horizontalOffset = (Math.random() - 0.5) * maxOffset;
                    
                    let newX = lastPlatform.x + lastPlatform.w / 2 + horizontalOffset - 60;
                    
                    // Platform width decreases with score: 120-160px early, 80-120px later
                    const baseWidth = 120 - (difficultyFactor * 40);
                    const platformWidth = baseWidth + Math.random() * 40;
                    
                    // Keep platforms on screen with padding
                    newX = Math.max(10, Math.min(canvas.width - platformWidth - 10, newX));
                    
                    // Occasionally spawn moving platforms at higher scores
                    const isMoving = score > 15 && Math.random() < 0.15;
                    
                    platforms.push({
                        x: newX,
                        y: lastPlatform.y - verticalGap,
                        w: platformWidth,
                        h: 20,
                        moving: isMoving,
                        moveSpeed: isMoving ? 2 + Math.random() * 2 : 0,
                        moveDir: Math.random() < 0.5 ? -1 : 1,
                        startX: newX
                    });
                }
            }

            function update() {
                // Gravity
                player.vy += 0.5;
                player.x += player.vx;
                player.y += player.vy;

                // Wrap around horizontally
                if (player.x + player.w < 0) player.x = canvas.width;
                if (player.x > canvas.width) player.x = 0;

                // Update moving platforms
                platforms.forEach(plat => {
                    if (plat.moving) {
                        plat.x += plat.moveSpeed * plat.moveDir;
                        // Bounce back when hitting edges
                        if (plat.x < 10 || plat.x + plat.w > canvas.width - 10) {
                            plat.moveDir *= -1;
                        }
                    }
                });

                // Platform collision
                platforms.forEach(plat => {
                    if (player.vy > 0 &&
                        player.x + player.w > plat.x + 5 && 
                        player.x < plat.x + plat.w - 5 &&
                        player.y + player.h > plat.y && 
                        player.y + player.h < plat.y + 22) {
                        player.vy = -12.5; // Jump power - reaches ~78px high
                        score++;
                        
                        // If on moving platform, give player some horizontal momentum
                        if (plat.moving) {
                            player.vx += plat.moveSpeed * plat.moveDir * 0.3;
                        }
                    }
                });

                // Camera follow - move camera UP when player goes UP
                if (player.y < cameraY + 200) {
                    cameraY = player.y - 200;
                }

                // Spawn platforms
                spawnPlatform();

                // Remove old platforms below screen
                platforms = platforms.filter(p => p.y > cameraY - 100);

                // Game over - fell below screen
                if (player.y > cameraY + canvas.height) {
                    // Save score and check quests
                    checkQuests(4, {
                        height: Math.abs(Math.floor(cameraY / 10)),
                        platforms: score,
                        score: score
                    });
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '28px Arial';
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 20);
                    ctx.fillText('Height: ' + Math.abs(Math.floor(cameraY / 10)) + 'm', canvas.width/2, canvas.height/2 + 60);
                    ctx.textAlign = 'left';
                    
                    // Cleanup
                    document.removeEventListener('keydown', keyHandler);
                    document.removeEventListener('keyup', keyUpHandler);
                    return;
                }

                // Draw background
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw clouds for effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for (let i = 0; i < 3; i++) {
                    const cloudY = ((cameraY + i * 200) % 600);
                    ctx.beginPath();
                    ctx.arc(100 + i * 200, cloudY - cameraY % 600, 30, 0, Math.PI * 2);
                    ctx.arc(130 + i * 200, cloudY - cameraY % 600, 40, 0, Math.PI * 2);
                    ctx.arc(160 + i * 200, cloudY - cameraY % 600, 30, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Platforms - draw relative to camera
                platforms.forEach(plat => {
                    const screenY = plat.y - cameraY;
                    
                    // Different color for moving platforms
                    const gradient = ctx.createLinearGradient(plat.x, screenY, plat.x, screenY + plat.h);
                    if (plat.moving) {
                        gradient.addColorStop(0, '#ff8844');
                        gradient.addColorStop(1, '#ff4444');
                    } else {
                        gradient.addColorStop(0, '#8B4513');
                        gradient.addColorStop(1, '#654321');
                    }
                    ctx.fillStyle = gradient;
                    ctx.fillRect(plat.x, screenY, plat.w, plat.h);
                    
                    // Platform border
                    ctx.strokeStyle = plat.moving ? '#ff0000' : '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(plat.x, screenY, plat.w, plat.h);
                    
                    // Arrow indicator on moving platforms
                    if (plat.moving) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(plat.moveDir > 0 ? '‚Üí' : '‚Üê', plat.x + plat.w/2, screenY + 15);
                        ctx.textAlign = 'left';
                    }
                });

                // Player - draw relative to camera with skin
                const equippedSkinId = getEquippedSkin(4);
                const skinsList = gameSkins[4] || [];
                const skinData = skinsList.find(s => s.id === equippedSkinId) || skinsList[0];
                const playerColor = skinData ? skinData.color : '#00ff88';
                
                const screenY = player.y - cameraY;
                
                // Draw with glow effect
                ctx.shadowColor = playerColor !== 'rainbow' ? playerColor : '#00ff88';
                ctx.shadowBlur = 15;
                ctx.fillStyle = playerColor !== 'rainbow' ? playerColor : '#00ff88';
                ctx.fillRect(player.x, screenY, player.w, player.h);
                ctx.shadowBlur = 0;
                
                // Border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeRect(player.x, screenY, player.w, player.h);

                // HUD
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(5, 5, 200, 70);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('Score: ' + score, 15, 30);
                ctx.fillText('Height: ' + Math.abs(Math.floor(cameraY / 10)) + 'm', 15, 55);

                // Difficulty indicator
                const difficulty = Math.floor(Math.min(score / 10, 15));
                if (difficulty > 0) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.fillRect(canvas.width - 155, 5, 150, 35);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('Difficulty: ' + difficulty, canvas.width - 145, 28);
                }

                // Controls hint
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(canvas.width/2 - 120, canvas.height - 40, 240, 35);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üê A/D ‚Üí to move', canvas.width/2, canvas.height - 15);
                ctx.textAlign = 'left';

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // GAME 5: COLOR SWITCH
        function initColorSwitch() {
            let player = {x: 400, y: 500, r: 18, vy: 0, colorIndex: 0};
            let obstacles = [];
            let particles = [];
            let score = 0;
            let gameOver = false;
            let switchCount = 0;
            let streak = 0;
            let bestStreak = 0;
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44'];
            const colorNames = ['Red', 'Green', 'Blue', 'Yellow'];
            let keyHandler = null;
            let clickHandler = null;

            keyHandler = (e) => {
                e.preventDefault();
                if (gameOver) {
                    // Restart on any key when game over
                    obstacles = [];
                    particles = [];
                    score = 0;
                    gameOver = false;
                    switchCount = 0;
                    streak = 0;
                    player.y = 500;
                    player.vy = 0;
                    player.colorIndex = 0;
                } else if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
                    player.colorIndex = (player.colorIndex + 1) % 4;
                    switchCount++;
                    createParticles(player.x, player.y, colors[player.colorIndex]);
                }
            };

            clickHandler = () => {
                if (gameOver) {
                    // Restart on click when game over
                    obstacles = [];
                    particles = [];
                    score = 0;
                    gameOver = false;
                    switchCount = 0;
                    streak = 0;
                    player.y = 500;
                    player.vy = 0;
                    player.colorIndex = 0;
                } else {
                    player.colorIndex = (player.colorIndex + 1) % 4;
                    switchCount++;
                    createParticles(player.x, player.y, colors[player.colorIndex]);
                }
            };

            document.addEventListener('keydown', keyHandler);
            canvas.addEventListener('click', clickHandler);

            function createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 20,
                        color: color
                    });
                }
            }

            function spawnObstacle() {
                if (obstacles.length === 0 || obstacles[obstacles.length - 1].y > 150) {
                    const types = ['single', 'double', 'triple', 'spinner'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    if (type === 'single') {
                        // Single color block
                        obstacles.push({
                            x: 300 + Math.random() * 200,
                            y: -50,
                            w: 60,
                            h: 40,
                            type: 'single',
                            color: Math.floor(Math.random() * 4)
                        });
                    } else if (type === 'double') {
                        // Two blocks side by side
                        const color1 = Math.floor(Math.random() * 4);
                        let color2 = Math.floor(Math.random() * 4);
                        while (color2 === color1) color2 = Math.floor(Math.random() * 4);
                        
                        obstacles.push({
                            x: 280,
                            y: -50,
                            w: 60,
                            h: 40,
                            type: 'single',
                            color: color1
                        });
                        obstacles.push({
                            x: 360,
                            y: -50,
                            w: 60,
                            h: 40,
                            type: 'single',
                            color: color2
                        });
                    } else if (type === 'triple') {
                        // Three blocks
                        for (let i = 0; i < 3; i++) {
                            obstacles.push({
                                x: 250 + i * 100,
                                y: -50,
                                w: 50,
                                h: 40,
                                type: 'single',
                                color: Math.floor(Math.random() * 4)
                            });
                        }
                    } else if (type === 'spinner') {
                        // Rotating color wheel
                        obstacles.push({
                            x: 400,
                            y: -50,
                            r: 70,
                            type: 'spinner',
                            rotation: 0
                        });
                    }
                }
            }

            function update() {
                if (gameOver) {
                    // Save and check quests
                    checkQuests(5, {
                        score: score,
                        switches: switchCount,
                        streak: bestStreak
                    });
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 60);
                    ctx.font = '28px Arial';
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 - 10);
                    ctx.fillText('Best Streak: ' + bestStreak, canvas.width/2, canvas.height/2 + 30);
                    ctx.fillText('Switches: ' + switchCount, canvas.width/2, canvas.height/2 + 70);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('SPACE or CLICK to restart', canvas.width/2, canvas.height/2 + 120);
                    ctx.textAlign = 'left';
                    
                    gameLoop = requestAnimationFrame(update);
                    return;
                }

                // Gravity
                player.vy += 0.4;
                player.y += player.vy;

                // Keep player on screen
                if (player.y < 50) {
                    player.y = 50;
                    player.vy = 0;
                }
                if (player.y > 550) {
                    player.y = 550;
                    player.vy = 0;
                }

                // Spawn obstacles
                spawnObstacle();

                // Update particles
                particles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                // Move obstacles
                obstacles.forEach((obs, i) => {
                    obs.y += 3 + score / 20; // Speed increases with score
                    
                    if (obs.type === 'spinner') {
                        obs.rotation += 0.05;
                    }
                    
                    // Remove if off screen
                    if (obs.y > canvas.height + 100) {
                        obstacles.splice(i, 1);
                    }

                    // Collision detection
                    if (obs.type === 'single') {
                        if (player.x + player.r > obs.x && 
                            player.x - player.r < obs.x + obs.w &&
                            player.y + player.r > obs.y && 
                            player.y - player.r < obs.y + obs.h) {
                            
                            if (player.colorIndex === obs.color) {
                                // Correct color - score!
                                obstacles.splice(i, 1);
                                score += 10;
                                streak++;
                                if (streak > bestStreak) bestStreak = streak;
                                createParticles(obs.x + obs.w/2, obs.y + obs.h/2, colors[obs.color]);
                            } else {
                                // Wrong color - game over!
                                gameOver = true;
                                streak = 0; // Reset streak
                                createParticles(player.x, player.y, '#ffffff');
                                // Don't remove listeners - need them for restart
                            }
                        }
                    } else if (obs.type === 'spinner') {
                        const dist = Math.hypot(player.x - obs.x, player.y - obs.y);
                        if (dist < player.r + obs.r - 20) {
                            // Inside spinner - check segment
                            const angle = Math.atan2(player.y - obs.y, player.x - obs.x) - obs.rotation;
                            const normalizedAngle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                            const segment = Math.floor(normalizedAngle / (Math.PI / 2));
                            
                            if (player.colorIndex === segment) {
                                // Correct color
                                obstacles.splice(i, 1);
                                score += 20;
                                streak++;
                                if (streak > bestStreak) bestStreak = streak;
                                createParticles(obs.x, obs.y, colors[segment]);
                            } else {
                                // Wrong color
                                gameOver = true;
                                streak = 0; // Reset streak
                                createParticles(player.x, player.y, '#ffffff');
                                // Don't remove listeners - need them for restart
                            }
                        }
                    }
                });

                // Draw background with gradient
                const bgGradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 600);
                bgGradient.addColorStop(0, '#1a1a2e');
                bgGradient.addColorStop(1, '#0a0a0f');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 20;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw obstacles
                obstacles.forEach(obs => {
                    if (obs.type === 'single') {
                        // Draw colored block with glow
                        ctx.shadowColor = colors[obs.color];
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = colors[obs.color];
                        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                        ctx.shadowBlur = 0;
                        
                        // Border
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                    } else if (obs.type === 'spinner') {
                        // Draw rotating color wheel
                        ctx.save();
                        ctx.translate(obs.x, obs.y);
                        ctx.rotate(obs.rotation);
                        
                        for (let i = 0; i < 4; i++) {
                            ctx.fillStyle = colors[i];
                            ctx.shadowColor = colors[i];
                            ctx.shadowBlur = 15;
                            ctx.beginPath();
                            ctx.arc(0, 0, obs.r, i * Math.PI / 2, (i + 1) * Math.PI / 2);
                            ctx.lineTo(0, 0);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                        
                        // Center circle
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(0, 0, 25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });

                // Draw player with glow
                const equippedSkinId = getEquippedSkin(5);
                const skinsList = gameSkins[5] || [];
                const skinData = skinsList.find(s => s.id === equippedSkinId) || skinsList[0];
                const skinColor = skinData ? skinData.color : colors[player.colorIndex];
                
                const displayColor = skinColor !== 'rainbow' ? colors[player.colorIndex] : colors[player.colorIndex];
                
                ctx.shadowColor = displayColor;
                ctx.shadowBlur = 25;
                ctx.fillStyle = displayColor;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Player border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
                ctx.stroke();

                // HUD
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(5, 5, 220, 120);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('Score: ' + score, 15, 30);
                ctx.fillText('Streak: ' + streak, 15, 58);
                ctx.fillText('Best: ' + bestStreak, 15, 86);
                ctx.fillText('Color: ' + colorNames[player.colorIndex], 15, 114);

                // Color indicator
                ctx.fillStyle = colors[player.colorIndex];
                ctx.fillRect(190, 10, 25, 110);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(190, 10, 25, 110);

                // Instructions
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width/2 - 150, canvas.height - 80, 300, 75);
                ctx.fillStyle = '#fff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPACE or CLICK to switch color', canvas.width/2, canvas.height - 48);
                ctx.fillText('Match your color with obstacles!', canvas.width/2, canvas.height - 20);
                ctx.textAlign = 'left';

                gameLoop = requestAnimationFrame(update);
            }

            update();
        }

        // GAME 6: CIRCLE DASH
        function initCircleDash() {
            let player = {angle: 0, radius: 150, speed: 0.05, orbiting: true};
            let obstacles = [];
            let powerUps = [];
            let score = 0;
            let combo = 0;
            let gameOver = false;
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;
            let direction = 1; // 1 = clockwise, -1 = counter-clockwise
            let shield = 0; // Shield timer
            let slowMo = 0; // Slow motion timer
            let speedBoost = 0; // Speed boost timer
            let particles = [];
            
            const activeSkin = getActiveSkin(6);
            const playerColor = activeSkin?.color || '#00ff88';

            canvas.onclick = () => {
                if (!gameOver) {
                    direction *= -1; // Reverse direction
                    // Create direction change particles
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            x: centerX + Math.cos(player.angle) * player.radius,
                            y: centerY + Math.sin(player.angle) * player.radius,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 20,
                            color: playerColor
                        });
                    }
                }
            };

            function spawnObstacle() {
                const difficulty = Math.min(2, 1 + score / 2000);
                if (Math.random() < 0.015 * difficulty) {
                    const angle = Math.random() * Math.PI * 2;
                    obstacles.push({
                        angle: angle,
                        radius: 250 + Math.random() * 50,
                        size: 15 + Math.random() * 10,
                        speed: 0.6 + Math.random() * 0.4 * difficulty
                    });
                }
            }

            function spawnPowerUp() {
                if (Math.random() < 0.003 && powerUps.length < 2) {
                    const types = ['shield', 'slow', 'speed'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const angle = Math.random() * Math.PI * 2;
                    powerUps.push({
                        angle: angle,
                        radius: 250,
                        type: type,
                        speed: 0.5
                    });
                }
            }

            function update() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (gameOver) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 40);
                    ctx.font = '30px Arial';
                    ctx.fillText(`Score: ${Math.floor(score / 10)}`, canvas.width/2, canvas.height/2 + 20);
                    ctx.fillText('Click to restart', canvas.width/2, canvas.height/2 + 60);
                    ctx.textAlign = 'left';
                    
                    canvas.onclick = () => {
                        initCircleDash();
                    };
                    return;
                }

                // Apply slow motion
                const timeScale = slowMo > 0 ? 0.5 : 1;
                
                // Update player angle
                const currentSpeed = speedBoost > 0 ? player.speed * 1.8 : player.speed;
                player.angle += currentSpeed * direction * timeScale;

                // Spawn obstacles and powerups
                spawnObstacle();
                spawnPowerUp();
                score += timeScale;

                // Update and check obstacles
                obstacles.forEach((obs, i) => {
                    obs.radius -= obs.speed * timeScale;

                    if (obs.radius < 50) {
                        obstacles.splice(i, 1);
                        combo++; // Increase combo for dodging
                    }

                    // Collision check
                    if (shield === 0) {
                        const playerX = centerX + Math.cos(player.angle) * player.radius;
                        const playerY = centerY + Math.sin(player.angle) * player.radius;
                        const obsX = centerX + Math.cos(obs.angle) * obs.radius;
                        const obsY = centerY + Math.sin(obs.angle) * obs.radius;
                        
                        const dist = Math.hypot(playerX - obsX, playerY - obsY);
                        if (dist < 15 + obs.size) {
                            gameOver = true;
                            combo = 0;
                        }
                    }
                });

                // Update and check power-ups
                powerUps.forEach((pu, i) => {
                    pu.radius -= pu.speed * timeScale;

                    if (pu.radius < 50) {
                        powerUps.splice(i, 1);
                    }

                    // Collection check
                    const playerX = centerX + Math.cos(player.angle) * player.radius;
                    const playerY = centerY + Math.sin(player.angle) * player.radius;
                    const puX = centerX + Math.cos(pu.angle) * pu.radius;
                    const puY = centerY + Math.sin(pu.angle) * pu.radius;
                    
                    const dist = Math.hypot(playerX - puX, playerY - puY);
                    if (dist < 30) {
                        powerUps.splice(i, 1);
                        score += 500;
                        
                        if (pu.type === 'shield') shield = 180;
                        if (pu.type === 'slow') slowMo = 150;
                        if (pu.type === 'speed') speedBoost = 120;
                        
                        // Power-up particles
                        for (let j = 0; j < 20; j++) {
                            particles.push({
                                x: puX,
                                y: puY,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 30,
                                color: pu.type === 'shield' ? '#00ffff' : pu.type === 'slow' ? '#ffff00' : '#ff00ff'
                            });
                        }
                    }
                });

                // Update particles
                particles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                // Countdown timers
                if (shield > 0) shield--;
                if (slowMo > 0) slowMo--;
                if (speedBoost > 0) speedBoost--;

                // Draw orbit circles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                for (let r = 100; r <= 250; r += 50) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 30;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw obstacles
                ctx.fillStyle = '#ff4444';
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 20;
                obstacles.forEach(obs => {
                    const x = centerX + Math.cos(obs.angle) * obs.radius;
                    const y = centerY + Math.sin(obs.angle) * obs.radius;
                    ctx.beginPath();
                    ctx.arc(x, y, obs.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;

                // Draw power-ups
                powerUps.forEach(pu => {
                    const x = centerX + Math.cos(pu.angle) * pu.radius;
                    const y = centerY + Math.sin(pu.angle) * pu.radius;
                    
                    const colors = {shield: '#00ffff', slow: '#ffff00', speed: '#ff00ff'};
                    const icons = {shield: 'üõ°Ô∏è', slow: '‚è±Ô∏è', speed: '‚ö°'};
                    
                    ctx.fillStyle = colors[pu.type];
                    ctx.shadowColor = colors[pu.type];
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(icons[pu.type], x, y + 7);
                    ctx.textAlign = 'left';
                });

                // Draw player
                const px = centerX + Math.cos(player.angle) * player.radius;
                const py = centerY + Math.sin(player.angle) * player.radius;
                
                if (shield > 0) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(px, py, 22, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.fillStyle = speedBoost > 0 ? '#ff00ff' : playerColor;
                ctx.shadowColor = speedBoost > 0 ? '#ff00ff' : playerColor;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(px, py, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // UI
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(5, 5, 280, 130);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${Math.floor(score / 10)}`, 15, 35);
                ctx.fillText(`Combo: x${Math.min(combo, 99)}`, 15, 65);
                
                ctx.font = '16px Arial';
                if (shield > 0) {
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText(`üõ°Ô∏è Shield: ${Math.ceil(shield/60)}s`, 15, 95);
                }
                if (slowMo > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`‚è±Ô∏è Slow Mo: ${Math.ceil(slowMo/60)}s`, 15, 115);
                }
                if (speedBoost > 0) {
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillText(`‚ö° Speed: ${Math.ceil(speedBoost/60)}s`, 15, slowMo > 0 ? 135 : 115);
                }
                
                ctx.fillStyle = '#00ff88';
                ctx.fillText('Click to reverse direction', canvas.width - 220, 30);

                gameLoop = requestAnimationFrame(update);
            }

            checkQuests(6, {score: Math.floor(score / 10)});
            update();
        }

        // GAME 7: LASER DODGE
        function initLaserDodge() {
            let player = {x: 400, y: 300, size: 20, speed: 5};
            let lasers = [];
            let score = 0;
            let gameOver = false;
            let keys = {};
            let laserWidth = 5; // Starts at 5, gets thicker
            
            const activeSkin = getActiveSkin(7);
            const playerColor = activeSkin?.color || '#00ff88';

            document.addEventListener('keydown', (e) => { keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key] = false; });

            function spawnLaser() {
                // EASIER START - gentler spawn rate increase
                const spawnChance = 0.012 + (score / 5000); // Start at 1.2%, slower increase
                
                if (Math.random() < spawnChance) {
                    const vertical = Math.random() < 0.5;
                    
                    // SLOWER speed at start
                    const baseSpeed = 3 + (score / 500); // Start at 3 instead of 4, slower increase
                    
                    // MORE WARNING TIME at start
                    const warningTime = Math.max(18, 80 - (score / 180)); // Start with 80 frames, gentler decrease
                    
                    // THINNER lasers at start
                    const thickness = Math.min(20, 3 + (score / 600)); // Start at 3px, slower growth
                    
                    if (vertical) {
                        lasers.push({
                            x: Math.random() * (canvas.width - 100) + 50,
                            y: -600,
                            w: thickness,
                            h: 600,
                            vertical: true,
                            speed: baseSpeed + Math.random() * 2, // Less variation
                            warningTime: warningTime
                        });
                    } else {
                        lasers.push({
                            x: -600,
                            y: Math.random() * (canvas.height - 100) + 50,
                            w: 600,
                            h: thickness,
                            vertical: false,
                            speed: baseSpeed + Math.random() * 2,
                            warningTime: warningTime
                        });
                    }
                }
                
                // DIAGONAL ROTATING LASERS - later and less common
                if (score > 800 && Math.random() < 0.004 + (score / 15000)) {
                    const angle = Math.random() * Math.PI * 2;
                    lasers.push({
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        w: 800,
                        h: 4 + (score / 1000),
                        vertical: false,
                        speed: 0,
                        angle: angle,
                        rotating: true,
                        rotationSpeed: 0.02 + (score / 50000),
                        warningTime: Math.max(35, 90 - (score / 150))
                    });
                }
            }

            function update() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (gameOver) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 40);
                    ctx.font = '30px Arial';
                    ctx.fillText(`Score: ${Math.floor(score / 10)}`, canvas.width/2, canvas.height/2 + 20);
                    ctx.fillText('Click anywhere to restart', canvas.width/2, canvas.height/2 + 60);
                    ctx.textAlign = 'left';
                    
                    canvas.onclick = () => {
                        canvas.onclick = null;
                        initLaserDodge();
                    };
                    return;
                }

                // Player movement
                if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
                if (keys['ArrowRight'] || keys['d']) player.x += player.speed;
                if (keys['ArrowUp'] || keys['w']) player.y -= player.speed;
                if (keys['ArrowDown'] || keys['s']) player.y += player.speed;

                // Keep player in bounds
                player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
                player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

                spawnLaser();
                score++;

                // Update lasers
                lasers.forEach((laser, i) => {
                    if (laser.warningTime > 0) {
                        laser.warningTime--;
                        if (laser.rotating) {
                            laser.angle += laser.rotationSpeed;
                        }
                    } else {
                        if (laser.rotating) {
                            laser.angle += laser.rotationSpeed;
                        } else if (laser.vertical) {
                            laser.y += laser.speed;
                        } else {
                            laser.x += laser.speed;
                        }

                        // Remove off-screen lasers
                        if (laser.y > canvas.height + 100 || laser.x > canvas.width + 100) {
                            lasers.splice(i, 1);
                        }

                        // Collision check (only when laser is active, not in warning)
                        if (laser.rotating) {
                            // Rotating laser collision (line-based)
                            const cos = Math.cos(laser.angle);
                            const sin = Math.sin(laser.angle);
                            const dx = player.x - laser.x;
                            const dy = player.y - laser.y;
                            const dist = Math.abs(dy * cos - dx * sin);
                            const alongLine = dx * cos + dy * sin;
                            
                            if (dist < player.size + laser.h / 2 && Math.abs(alongLine) < laser.w / 2) {
                                gameOver = true;
                            }
                        } else {
                            // Regular laser collision
                            if (player.x + player.size > laser.x && player.x - player.size < laser.x + laser.w &&
                                player.y + player.size > laser.y && player.y - player.size < laser.y + laser.h) {
                                gameOver = true;
                            }
                        }
                    }
                });

                // Draw lasers
                lasers.forEach(laser => {
                    if (laser.warningTime > 0) {
                        // Warning flash
                        const alpha = laser.warningTime % 20 < 10 ? 0.5 : 0.2;
                        ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                        ctx.lineWidth = laser.rotating ? laser.h * 2 : (laser.vertical ? laser.w : laser.h);
                        ctx.beginPath();
                        
                        if (laser.rotating) {
                            const cos = Math.cos(laser.angle);
                            const sin = Math.sin(laser.angle);
                            ctx.moveTo(laser.x - cos * laser.w/2, laser.y - sin * laser.w/2);
                            ctx.lineTo(laser.x + cos * laser.w/2, laser.y + sin * laser.w/2);
                        } else if (laser.vertical) {
                            ctx.moveTo(laser.x, 0);
                            ctx.lineTo(laser.x, canvas.height);
                        } else {
                            ctx.moveTo(0, laser.y);
                            ctx.lineTo(canvas.width, laser.y);
                        }
                        ctx.stroke();
                    } else {
                        // Active laser
                        ctx.fillStyle = '#ff0000';
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 20;
                        
                        if (laser.rotating) {
                            // Draw rotating laser
                            ctx.save();
                            ctx.translate(laser.x, laser.y);
                            ctx.rotate(laser.angle);
                            ctx.fillRect(-laser.w/2, -laser.h/2, laser.w, laser.h);
                            ctx.restore();
                        } else {
                            ctx.fillRect(laser.x, laser.y, laser.w, laser.h);
                        }
                        ctx.shadowBlur = 0;
                    }
                });

                // Draw player
                ctx.fillStyle = playerColor;
                ctx.shadowColor = playerColor;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // UI
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, 250, 100);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${Math.floor(score / 10)}`, 20, 40);
                ctx.font = '16px Arial';
                ctx.fillText('WASD or Arrows to move', 20, 65);
                
                // Difficulty indicator
                const difficulty = Math.min(100, Math.floor(score / 50));
                ctx.fillText(`Difficulty: ${difficulty}%`, 20, 90);
                
                // Difficulty bar
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(20, 95, 200, 10);
                const barColor = difficulty < 30 ? '#00ff88' : difficulty < 70 ? '#ffff00' : '#ff4444';
                ctx.fillStyle = barColor;
                ctx.fillRect(20, 95, (difficulty / 100) * 200, 10);

                gameLoop = requestAnimationFrame(update);
            }

            checkQuests(7, {score: Math.floor(score / 10)});
            update();
        }

        // GAME 8: BOUNCE MASTER
        function initBounceMaster() {
            let ball = {x: 400, y: 100, vx: 0, vy: 0, size: 15, gravity: 0.5, speed: 6};
            let platforms = [];
            let score = 0;
            let gameOver = false;
            let perfectBounces = 0;
            let combo = 0;
            let maxCombo = 0;
            let keys = {};
            let particles = [];
            let doubleJump = true;
            let doubleJumpUsed = false;
            
            const activeSkin = getActiveSkin(8);
            const ballColor = activeSkin?.color || '#00ff88';

            // Keyboard controls
            const keyDownHandler = (e) => { 
                keys[e.key] = true;
                // Double jump with space
                if ((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && !doubleJumpUsed && !ball.onGround) {
                    ball.vy = -11;
                    doubleJumpUsed = true;
                    // Jump particles
                    for (let i = 0; i < 15; i++) {
                        particles.push({
                            x: ball.x,
                            y: ball.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: Math.random() * 3,
                            life: 20,
                            color: '#ffff00'
                        });
                    }
                }
            };
            const keyUpHandler = (e) => { keys[e.key] = false; };
            
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);

            // Platform types
            const platformTypes = {
                normal: { color: '#00d4ff', bonus: 10, glow: '#00d4ff' },
                moving: { color: '#ffd700', bonus: 15, glow: '#ffd700' },
                bouncy: { color: '#ff00ff', bonus: 20, glow: '#ff00ff', bouncePower: 1.3 },
                fragile: { color: '#ff6666', bonus: 25, glow: '#ff6666', breakAfter: 1 },
                cloud: { color: '#ffffff', bonus: 30, glow: '#ffffff', soft: true }
            };

            // Generate initial platforms
            for (let i = 0; i < 6; i++) {
                let type = 'normal';
                if (i > 2) {
                    const rand = Math.random();
                    if (rand < 0.3) type = 'moving';
                    else if (rand < 0.5) type = 'bouncy';
                }
                
                platforms.push({
                    x: Math.random() * (canvas.width - 150) + 50,
                    y: 150 + i * 100,
                    w: 120,
                    h: 12,
                    type: type,
                    moving: type === 'moving',
                    speed: type === 'moving' ? (Math.random() - 0.5) * 2 : 0,
                    hits: 0
                });
            }

            function createPlatform() {
                const newWidth = Math.max(60, 120 - score / 40);
                let type = 'normal';
                
                const rand = Math.random();
                const difficulty = Math.min(score / 500, 0.8);
                
                if (rand < 0.2 + difficulty * 0.2) type = 'moving';
                else if (rand < 0.3 + difficulty * 0.15) type = 'bouncy';
                else if (rand < 0.4 + difficulty * 0.1) type = 'fragile';
                else if (rand < 0.45 + difficulty * 0.05) type = 'cloud';
                
                return {
                    x: Math.random() * (canvas.width - newWidth - 100) + 50,
                    y: Math.min(...platforms.map(p => p.y)) - 100,
                    w: newWidth,
                    h: 12,
                    type: type,
                    moving: type === 'moving',
                    speed: type === 'moving' ? (Math.random() - 0.5) * (2 + score / 150) : 0,
                    hits: 0
                };
            }

            function update() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (gameOver) {
                    // Clean up listeners
                    document.removeEventListener('keydown', keyDownHandler);
                    document.removeEventListener('keyup', keyUpHandler);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 60);
                    ctx.font = '30px Arial';
                    ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 - 10);
                    ctx.fillText(`Perfect: ${perfectBounces}`, canvas.width/2, canvas.height/2 + 30);
                    ctx.fillText(`Max Combo: ${maxCombo}`, canvas.width/2, canvas.height/2 + 70);
                    ctx.fillText('Click to restart', canvas.width/2, canvas.height/2 + 110);
                    ctx.textAlign = 'left';
                    
                    canvas.onclick = () => {
                        canvas.onclick = null;
                        initBounceMaster();
                    };
                    return;
                }

                // Player horizontal control
                ball.vx = 0;
                if (keys['ArrowLeft'] || keys['a']) ball.vx = -ball.speed;
                if (keys['ArrowRight'] || keys['d']) ball.vx = ball.speed;

                // Ball physics
                ball.vy += ball.gravity;
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.onGround = false;

                // Keep ball in bounds horizontally
                ball.x = Math.max(ball.size, Math.min(canvas.width - ball.size, ball.x));

                // Fall off bottom
                if (ball.y > canvas.height + 50) {
                    gameOver = true;
                    maxCombo = Math.max(maxCombo, combo);
                }

                // Platform collisions
                platforms.forEach((plat, i) => {
                    // Move platform
                    if (plat.moving) {
                        plat.x += plat.speed;
                        if (plat.x < 0 || plat.x + plat.w > canvas.width) {
                            plat.speed *= -1;
                        }
                    }

                    // Collision from above
                    if (ball.vy > 0 &&
                        ball.x > plat.x - ball.size && 
                        ball.x < plat.x + plat.w + ball.size &&
                        ball.y + ball.size > plat.y && 
                        ball.y + ball.size < plat.y + plat.h + 15) {
                        
                        const platType = platformTypes[plat.type];
                        const bouncePower = platType.bouncePower || 1;
                        
                        ball.vy = -13 * bouncePower;
                        ball.y = plat.y - ball.size;
                        ball.onGround = true;
                        doubleJumpUsed = false; // Reset double jump
                        
                        score += platType.bonus;
                        combo++;
                        maxCombo = Math.max(maxCombo, combo);

                        // Perfect bounce check
                        const platCenter = plat.x + plat.w / 2;
                        const isPerfect = Math.abs(ball.x - platCenter) < plat.w / 4;
                        
                        if (isPerfect) {
                            perfectBounces++;
                            score += 20 + combo * 2;
                            plat.perfect = 15;
                        }

                        // Bounce particles
                        for (let j = 0; j < 10; j++) {
                            particles.push({
                                x: ball.x,
                                y: ball.y + ball.size,
                                vx: (Math.random() - 0.5) * 5,
                                vy: -Math.random() * 3,
                                life: 20,
                                color: platType.glow
                            });
                        }

                        // Handle special platforms
                        if (plat.type === 'fragile') {
                            plat.hits++;
                            if (plat.hits >= platformTypes.fragile.breakAfter) {
                                plat.breaking = 30;
                            }
                        }

                        // Remove and add new platform
                        if (!plat.breaking) {
                            platforms.splice(i, 1);
                            platforms.push(createPlatform());
                        }
                    }
                });

                // Update particles
                particles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                });

                // Update breaking platforms
                platforms.forEach((plat, i) => {
                    if (plat.breaking !== undefined) {
                        plat.breaking--;
                        if (plat.breaking <= 0) {
                            platforms.splice(i, 1);
                            platforms.push(createPlatform());
                        }
                    }
                    if (plat.perfect !== undefined && plat.perfect > 0) {
                        plat.perfect--;
                    }
                });

                // Camera scroll
                if (ball.y < canvas.height / 3) {
                    const diff = canvas.height / 3 - ball.y;
                    ball.y = canvas.height / 3;
                    platforms.forEach(p => p.y += diff);
                }

                // Remove far platforms and ensure minimum count
                platforms = platforms.filter(p => p.y < canvas.height + 50);
                while (platforms.length < 5) {
                    platforms.push(createPlatform());
                }

                // Draw particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 20;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw platforms
                platforms.forEach(plat => {
                    const platType = platformTypes[plat.type];
                    
                    if (plat.breaking !== undefined) {
                        ctx.globalAlpha = plat.breaking / 30;
                    }
                    
                    if (plat.perfect && plat.perfect > 0) {
                        ctx.fillStyle = '#00ff88';
                        ctx.shadowColor = '#00ff88';
                    } else {
                        ctx.fillStyle = platType.color;
                        ctx.shadowColor = platType.glow;
                    }
                    
                    ctx.shadowBlur = 15;
                    ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
                    
                    // Center marker
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    const centerZone = plat.w / 4;
                    ctx.fillRect(plat.x + plat.w/2 - centerZone/2, plat.y, centerZone, plat.h);
                    
                    ctx.globalAlpha = 1;
                });
                ctx.shadowBlur = 0;

                // Draw ball
                ctx.fillStyle = ballColor;
                ctx.shadowColor = ballColor;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Double jump indicator
                if (!doubleJumpUsed && !ball.onGround) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Velocity indicator
                if (ball.vx !== 0) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(ball.x, ball.y);
                    ctx.lineTo(ball.x + ball.vx * 3, ball.y);
                    ctx.stroke();
                }

                // UI
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(5, 5, 300, 130);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 26px Arial';
                ctx.fillText(`Score: ${score}`, 15, 35);
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.fillText(`Combo: x${combo}`, 15, 65);
                
                ctx.fillStyle = '#00ff88';
                ctx.fillText(`Perfect: ${perfectBounces}`, 15, 95);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ffff00';
                ctx.fillText('‚Üê ‚Üí : Move | Space/‚Üë : Double Jump', 15, 120);

                // Combo display
                if (combo > 2) {
                    ctx.font = `bold ${20 + combo * 2}px Arial`;
                    ctx.fillStyle = `hsl(${(combo * 30) % 360}, 100%, 50%)`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`${combo}x COMBO!`, canvas.width / 2, 60);
                    ctx.textAlign = 'left';
                }

                gameLoop = requestAnimationFrame(update);
            }

            checkQuests(8, {score: score, perfectBounces: perfectBounces});
            update();
        }

        // Default game for unimplemented games
        // GAME 9: TUNNEL RUSH - Simple & Intuitive!
        function initTunnelRush() {
            let player = {x: canvas.width / 2, y: canvas.height - 100, width: 40, height: 40};
            let obstacles = [];
            let score = 0;
            let gameOver = false;
            let speed = 4;
            let keys = {left: false, right: false};

            const keyDownHandler = (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            };

            const keyUpHandler = (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            };

            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);

            // Spawn obstacle
            function spawnObstacle() {
                // Random lane (0 = left, 1 = middle, 2 = right)
                const lanes = 3;
                const laneWidth = canvas.width / lanes;
                const obstacleWidth = laneWidth - 30; // More space between obstacles
                
                // Only block 1 lane at easy levels, 2 lanes at harder levels
                const numBlocked = score < 100 ? 1 : (Math.random() > 0.7 ? 2 : 1);
                const blockedLanes = [];
                
                for (let i = 0; i < numBlocked; i++) {
                    let lane;
                    do {
                        lane = Math.floor(Math.random() * lanes);
                    } while (blockedLanes.includes(lane));
                    blockedLanes.push(lane);
                    
                    obstacles.push({
                        x: lane * laneWidth + 15,
                        y: -50,
                        width: obstacleWidth,
                        height: 35,
                        color: `hsl(${(score * 3) % 360}, 80%, 60%)`
                    });
                }
            }

            // Initial obstacles with good spacing
            for (let i = 0; i < 4; i++) {
                spawnObstacle();
                obstacles[obstacles.length - 1].y = -i * 200 - 150;
            }

            function gameLoop() {
                if (gameOver) return;

                // Background
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw tunnel effect (perspective lines)
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    const y = i * (canvas.height / 20);
                    const offset = Math.sin((score / 10) + i * 0.3) * 20;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // Draw lane dividers
                const laneWidth = canvas.width / 3;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 4;
                ctx.setLineDash([15, 10]);
                for (let i = 1; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * laneWidth, 0);
                    ctx.lineTo(i * laneWidth, canvas.height);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Move player (faster movement for better control)
                if (keys.left) player.x -= 10;
                if (keys.right) player.x += 10;

                // Keep player in bounds
                player.x = Math.max(10, Math.min(canvas.width - player.width - 10, player.x));

                // Update obstacles
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obs = obstacles[i];
                    obs.y += speed;

                    // Remove if off screen and spawn new
                    if (obs.y > canvas.height) {
                        obstacles.splice(i, 1);
                        if (i === 0) {
                            spawnObstacle();
                            score += 10;
                        }
                        continue;
                    }

                    // Draw obstacle
                    ctx.fillStyle = obs.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = obs.color;
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.shadowBlur = 0;

                    // More forgiving collision detection
                    if (player.x + 5 < obs.x + obs.width &&
                        player.x + player.width - 5 > obs.x &&
                        player.y + 5 < obs.y + obs.height &&
                        player.y + player.height - 5 > obs.y) {
                        gameOver = true;
                        document.removeEventListener('keydown', keyDownHandler);
                        document.removeEventListener('keyup', keyUpHandler);
                        
                        setTimeout(() => {
                            ctx.fillStyle = 'rgba(0,0,0,0.8)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 48px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
                            ctx.font = 'bold 32px Arial';
                            ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 20);
                            ctx.font = '20px Arial';
                            ctx.fillStyle = '#888';
                            ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 70);
                            
                            const restartHandler = () => {
                                canvas.removeEventListener('click', restartHandler);
                                initTunnelRush(); // Restart the game instead of closing
                            };
                            canvas.addEventListener('click', restartHandler);
                        }, 100);
                        
                        checkQuests(9, {score: score});
                        return;
                    }
                }

                // Draw player
                ctx.fillStyle = '#00ff88';
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#00ff88';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                
                // Draw player direction indicator
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(player.x + player.width/2, player.y - 10);
                ctx.lineTo(player.x + player.width/2 - 8, player.y - 20);
                ctx.lineTo(player.x + player.width/2 + 8, player.y - 20);
                ctx.fill();
                ctx.shadowBlur = 0;

                // UI
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Score: ' + score, 20, 40);
                
                // Show speed level
                const speedLevel = Math.floor((speed - 4) / 0.5) + 1;
                ctx.font = '20px Arial';
                ctx.fillText('Speed: ' + speedLevel, 20, 70);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üê ‚Üí or A D to move', canvas.width/2, canvas.height - 20);

                // Slower speed increase - caps at reasonable level
                speed = Math.min(8, 4 + (score / 200));

                requestAnimationFrame(gameLoop);
            }

            gameLoop();
        }
        // GAME 10: ZIG ZAG - Simple Bouncing Ball!
        function initZigZag() {
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let ball = {x: canvas.width / 2, y: 50, size: 20, vx: 4, vy: 0};
            let platforms = [];
            let score = 0;
            let gameOver = false;
            let clickHandler = null;
            let lastPlatformSide = 'left';
            let animationId = null;

            // Generate initial platforms
            for (let i = 0; i < 8; i++) {
                // Alternate sides for clear zigzag pattern
                const side = i % 2 === 0 ? 'left' : 'right';
                const y = 150 + i * 80;
                const width = 180;
                
                platforms.push({
                    x: side === 'left' ? 20 : canvas.width - width - 20,
                    y: y,
                    width: width,
                    height: 20,
                    side: side,
                    color: `hsl(${(i * 40) % 360}, 75%, 55%)`,
                    passed: false
                });
            }

            lastPlatformSide = platforms[platforms.length - 1].side;

            clickHandler = (e) => {
                if (!gameOver) {
                    // Reverse horizontal direction
                    ball.vx *= -1;
                    
                    // Small visual feedback
                    ball.size = 25;
                    setTimeout(() => { if (!gameOver) ball.size = 20; }, 100);
                }
            };

            canvas.addEventListener('click', clickHandler);

            function gameLoop() {
                if (gameOver) {
                    if (animationId) cancelAnimationFrame(animationId);
                    return;
                }

                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#0f0f1e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Move ball
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.vy += 0.4; // Gravity

                // Bounce off left/right edges (safety)
                if (ball.x - ball.size < 0) {
                    ball.x = ball.size;
                    ball.vx = Math.abs(ball.vx);
                }
                if (ball.x + ball.size > canvas.width) {
                    ball.x = canvas.width - ball.size;
                    ball.vx = -Math.abs(ball.vx);
                }

                // Move platforms down (camera moves up effect)
                for (let platform of platforms) {
                    platform.y -= 2;
                }

                // Remove platforms that went off top and add new ones at bottom
                platforms = platforms.filter(p => p.y > -50);
                
                while (platforms.length < 8) {
                    const lastPlatform = platforms[platforms.length - 1];
                    const newSide = lastPlatform.side === 'left' ? 'right' : 'left';
                    const y = lastPlatform.y + 80;
                    const width = 180;
                    
                    platforms.push({
                        x: newSide === 'left' ? 20 : canvas.width - width - 20,
                        y: y,
                        width: width,
                        height: 20,
                        side: newSide,
                        color: `hsl(${(platforms.length * 40) % 360}, 75%, 55%)`,
                        passed: false
                    });
                }

                // Draw platforms
                for (let platform of platforms) {
                    // Platform
                    ctx.fillStyle = platform.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = platform.color;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.shadowBlur = 0;
                    
                    // Direction arrow on platform
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    if (platform.side === 'left') {
                        // Arrow pointing right
                        ctx.beginPath();
                        ctx.moveTo(platform.x + platform.width - 10, platform.y + platform.height/2);
                        ctx.lineTo(platform.x + platform.width + 5, platform.y + 5);
                        ctx.lineTo(platform.x + platform.width + 5, platform.y + platform.height - 5);
                        ctx.fill();
                    } else {
                        // Arrow pointing left
                        ctx.beginPath();
                        ctx.moveTo(platform.x + 10, platform.y + platform.height/2);
                        ctx.lineTo(platform.x - 5, platform.y + 5);
                        ctx.lineTo(platform.x - 5, platform.y + platform.height - 5);
                        ctx.fill();
                    }
                    
                    // Platform collision detection
                    if (ball.vy > 0 && // Ball falling down
                        ball.y + ball.size >= platform.y &&
                        ball.y + ball.size <= platform.y + platform.height + 10 &&
                        ball.x + ball.size > platform.x &&
                        ball.x - ball.size < platform.x + platform.width) {
                        
                        // Bounce!
                        ball.y = platform.y - ball.size;
                        ball.vy = -10;
                        
                        // Score only once per platform
                        if (!platform.passed) {
                            platform.passed = true;
                            score += 10;
                        }
                    }
                }

                // Check if ball fell off screen
                if (ball.y > canvas.height + 50) {
                    gameOver = true;
                    canvas.removeEventListener('click', clickHandler);
                    if (animationId) cancelAnimationFrame(animationId);
                    
                    setTimeout(() => {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
                        ctx.font = 'bold 32px Arial';
                        ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 20);
                        ctx.font = '20px Arial';
                        ctx.fillStyle = '#888';
                        ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 70);
                        
                        const restartHandler = (e) => {
                            e.stopPropagation();
                            canvas.removeEventListener('click', restartHandler);
                            initZigZag();
                        };
                        canvas.addEventListener('click', restartHandler);
                    }, 100);
                    
                    checkQuests(10, {score: score});
                    return;
                }

                // Draw ball
                ctx.fillStyle = '#00ff88';
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#00ff88';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Draw direction indicator on ball
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + (ball.vx > 0 ? 15 : -15), ball.y);
                ctx.stroke();

                // UI
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Score: ' + score, 20, 40);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('CLICK to change direction', canvas.width/2, 30);

                animationId = requestAnimationFrame(gameLoop);
            }

            gameLoop();
        }

        // GAME 11: BLOCK PUZZLE - With Power-ups and Upgrades!
        function initBlockPuzzle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Show tutorial on first play
            if (!localStorage.getItem('blockPuzzleTutorialSeen')) {
                setTimeout(() => {
                    showNotification('üí° Earn coins by clearing lines! Spend them in the üõí SHOP to buy power-ups!');
                    localStorage.setItem('blockPuzzleTutorialSeen', 'true');
                }, 1000);
            }
            
            const GRID_SIZE = 8;
            const CELL_SIZE = 50;
            const GRID_OFFSET_X = 50;
            const GRID_OFFSET_Y = 100;
            
            let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            let score = 0;
            let gameOver = false;
            let currentBlocks = [];
            let selectedBlock = null;
            let mouseX = 0;
            let mouseY = 0;
            let animationId = null;
            let particles = [];
            
            // Load power-ups from localStorage (purchased from shop)
            const savedPowerUps = JSON.parse(localStorage.getItem('blockPuzzlePowerUps') || '{"bomb":2,"lightning":1,"hammer":3,"shuffle":1}');
            let powerUps = {...savedPowerUps}; // Copy so we can modify in game
            
            let activePowerUp = null;
            let combo = 0;
            let maxCombo = 0;
            let coins = 0;
            
            // Block shapes (Tetris pieces)
            const blockShapes = [
                [[1, 1], [1, 1]], // Square
                [[1, 1, 1]], // Line 3
                [[1], [1], [1]], // Vertical 3
                [[1, 1, 1, 1]], // Line 4
                [[1], [1], [1], [1]], // Vertical 4
                [[1, 1], [1, 0]], // L shape
                [[1, 0], [1, 1]], // Reverse L
                [[1, 1, 1], [0, 1, 0]], // T shape
                [[0, 1], [1, 1]], // Z shape
                [[1, 0], [1, 1], [1, 0]], // Plus
                [[1]], // Single
                [[1, 1]], // 2 horizontal
                [[1], [1]], // 2 vertical
            ];
            
            // Create particles
            function createParticles(x, y, color, count = 10) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 2,
                        life: 60,
                        color: color,
                        size: Math.random() * 4 + 2
                    });
                }
            }
            
            // Generate 3 random blocks
            function generateBlocks() {
                currentBlocks = [];
                for (let i = 0; i < 3; i++) {
                    const shape = blockShapes[Math.floor(Math.random() * blockShapes.length)];
                    const color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    currentBlocks.push({
                        shape: shape,
                        color: color,
                        x: 50 + i * 150,
                        y: canvas.height - 120,
                        used: false
                    });
                }
            }
            
            // Check if block can be placed at position
            function canPlace(block, gridX, gridY) {
                for (let y = 0; y < block.shape.length; y++) {
                    for (let x = 0; x < block.shape[y].length; x++) {
                        if (block.shape[y][x] === 1) {
                            const newX = gridX + x;
                            const newY = gridY + y;
                            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                                return false;
                            }
                            if (grid[newY][newX] !== 0) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            // Place block on grid
            function placeBlock(block, gridX, gridY) {
                for (let y = 0; y < block.shape.length; y++) {
                    for (let x = 0; x < block.shape[y].length; x++) {
                        if (block.shape[y][x] === 1) {
                            grid[gridY + y][gridX + x] = block.color;
                            const posX = GRID_OFFSET_X + (gridX + x) * CELL_SIZE + CELL_SIZE/2;
                            const posY = GRID_OFFSET_Y + (gridY + y) * CELL_SIZE + CELL_SIZE/2;
                            createParticles(posX, posY, block.color, 5);
                        }
                    }
                }
                block.used = true;
                selectedBlock = null;
                combo++;
                
                // Check for complete rows/columns
                const linesCleared = clearLines();
                
                if (linesCleared === 0) {
                    combo = 0;
                }
                
                // Generate new blocks if all used
                if (currentBlocks.every(b => b.used)) {
                    generateBlocks();
                    score += 50 + (combo * 10); // Combo bonus
                    coins += 5;
                    
                    // Random power-up chance
                    if (Math.random() < 0.3) {
                        const powerUpTypes = ['bomb', 'lightning', 'hammer'];
                        const randomPowerUp = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                        powerUps[randomPowerUp]++;
                    }
                }
                
                // Check game over
                if (!canPlaceAny()) {
                    endGame();
                }
            }
            
            // Clear complete lines
            function clearLines() {
                let linesCleared = 0;
                let clearedCells = [];
                
                // Check rows
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (grid[y].every(cell => cell !== 0)) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            clearedCells.push({x, y, color: grid[y][x]});
                        }
                        grid[y] = Array(GRID_SIZE).fill(0);
                        linesCleared++;
                        score += 100 + (combo * 20);
                        coins += 2;
                    }
                }
                
                // Check columns
                for (let x = 0; x < GRID_SIZE; x++) {
                    let full = true;
                    for (let y = 0; y < GRID_SIZE; y++) {
                        if (grid[y][x] === 0) {
                            full = false;
                            break;
                        }
                    }
                    if (full) {
                        for (let y = 0; y < GRID_SIZE; y++) {
                            if (!clearedCells.some(c => c.x === x && c.y === y)) {
                                clearedCells.push({x, y, color: grid[y][x]});
                            }
                            grid[y][x] = 0;
                        }
                        linesCleared++;
                        score += 100 + (combo * 20);
                        coins += 2;
                    }
                }
                
                // Create particles for cleared cells
                for (let cell of clearedCells) {
                    const posX = GRID_OFFSET_X + cell.x * CELL_SIZE + CELL_SIZE/2;
                    const posY = GRID_OFFSET_Y + cell.y * CELL_SIZE + CELL_SIZE/2;
                    createParticles(posX, posY, cell.color, 15);
                }
                
                // Combo bonus
                if (linesCleared > 1) {
                    score += linesCleared * 50;
                    coins += linesCleared;
                }
                
                if (linesCleared > 0) {
                    maxCombo = Math.max(maxCombo, combo);
                }
                
                return linesCleared;
            }
            
            // Power-up: Bomb (clears 3x3 area)
            function useBomb(gridX, gridY) {
                if (powerUps.bomb <= 0) return;
                powerUps.bomb--;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const x = gridX + dx;
                        const y = gridY + dy;
                        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && grid[y][x] !== 0) {
                            const posX = GRID_OFFSET_X + x * CELL_SIZE + CELL_SIZE/2;
                            const posY = GRID_OFFSET_Y + y * CELL_SIZE + CELL_SIZE/2;
                            createParticles(posX, posY, grid[y][x], 20);
                            grid[y][x] = 0;
                        }
                    }
                }
                
                score += 50;
                activePowerUp = null;
            }
            
            // Power-up: Lightning (clears entire row)
            function useLightning(gridY) {
                if (powerUps.lightning <= 0) return;
                powerUps.lightning--;
                
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[gridY][x] !== 0) {
                        const posX = GRID_OFFSET_X + x * CELL_SIZE + CELL_SIZE/2;
                        const posY = GRID_OFFSET_Y + gridY * CELL_SIZE + CELL_SIZE/2;
                        createParticles(posX, posY, grid[gridY][x], 15);
                        grid[gridY][x] = 0;
                    }
                }
                
                score += 75;
                activePowerUp = null;
            }
            
            // Power-up: Hammer (removes single cell)
            function useHammer(gridX, gridY) {
                if (powerUps.hammer <= 0) return;
                if (grid[gridY][gridX] === 0) return;
                
                powerUps.hammer--;
                const posX = GRID_OFFSET_X + gridX * CELL_SIZE + CELL_SIZE/2;
                const posY = GRID_OFFSET_Y + gridY * CELL_SIZE + CELL_SIZE/2;
                createParticles(posX, posY, grid[gridY][gridX], 10);
                grid[gridY][gridX] = 0;
                
                score += 10;
                activePowerUp = null;
            }
            
            // Power-up: Shuffle (get new blocks)
            function useShuffle() {
                if (powerUps.shuffle <= 0) return;
                powerUps.shuffle--;
                
                currentBlocks = currentBlocks.filter(b => b.used);
                const needed = 3 - currentBlocks.length;
                
                for (let i = 0; i < needed; i++) {
                    const shape = blockShapes[Math.floor(Math.random() * blockShapes.length)];
                    const color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    currentBlocks.push({
                        shape: shape,
                        color: color,
                        x: 50 + currentBlocks.length * 150,
                        y: canvas.height - 120,
                        used: false
                    });
                }
                
                activePowerUp = null;
            }
            
            // Check if any block can be placed
            function canPlaceAny() {
                for (let block of currentBlocks) {
                    if (block.used) continue;
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            if (canPlace(block, x, y)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            function endGame() {
                gameOver = true;
                canvas.removeEventListener('mousedown', mouseDownHandler);
                canvas.removeEventListener('mousemove', mouseMoveHandler);
                canvas.removeEventListener('mouseup', mouseUpHandler);
                if (animationId) cancelAnimationFrame(animationId);
                
                // Save coins to Block Puzzle specific storage (not global hub currency)
                const savedCoins = parseInt(localStorage.getItem('blockPuzzleCoins') || '0');
                localStorage.setItem('blockPuzzleCoins', (savedCoins + coins).toString());
                
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 60);
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 - 10);
                    ctx.fillText('üí∞ Coins: ' + coins, canvas.width/2, canvas.height/2 + 30);
                    ctx.font = '24px Arial';
                    ctx.fillText('Max Combo: ' + maxCombo + 'x', canvas.width/2, canvas.height/2 + 70);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 110);
                    
                    const restartHandler = (e) => {
                        e.stopPropagation();
                        canvas.removeEventListener('click', restartHandler);
                        initBlockPuzzle();
                    };
                    canvas.addEventListener('click', restartHandler);
                }, 100);
                
                checkQuests(11, {score: score, coins: coins, combo: maxCombo});
            }
            
            // Mouse handlers
            function mouseDownHandler(e) {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                
                // Check power-up buttons
                if (mouseY >= 20 && mouseY <= 60) {
                    if (mouseX >= 420 && mouseX <= 460 && powerUps.bomb > 0) {
                        activePowerUp = activePowerUp === 'bomb' ? null : 'bomb';
                        return;
                    }
                    if (mouseX >= 470 && mouseX <= 510 && powerUps.lightning > 0) {
                        activePowerUp = activePowerUp === 'lightning' ? null : 'lightning';
                        return;
                    }
                    if (mouseX >= 520 && mouseX <= 560 && powerUps.hammer > 0) {
                        activePowerUp = activePowerUp === 'hammer' ? null : 'hammer';
                        return;
                    }
                    if (mouseX >= 570 && mouseX <= 610 && powerUps.shuffle > 0) {
                        useShuffle();
                        return;
                    }
                }
                
                // Check if using a power-up on grid
                if (activePowerUp) {
                    const gridX = Math.floor((mouseX - GRID_OFFSET_X) / CELL_SIZE);
                    const gridY = Math.floor((mouseY - GRID_OFFSET_Y) / CELL_SIZE);
                    
                    if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                        if (activePowerUp === 'bomb') useBomb(gridX, gridY);
                        else if (activePowerUp === 'lightning') useLightning(gridY);
                        else if (activePowerUp === 'hammer') useHammer(gridX, gridY);
                    }
                    return;
                }
                
                // Check if clicked on a block
                for (let block of currentBlocks) {
                    if (block.used) continue;
                    const blockWidth = block.shape[0].length * 30;
                    const blockHeight = block.shape.length * 30;
                    if (mouseX >= block.x && mouseX <= block.x + blockWidth &&
                        mouseY >= block.y && mouseY <= block.y + blockHeight) {
                        selectedBlock = block;
                        break;
                    }
                }
            }
            
            function mouseMoveHandler(e) {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            }
            
            function mouseUpHandler(e) {
                if (selectedBlock) {
                    // Try to place block
                    const gridX = Math.floor((mouseX - GRID_OFFSET_X) / CELL_SIZE);
                    const gridY = Math.floor((mouseY - GRID_OFFSET_Y) / CELL_SIZE);
                    
                    if (canPlace(selectedBlock, gridX, gridY)) {
                        placeBlock(selectedBlock, gridX, gridY);
                        score += 10;
                    } else {
                        selectedBlock = null;
                    }
                }
            }
            
            canvas.addEventListener('mousedown', mouseDownHandler);
            canvas.addEventListener('mousemove', mouseMoveHandler);
            canvas.addEventListener('mouseup', mouseUpHandler);
            
            generateBlocks();
            
            function gameLoop() {
                if (gameOver) return;
                
                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const posX = GRID_OFFSET_X + x * CELL_SIZE;
                        const posY = GRID_OFFSET_Y + y * CELL_SIZE;
                        
                        if (grid[y][x] === 0) {
                            ctx.fillStyle = '#2d2d44';
                            ctx.strokeStyle = '#1a1a2e';
                        } else {
                            ctx.fillStyle = grid[y][x];
                            ctx.strokeStyle = '#000';
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = grid[y][x];
                        }
                        
                        ctx.fillRect(posX, posY, CELL_SIZE - 2, CELL_SIZE - 2);
                        ctx.strokeRect(posX, posY, CELL_SIZE - 2, CELL_SIZE - 2);
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Draw power-up hover effect
                if (activePowerUp) {
                    const gridX = Math.floor((mouseX - GRID_OFFSET_X) / CELL_SIZE);
                    const gridY = Math.floor((mouseY - GRID_OFFSET_Y) / CELL_SIZE);
                    
                    if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#ffff00';
                        
                        if (activePowerUp === 'bomb') {
                            // Show 3x3 area
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const x = gridX + dx;
                                    const y = gridY + dy;
                                    if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                                        ctx.fillRect(GRID_OFFSET_X + x * CELL_SIZE, GRID_OFFSET_Y + y * CELL_SIZE, CELL_SIZE - 2, CELL_SIZE - 2);
                                    }
                                }
                            }
                        } else if (activePowerUp === 'lightning') {
                            // Show entire row
                            for (let x = 0; x < GRID_SIZE; x++) {
                                ctx.fillRect(GRID_OFFSET_X + x * CELL_SIZE, GRID_OFFSET_Y + gridY * CELL_SIZE, CELL_SIZE - 2, CELL_SIZE - 2);
                            }
                        } else if (activePowerUp === 'hammer') {
                            // Show single cell
                            ctx.fillRect(GRID_OFFSET_X + gridX * CELL_SIZE, GRID_OFFSET_Y + gridY * CELL_SIZE, CELL_SIZE - 2, CELL_SIZE - 2);
                        }
                        
                        ctx.globalAlpha = 1;
                    }
                }
                
                // Draw preview if dragging
                if (selectedBlock && !activePowerUp) {
                    const gridX = Math.floor((mouseX - GRID_OFFSET_X) / CELL_SIZE);
                    const gridY = Math.floor((mouseY - GRID_OFFSET_Y) / CELL_SIZE);
                    const valid = canPlace(selectedBlock, gridX, gridY);
                    
                    ctx.globalAlpha = 0.5;
                    for (let y = 0; y < selectedBlock.shape.length; y++) {
                        for (let x = 0; x < selectedBlock.shape[y].length; x++) {
                            if (selectedBlock.shape[y][x] === 1) {
                                const posX = GRID_OFFSET_X + (gridX + x) * CELL_SIZE;
                                const posY = GRID_OFFSET_Y + (gridY + y) * CELL_SIZE;
                                ctx.fillStyle = valid ? selectedBlock.color : '#ff4444';
                                ctx.fillRect(posX, posY, CELL_SIZE - 2, CELL_SIZE - 2);
                            }
                        }
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    ctx.globalAlpha = p.life / 60;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                
                // Draw available blocks
                for (let block of currentBlocks) {
                    if (block.used) continue;
                    
                    const isSelected = block === selectedBlock;
                    const drawX = isSelected ? mouseX - 30 : block.x;
                    const drawY = isSelected ? mouseY - 30 : block.y;
                    
                    for (let y = 0; y < block.shape.length; y++) {
                        for (let x = 0; x < block.shape[y].length; x++) {
                            if (block.shape[y][x] === 1) {
                                ctx.fillStyle = block.color;
                                ctx.shadowBlur = isSelected ? 15 : 5;
                                ctx.shadowColor = block.color;
                                ctx.fillRect(drawX + x * 30, drawY + y * 30, 28, 28);
                            }
                        }
                    }
                    ctx.shadowBlur = 0;
                }
                
                // UI - Score and Coins
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Score: ' + score, 20, 35);
                ctx.fillText('üí∞ ' + coins, 20, 65);
                
                // Combo meter
                if (combo > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('Combo: ' + combo + 'x', 180, 35);
                }
                
                // Power-up buttons
                const powerUpY = 20;
                const powerUpSize = 40;
                const powerUpSpacing = 50;
                let powerUpX = 420;
                
                // Bomb
                ctx.fillStyle = activePowerUp === 'bomb' ? '#ffff00' : (powerUps.bomb > 0 ? '#ff6b6b' : '#444');
                ctx.fillRect(powerUpX, powerUpY, powerUpSize, powerUpSize);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üí£', powerUpX + powerUpSize/2, powerUpY + 28);
                ctx.font = '12px Arial';
                ctx.fillText(powerUps.bomb, powerUpX + powerUpSize/2, powerUpY + powerUpSize + 12);
                
                // Lightning
                powerUpX += powerUpSpacing;
                ctx.fillStyle = activePowerUp === 'lightning' ? '#ffff00' : (powerUps.lightning > 0 ? '#ffd700' : '#444');
                ctx.fillRect(powerUpX, powerUpY, powerUpSize, powerUpSize);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('‚ö°', powerUpX + powerUpSize/2, powerUpY + 28);
                ctx.font = '12px Arial';
                ctx.fillText(powerUps.lightning, powerUpX + powerUpSize/2, powerUpY + powerUpSize + 12);
                
                // Hammer
                powerUpX += powerUpSpacing;
                ctx.fillStyle = activePowerUp === 'hammer' ? '#ffff00' : (powerUps.hammer > 0 ? '#00bfff' : '#444');
                ctx.fillRect(powerUpX, powerUpY, powerUpSize, powerUpSize);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('üî®', powerUpX + powerUpSize/2, powerUpY + 28);
                ctx.font = '12px Arial';
                ctx.fillText(powerUps.hammer, powerUpX + powerUpSize/2, powerUpY + powerUpSize + 12);
                
                // Shuffle
                powerUpX += powerUpSpacing;
                ctx.fillStyle = powerUps.shuffle > 0 ? '#9370db' : '#444';
                ctx.fillRect(powerUpX, powerUpY, powerUpSize, powerUpSize);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('üîÄ', powerUpX + powerUpSize/2, powerUpY + 28);
                ctx.font = '12px Arial';
                ctx.fillText(powerUps.shuffle, powerUpX + powerUpSize/2, powerUpY + powerUpSize + 12);
                
                // Instructions
                ctx.font = '14px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.textAlign = 'center';
                if (activePowerUp) {
                    ctx.fillText('Click on grid to use ' + activePowerUp.toUpperCase(), canvas.width/2, 85);
                } else {
                    ctx.fillText('Drag blocks to grid | Click power-ups to use', canvas.width/2, 85);
                }
                
                animationId = requestAnimationFrame(gameLoop);
            }
            
            gameLoop();
        }

        // GAME 12: NUMBER MATCH - 2048 style!
        function initNumberMatch() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const GRID_SIZE = 4;
            const CELL_SIZE = 90;
            const GRID_OFFSET_X = 80;
            const GRID_OFFSET_Y = 120;
            
            let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            let score = 0;
            let gameOver = false;
            let animationId = null;
            
            // Add random tile
            function addRandomTile() {
                const empty = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (grid[y][x] === 0) {
                            empty.push({x, y});
                        }
                    }
                }
                
                if (empty.length > 0) {
                    const pos = empty[Math.floor(Math.random() * empty.length)];
                    grid[pos.y][pos.x] = Math.random() > 0.9 ? 4 : 2;
                }
            }
            
            // Move and merge tiles
            function move(direction) {
                let moved = false;
                const newGrid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
                
                if (direction === 'left') {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        let pos = 0;
                        for (let x = 0; x < GRID_SIZE; x++) {
                            if (grid[y][x] !== 0) {
                                if (newGrid[y][pos] === 0) {
                                    newGrid[y][pos] = grid[y][x];
                                    if (pos !== x) moved = true;
                                } else if (newGrid[y][pos] === grid[y][x]) {
                                    newGrid[y][pos] *= 2;
                                    score += newGrid[y][pos];
                                    pos++;
                                    moved = true;
                                } else {
                                    pos++;
                                    newGrid[y][pos] = grid[y][x];
                                    if (pos !== x) moved = true;
                                }
                            }
                        }
                    }
                } else if (direction === 'right') {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        let pos = GRID_SIZE - 1;
                        for (let x = GRID_SIZE - 1; x >= 0; x--) {
                            if (grid[y][x] !== 0) {
                                if (newGrid[y][pos] === 0) {
                                    newGrid[y][pos] = grid[y][x];
                                    if (pos !== x) moved = true;
                                } else if (newGrid[y][pos] === grid[y][x]) {
                                    newGrid[y][pos] *= 2;
                                    score += newGrid[y][pos];
                                    pos--;
                                    moved = true;
                                } else {
                                    pos--;
                                    newGrid[y][pos] = grid[y][x];
                                    if (pos !== x) moved = true;
                                }
                            }
                        }
                    }
                } else if (direction === 'up') {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        let pos = 0;
                        for (let y = 0; y < GRID_SIZE; y++) {
                            if (grid[y][x] !== 0) {
                                if (newGrid[pos][x] === 0) {
                                    newGrid[pos][x] = grid[y][x];
                                    if (pos !== y) moved = true;
                                } else if (newGrid[pos][x] === grid[y][x]) {
                                    newGrid[pos][x] *= 2;
                                    score += newGrid[pos][x];
                                    pos++;
                                    moved = true;
                                } else {
                                    pos++;
                                    newGrid[pos][x] = grid[y][x];
                                    if (pos !== y) moved = true;
                                }
                            }
                        }
                    }
                } else if (direction === 'down') {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        let pos = GRID_SIZE - 1;
                        for (let y = GRID_SIZE - 1; y >= 0; y--) {
                            if (grid[y][x] !== 0) {
                                if (newGrid[pos][x] === 0) {
                                    newGrid[pos][x] = grid[y][x];
                                    if (pos !== y) moved = true;
                                } else if (newGrid[pos][x] === grid[y][x]) {
                                    newGrid[pos][x] *= 2;
                                    score += newGrid[pos][x];
                                    pos--;
                                    moved = true;
                                } else {
                                    pos--;
                                    newGrid[pos][x] = grid[y][x];
                                    if (pos !== y) moved = true;
                                }
                            }
                        }
                    }
                }
                
                if (moved) {
                    grid = newGrid;
                    addRandomTile();
                    
                    if (!canMove()) {
                        endGame();
                    }
                }
            }
            
            function canMove() {
                // Check for empty cells
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (grid[y][x] === 0) return true;
                    }
                }
                
                // Check for mergeable tiles
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const val = grid[y][x];
                        if (x < GRID_SIZE - 1 && grid[y][x + 1] === val) return true;
                        if (y < GRID_SIZE - 1 && grid[y + 1][x] === val) return true;
                    }
                }
                
                return false;
            }
            
            function endGame() {
                gameOver = true;
                document.removeEventListener('keydown', keyHandler);
                if (animationId) cancelAnimationFrame(animationId);
                
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 20);
                    
                    // Find highest tile
                    let maxTile = 0;
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            maxTile = Math.max(maxTile, grid[y][x]);
                        }
                    }
                    ctx.fillText('Best Tile: ' + maxTile, canvas.width/2, canvas.height/2 + 60);
                    
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 100);
                    
                    const restartHandler = (e) => {
                        e.stopPropagation();
                        canvas.removeEventListener('click', restartHandler);
                        initNumberMatch();
                    };
                    canvas.addEventListener('click', restartHandler);
                }, 100);
                
                checkQuests(12, {score: score});
            }
            
            function keyHandler(e) {
                if (gameOver) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        move('left');
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        move('right');
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        move('up');
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        move('down');
                        break;
                }
            }
            
            document.addEventListener('keydown', keyHandler);
            
            // Get tile color
            function getTileColor(value) {
                const colors = {
                    0: '#3a3a52',
                    2: '#eee4da',
                    4: '#ede0c8',
                    8: '#f2b179',
                    16: '#f59563',
                    32: '#f67c5f',
                    64: '#f65e3b',
                    128: '#edcf72',
                    256: '#edcc61',
                    512: '#edc850',
                    1024: '#edc53f',
                    2048: '#edc22e'
                };
                return colors[value] || '#3c3a32';
            }
            
            // Start with 2 tiles
            addRandomTile();
            addRandomTile();
            
            function gameLoop() {
                if (gameOver) return;
                
                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const posX = GRID_OFFSET_X + x * CELL_SIZE;
                        const posY = GRID_OFFSET_Y + y * CELL_SIZE;
                        const value = grid[y][x];
                        
                        // Cell background
                        ctx.fillStyle = getTileColor(value);
                        ctx.fillRect(posX, posY, CELL_SIZE - 10, CELL_SIZE - 10);
                        
                        // Number
                        if (value !== 0) {
                            ctx.fillStyle = value <= 4 ? '#776e65' : '#f9f6f2';
                            ctx.font = value >= 1000 ? 'bold 32px Arial' : 'bold 40px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(value, posX + (CELL_SIZE - 10) / 2, posY + (CELL_SIZE - 10) / 2);
                        }
                    }
                }
                
                // UI
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('Score: ' + score, 20, 40);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('Arrow keys or WASD to move', canvas.width/2, 90);
                
                animationId = requestAnimationFrame(gameLoop);
            }
            
            gameLoop();
        }

        // GAME 13: PATTERN MEMORY - Simon Says Style!
        function initPatternMemory() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const colors = [
                {name: 'red', color: '#ff4444', active: '#ff8888', x: 250, y: 150},
                {name: 'blue', color: '#4444ff', active: '#8888ff', x: 450, y: 150},
                {name: 'green', color: '#44ff44', active: '#88ff88', x: 250, y: 350},
                {name: 'yellow', color: '#ffff44', active: '#ffff88', x: 450, y: 350}
            ];
            
            let sequence = [];
            let playerSequence = [];
            let round = 1;
            let score = 0;
            let gameOver = false;
            let isPlaying = false;
            let canClick = false;
            let animationId = null;
            
            function addToSequence() {
                const randomIndex = Math.floor(Math.random() * colors.length);
                sequence.push(randomIndex);
            }
            
            async function playSequence() {
                isPlaying = true;
                canClick = false;
                playerSequence = [];
                
                // Wait a bit before starting
                await sleep(500);
                
                for (let i = 0; i < sequence.length; i++) {
                    const colorIndex = sequence[i];
                    
                    // Light up
                    colors[colorIndex].isActive = true;
                    render();
                    
                    // Play sound effect visually (pulse)
                    await sleep(400);
                    
                    // Turn off
                    colors[colorIndex].isActive = false;
                    render();
                    
                    await sleep(200);
                }
                
                isPlaying = false;
                canClick = true;
            }
            
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            function checkPattern() {
                // Check if player got it right
                for (let i = 0; i < playerSequence.length; i++) {
                    if (playerSequence[i] !== sequence[i]) {
                        // Wrong!
                        endGame();
                        return;
                    }
                }
                
                // Check if player completed the sequence
                if (playerSequence.length === sequence.length) {
                    // Correct! Next round
                    score += round * 10;
                    round++;
                    canClick = false;
                    
                    setTimeout(() => {
                        addToSequence();
                        playSequence();
                    }, 1000);
                }
            }
            
            function endGame() {
                gameOver = true;
                canClick = false;
                if (animationId) cancelAnimationFrame(animationId);
                
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText('Round: ' + round, canvas.width/2, canvas.height/2 + 10);
                    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 50);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 100);
                    
                    const restartHandler = (e) => {
                        e.stopPropagation();
                        canvas.removeEventListener('click', restartHandler);
                        initPatternMemory();
                    };
                    canvas.addEventListener('click', restartHandler);
                }, 100);
                
                checkQuests(13, {round: round, score: score});
            }
            
            function clickHandler(e) {
                if (!canClick || isPlaying || gameOver) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check which color was clicked
                for (let i = 0; i < colors.length; i++) {
                    const c = colors[i];
                    if (mouseX >= c.x && mouseX <= c.x + 150 &&
                        mouseY >= c.y && mouseY <= c.y + 150) {
                        
                        // Flash the color
                        c.isActive = true;
                        render();
                        
                        setTimeout(() => {
                            c.isActive = false;
                            render();
                        }, 200);
                        
                        playerSequence.push(i);
                        checkPattern();
                        break;
                    }
                }
            }
            
            canvas.addEventListener('click', clickHandler);
            
            function render() {
                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw color buttons
                for (let c of colors) {
                    ctx.fillStyle = c.isActive ? c.active : c.color;
                    ctx.shadowBlur = c.isActive ? 30 : 10;
                    ctx.shadowColor = c.color;
                    
                    ctx.fillRect(c.x, c.y, 150, 150);
                    ctx.shadowBlur = 0;
                }
                
                // UI
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Round: ' + round, canvas.width/2, 60);
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Score: ' + score, canvas.width/2, 95);
                
                if (isPlaying) {
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#ffff44';
                    ctx.fillText('üß† Watch and memorize...', canvas.width/2, canvas.height - 30);
                } else if (canClick) {
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('‚úã Your turn! Click the pattern', canvas.width/2, canvas.height - 30);
                }
            }
            
            // Start game
            addToSequence();
            render();
            playSequence();
        }

        // GAME 14: COLOR SORT - Ball Sorting Puzzle!
        function initColorSort() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const TUBE_WIDTH = 60;
            const TUBE_HEIGHT = 200;
            const BALL_SIZE = 50;
            const TUBE_COUNT = 5;
            const BALLS_PER_TUBE = 4;
            
            let tubes = [];
            let selectedTube = null;
            let moves = 0;
            let gameOver = false;
            let animationId = null;
            
            const ballColors = [
                '#ff4444', // red
                '#4444ff', // blue
                '#44ff44', // green
                '#ffff44', // yellow
            ];
            
            // Initialize tubes
            function initTubes() {
                tubes = [];
                
                // Create array of all balls
                let allBalls = [];
                for (let color of ballColors) {
                    for (let i = 0; i < BALLS_PER_TUBE; i++) {
                        allBalls.push(color);
                    }
                }
                
                // Shuffle balls
                for (let i = allBalls.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allBalls[i], allBalls[j]] = [allBalls[j], allBalls[i]];
                }
                
                // Fill first 4 tubes
                for (let i = 0; i < 4; i++) {
                    tubes.push({
                        balls: allBalls.slice(i * BALLS_PER_TUBE, (i + 1) * BALLS_PER_TUBE),
                        x: 100 + i * 150
                    });
                }
                
                // Add empty tube
                tubes.push({
                    balls: [],
                    x: 100 + 4 * 150
                });
            }
            
            function canMoveBall(fromTube, toTube) {
                // Can't move from empty tube
                if (fromTube.balls.length === 0) return false;
                
                // Can move to empty tube
                if (toTube.balls.length === 0) return true;
                
                // Can't move to full tube
                if (toTube.balls.length >= BALLS_PER_TUBE) return false;
                
                // Can only stack same colors
                const fromColor = fromTube.balls[fromTube.balls.length - 1];
                const toColor = toTube.balls[toTube.balls.length - 1];
                
                return fromColor === toColor;
            }
            
            function moveBall(fromTube, toTube) {
                if (!canMoveBall(fromTube, toTube)) return false;
                
                const ball = fromTube.balls.pop();
                toTube.balls.push(ball);
                moves++;
                
                checkWin();
                return true;
            }
            
            function checkWin() {
                // Check if all tubes are either empty or have 4 balls of same color
                for (let tube of tubes) {
                    if (tube.balls.length === 0) continue;
                    
                    if (tube.balls.length !== BALLS_PER_TUBE) return;
                    
                    const firstColor = tube.balls[0];
                    if (!tube.balls.every(ball => ball === firstColor)) return;
                }
                
                // Win!
                gameOver = true;
                if (animationId) cancelAnimationFrame(animationId);
                
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üéâ YOU WIN! üéâ', canvas.width/2, canvas.height/2 - 40);
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText('Moves: ' + moves, canvas.width/2, canvas.height/2 + 20);
                    
                    let rating = 'Perfect!';
                    if (moves > 30) rating = 'Good!';
                    if (moves > 50) rating = 'Not bad!';
                    
                    ctx.font = '28px Arial';
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText(rating, canvas.width/2, canvas.height/2 + 60);
                    
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 100);
                    
                    const restartHandler = (e) => {
                        e.stopPropagation();
                        canvas.removeEventListener('click', restartHandler);
                        initColorSort();
                    };
                    canvas.addEventListener('click', restartHandler);
                }, 500);
                
                checkQuests(14, {moves: moves});
            }
            
            function clickHandler(e) {
                if (gameOver) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check which tube was clicked
                for (let i = 0; i < tubes.length; i++) {
                    const tube = tubes[i];
                    const tubeY = 200;
                    
                    if (mouseX >= tube.x && mouseX <= tube.x + TUBE_WIDTH &&
                        mouseY >= tubeY && mouseY <= tubeY + TUBE_HEIGHT) {
                        
                        if (selectedTube === null) {
                            // Select this tube
                            if (tube.balls.length > 0) {
                                selectedTube = i;
                            }
                        } else {
                            // Try to move ball
                            if (selectedTube === i) {
                                // Deselect
                                selectedTube = null;
                            } else {
                                // Move ball
                                if (moveBall(tubes[selectedTube], tube)) {
                                    selectedTube = null;
                                }
                            }
                        }
                        break;
                    }
                }
            }
            
            canvas.addEventListener('click', clickHandler);
            
            function render() {
                if (gameOver) return;
                
                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw tubes
                for (let i = 0; i < tubes.length; i++) {
                    const tube = tubes[i];
                    const tubeY = 200;
                    
                    // Tube outline
                    ctx.strokeStyle = selectedTube === i ? '#ffff00' : '#666';
                    ctx.lineWidth = selectedTube === i ? 4 : 2;
                    ctx.strokeRect(tube.x, tubeY, TUBE_WIDTH, TUBE_HEIGHT);
                    
                    // Draw balls in tube (from bottom up)
                    for (let j = 0; j < tube.balls.length; j++) {
                        const ballY = tubeY + TUBE_HEIGHT - (j + 1) * (BALL_SIZE + 5);
                        
                        ctx.fillStyle = tube.balls[j];
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = tube.balls[j];
                        ctx.beginPath();
                        ctx.arc(tube.x + TUBE_WIDTH/2, ballY + BALL_SIZE/2, BALL_SIZE/2 - 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
                
                // UI
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üé® Color Sort', canvas.width/2, 50);
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Moves: ' + moves, canvas.width/2, 90);
                
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fillText('Click a tube to select, click another to move', canvas.width/2, 140);
                ctx.fillText('Sort all colors into separate tubes!', canvas.width/2, 165);
                
                animationId = requestAnimationFrame(render);
            }
            
            initTubes();
            render();
        }

        // GAME 15: TANK BATTLE - EXACTLY LIKE AWESOME TANKS!
        function initTankBattle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const TILE_SIZE = 40;
            
            // Tank types player can unlock
            const tankTypes = {
                default: {
                    name: 'Standard Tank',
                    unlocked: true,
                    cost: 0,
                    color: '#00ff88',
                    turretColor: '#00cc66',
                    speed: 2,
                    damage: 20,
                    fireRate: 500,
                    armor: 0,
                    health: 100,
                    description: 'Balanced tank for beginners'
                },
                speedy: {
                    name: 'Speed Tank',
                    unlocked: false,
                    cost: 300,
                    color: '#ffff00',
                    turretColor: '#cccc00',
                    speed: 3,
                    damage: 15,
                    fireRate: 400,
                    armor: 0,
                    health: 80,
                    description: 'Fast but fragile'
                },
                heavy: {
                    name: 'Heavy Tank',
                    unlocked: false,
                    cost: 500,
                    color: '#4444ff',
                    turretColor: '#3333cc',
                    speed: 1.5,
                    damage: 30,
                    fireRate: 700,
                    armor: 10,
                    health: 150,
                    description: 'Slow but powerful'
                },
                sniper: {
                    name: 'Sniper Tank',
                    unlocked: false,
                    cost: 400,
                    color: '#ff44ff',
                    turretColor: '#cc33cc',
                    speed: 2.2,
                    damage: 40,
                    fireRate: 1000,
                    armor: 0,
                    health: 90,
                    description: 'High damage, slow fire'
                },
                artillery: {
                    name: 'Artillery Tank',
                    unlocked: false,
                    cost: 600,
                    color: '#ff8800',
                    turretColor: '#cc6600',
                    speed: 1.8,
                    damage: 25,
                    fireRate: 600,
                    armor: 5,
                    health: 120,
                    description: 'Splash damage bullets'
                }
            };
            
            let currentTank = 'default';
            
            // Player tank with upgrades
            let player = {
                x: 100,
                y: 100,
                angle: 0,
                turretAngle: 0,
                vx: 0,
                vy: 0,
                speed: 2,
                maxSpeed: 2,
                health: 100,
                maxHealth: 100,
                armor: 0,
                damage: 20,
                fireRate: 500,
                bulletSpeed: 10,
                lastShot: 0,
                money: 0,
                size: 30,
                tankType: 'default',
                // Upgrade levels
                upgrades: {
                    damage: 0,      // 0-5
                    fireRate: 0,    // 0-5
                    armor: 0,       // 0-5
                    speed: 0,       // 0-5
                    health: 0       // 0-5
                }
            };
            
            function applyTankType(tankType) {
                const tank = tankTypes[tankType];
                player.tankType = tankType;
                currentTank = tankType;
                
                // Base stats from tank type
                player.speed = tank.speed + player.upgrades.speed * 0.4;
                player.maxSpeed = player.speed;
                player.damage = tank.damage + player.upgrades.damage * 10;
                player.fireRate = tank.fireRate - player.upgrades.fireRate * 50;
                player.armor = tank.armor + player.upgrades.armor * 5;
                player.maxHealth = tank.health + player.upgrades.health * 25;
                player.health = Math.min(player.health, player.maxHealth);
            }
            
            let walls = [];
            let enemies = [];
            let bullets = [];
            let particles = [];
            let explosions = [];
            let level = 1;
            let gameOver = false;
            let keys = {};
            let mouseX = 0, mouseY = 0;
            let animationId = null;
            let showShop = false;
            let missionComplete = false;
            
            // Mission objectives
            let mission = {
                enemiesKilled: 0,
                enemiesTarget: 5,
                basesDestroyed: 0,
                basesTarget: 2
            };
            
            // Generate level with Awesome Tanks style
            function generateLevel() {
                walls = [];
                enemies = [];
                missionComplete = false;
                
                // Border walls (indestructible)
                for (let x = 0; x < 20; x++) {
                    walls.push({x: x * TILE_SIZE, y: 0, destructible: false, health: 999});
                    walls.push({x: x * TILE_SIZE, y: 14 * TILE_SIZE, destructible: false, health: 999});
                }
                for (let y = 0; y < 15; y++) {
                    walls.push({x: 0, y: y * TILE_SIZE, destructible: false, health: 999});
                    walls.push({x: 19 * TILE_SIZE, y: y * TILE_SIZE, destructible: false, health: 999});
                }
                
                // Destructible walls - more walls each level
                const wallCount = 15 + level * 8;
                for (let i = 0; i < wallCount; i++) {
                    const x = Math.floor(Math.random() * 16 + 2) * TILE_SIZE;
                    const y = Math.floor(Math.random() * 11 + 2) * TILE_SIZE;
                    
                    if (Math.abs(x - player.x) > 120 && Math.abs(y - player.y) > 120) {
                        walls.push({x, y, destructible: true, health: 3 + Math.floor(level / 3)});
                    }
                }
                
                // Reset mission counters
                mission.enemiesKilled = 0;
                mission.basesDestroyed = 0;
                
                // Spawn enemy bases - more bases, tougher, spawn faster
                mission.basesTarget = 2 + Math.floor(level / 2);
                for (let i = 0; i < mission.basesTarget; i++) {
                    const x = Math.random() * (canvas.width - 300) + 150;
                    const y = Math.random() * (canvas.height - 300) + 150;
                    
                    if (Math.abs(x - player.x) > 250 && Math.abs(y - player.y) > 250) {
                        enemies.push({
                            type: 'base',
                            x, y,
                            health: 100 + level * 15,
                            maxHealth: 100 + level * 15,
                            size: 45,
                            color: '#cc0000',
                            spawnTimer: 0,
                            spawnRate: Math.max(120, 180 - level * 10), // Spawn faster each level
                            reward: 30
                        });
                    }
                }
                
                // Spawn MORE initial enemies each level
                const initialEnemies = Math.min(6 + level * 2, 25);
                spawnEnemies(initialEnemies);
                
                // Set target to ACTUAL enemies spawned
                mission.enemiesTarget = enemies.filter(e => e.type !== 'base').length;
            }
            
            function spawnEnemies(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * (canvas.width - 300) + 150;
                    const y = Math.random() * (canvas.height - 300) + 150;
                    
                    if (Math.abs(x - player.x) > 200) {
                        // Enemy variety - 4 types with MUCH harder scaling
                        const rand = Math.random();
                        let type, health, speed, damage, fireRate, size, color, reward;
                        
                        // Enemy distribution changes with level
                        const heavyChance = Math.min(0.3, 0.1 + level * 0.02);
                        const sniperChance = Math.min(0.25, 0.05 + level * 0.02);
                        
                        if (rand < 0.35) { // Basic (red) - less common at high levels
                            type = 'basic';
                            health = 40 + level * 8; // More HP scaling
                            speed = 1.2 + level * 0.05; // Gets faster
                            damage = 12 + level * 2; // More damage
                            fireRate = Math.max(1500, 2500 - level * 50); // Shoots faster
                            size = 28;
                            color = '#ff4444';
                            reward = 8;
                        } else if (rand < 0.35 + (0.3 - heavyChance - sniperChance)) { // Fast (orange)
                            type = 'fast';
                            health = 20 + level * 5;
                            speed = 2.5 + level * 0.08; // Gets very fast
                            damage = 8 + level * 1.5;
                            fireRate = Math.max(1000, 1500 - level * 40);
                            size = 22;
                            color = '#ffaa00';
                            reward = 6;
                        } else if (rand < 1 - sniperChance) { // Heavy (blue) - more common later
                            type = 'heavy';
                            health = 80 + level * 15; // Very tanky
                            speed = 0.8 + level * 0.03;
                            damage = 18 + level * 3; // High damage
                            fireRate = Math.max(2000, 3000 - level * 50);
                            size = 35;
                            color = '#4444ff';
                            reward = 15;
                        } else { // Sniper (purple) - more common later
                            type = 'sniper';
                            health = 30 + level * 6;
                            speed = 1.0 + level * 0.04;
                            damage = 25 + level * 4; // High damage scaling
                            fireRate = Math.max(2500, 3500 - level * 60);
                            size = 26;
                            color = '#aa44ff';
                            reward = 12;
                        }
                        
                        enemies.push({
                            type: type,
                            x, y,
                            angle: Math.random() * Math.PI * 2,
                            turretAngle: 0,
                            health: health,
                            maxHealth: health,
                            speed: speed,
                            damage: damage,
                            fireRate: fireRate,
                            lastShot: 0,
                            size: size,
                            color: color,
                            reward: reward,
                            alertRange: type === 'sniper' ? 450 : 350,
                            shootRange: type === 'sniper' ? 400 : type === 'heavy' ? 250 : 280
                        });
                    }
                }
            }
            
            // Mouse tracking for turret aiming
            function mouseMoveHandler(e) {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            }
            
            function keyDownHandler(e) {
                keys[e.key] = true;
            }
            
            function keyUpHandler(e) {
                keys[e.key] = false;
            }
            
            function mouseDownHandler(e) {
                if (!gameOver && !showShop && e.button === 0) {
                    shoot();
                }
            }
            
            canvas.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);
            canvas.addEventListener('mousedown', mouseDownHandler);
            
            function shoot() {
                const now = Date.now();
                if (now - player.lastShot < player.fireRate) return;
                player.lastShot = now;
                
                bullets.push({
                    x: player.x + Math.cos(player.turretAngle) * 25,
                    y: player.y + Math.sin(player.turretAngle) * 25,
                    vx: Math.cos(player.turretAngle) * player.bulletSpeed,
                    vy: Math.sin(player.turretAngle) * player.bulletSpeed,
                    damage: player.damage,
                    owner: 'player',
                    size: 6,
                    color: '#ffff00'
                });
            }
            
            function createExplosion(x, y, size) {
                explosions.push({x, y, radius: 5, maxRadius: size, life: 20});
                
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 30,
                        color: ['#ff4444', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                        size: Math.random() * 5 + 2
                    });
                }
            }
            
            function checkCollision(obj1, obj2, size1, size2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx*dx + dy*dy) < size1 + size2;
            }
            
            function canMoveTo(x, y, size) {
                for (let wall of walls) {
                    if (Math.abs(x - wall.x) < TILE_SIZE/2 + size/2 &&
                        Math.abs(y - wall.y) < TILE_SIZE/2 + size/2) {
                        return false;
                    }
                }
                return true;
            }
            
            function openShop() {
                showShop = true;
            }
            
            function closeShop() {
                showShop = false;
            }
            
            function buyUpgrade(type) {
                const costs = {
                    damage: [50, 100, 200, 400, 800],
                    fireRate: [50, 100, 200, 400, 800],
                    armor: [75, 150, 300, 600, 1200],
                    speed: [40, 80, 160, 320, 640],
                    health: [60, 120, 240, 480, 960]
                };
                
                const lv = player.upgrades[type];
                if (lv >= 5) return;
                
                const cost = costs[type][lv];
                if (player.money < cost) return;
                
                player.money -= cost;
                player.upgrades[type]++;
                
                switch(type) {
                    case 'damage':
                        player.damage = 20 + player.upgrades.damage * 10;
                        break;
                    case 'fireRate':
                        player.fireRate = 500 - player.upgrades.fireRate * 50;
                        break;
                    case 'armor':
                        player.armor = player.upgrades.armor * 5;
                        break;
                    case 'speed':
                        player.speed = 2 + player.upgrades.speed * 0.4;
                        player.maxSpeed = player.speed;
                        break;
                    case 'health':
                        const oldMax = player.maxHealth;
                        player.maxHealth = 100 + player.upgrades.health * 25;
                        player.health += (player.maxHealth - oldMax);
                        break;
                }
            }
            
            function clickHandler(e) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                // Mission complete buttons
                if (missionComplete && !showShop) {
                    const btnY = canvas.height/2 + 60;
                    
                    // Continue button
                    if (mx > canvas.width/2 - 220 && mx < canvas.width/2 - 20 && 
                        my > btnY && my < btnY + 60) {
                        missionComplete = false;
                        generateLevel();
                        return;
                    }
                    
                    // Shop button
                    if (mx > canvas.width/2 + 20 && mx < canvas.width/2 + 220 && 
                        my > btnY && my < btnY + 60) {
                        showShop = true;
                        return;
                    }
                }
                
                if (!showShop) return;
                
                // Close shop button
                if (mx > canvas.width - 120 && mx < canvas.width - 20 && my > 20 && my < 60) {
                    closeShop();
                    return;
                }
                
                // Tank selection buttons
                const tankNames = Object.keys(tankTypes);
                for (let i = 0; i < tankNames.length; i++) {
                    const tankName = tankNames[i];
                    const tank = tankTypes[tankName];
                    const btnX = 20 + (i % 3) * 260;
                    const btnY = 120 + Math.floor(i / 3) * 90;
                    
                    if (mx > btnX && mx < btnX + 250 && my > btnY && my < btnY + 80) {
                        if (!tank.unlocked && player.money >= tank.cost) {
                            player.money -= tank.cost;
                            tank.unlocked = true;
                            applyTankType(tankName);
                        } else if (tank.unlocked) {
                            applyTankType(tankName);
                        }
                        return;
                    }
                }
                
                // Upgrade buttons
                const types = ['damage', 'fireRate', 'armor', 'speed', 'health'];
                const startY = 120 + Math.ceil(tankNames.length / 3) * 90 + 40;
                
                for (let i = 0; i < types.length; i++) {
                    const btnX = canvas.width/2 - 180;
                    const btnY = startY + i * 80;
                    
                    if (mx > btnX && mx < btnX + 360 && my > btnY && my < btnY + 60) {
                        buyUpgrade(types[i]);
                    }
                }
            }
            
            canvas.addEventListener('click', clickHandler);
            
            function endGame() {
                gameOver = true;
                canvas.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('keydown', keyDownHandler);
                document.removeEventListener('keyup', keyUpHandler);
                canvas.removeEventListener('mousedown', mouseDownHandler);
                canvas.removeEventListener('click', clickHandler);
                if (animationId) cancelAnimationFrame(animationId);
                
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,0,0,0.9)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 60);
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText('Level: ' + level, canvas.width/2, canvas.height/2 - 10);
                    ctx.fillText('Money: $' + player.money, canvas.width/2, canvas.height/2 + 30);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 80);
                    
                    const restartHandler = (e) => {
                        e.stopPropagation();
                        canvas.removeEventListener('click', restartHandler);
                        initTankBattle();
                    };
                    canvas.addEventListener('click', restartHandler);
                }, 100);
                
                checkQuests(15, {level: level, money: player.money});
            }
            
            function gameLoop() {
                if (gameOver) return;
                
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#3a5f3a');
                gradient.addColorStop(1, '#2d4a2d');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                ctx.lineWidth = 1;
                for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += TILE_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                if (!showShop) {
                    let moveX = 0, moveY = 0;
                    if (keys['w'] || keys['W'] || keys['ArrowUp']) moveY = -1;
                    if (keys['s'] || keys['S'] || keys['ArrowDown']) moveY = 1;
                    if (keys['a'] || keys['A'] || keys['ArrowLeft']) moveX = -1;
                    if (keys['d'] || keys['D'] || keys['ArrowRight']) moveX = 1;
                    
                    if (moveX !== 0 || moveY !== 0) {
                        const length = Math.sqrt(moveX*moveX + moveY*moveY);
                        player.vx += (moveX / length) * player.speed * 0.3;
                        player.vy += (moveY / length) * player.speed * 0.3;
                        player.angle = Math.atan2(moveY, moveX);
                    }
                    
                    player.vx *= 0.85;
                    player.vy *= 0.85;
                    
                    const speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
                    if (speed > player.maxSpeed) {
                        player.vx = (player.vx / speed) * player.maxSpeed;
                        player.vy = (player.vy / speed) * player.maxSpeed;
                    }
                    
                    const newX = player.x + player.vx;
                    const newY = player.y + player.vy;
                    
                    if (canMoveTo(newX, player.y, player.size)) {
                        player.x = newX;
                    } else {
                        player.vx = 0;
                    }
                    
                    if (canMoveTo(player.x, newY, player.size)) {
                        player.y = newY;
                    } else {
                        player.vy = 0;
                    }
                    
                    player.turretAngle = Math.atan2(mouseY - player.y, mouseX - player.x);
                    
                    if (keys['u'] || keys['U']) {
                        openShop();
                        keys['u'] = keys['U'] = false;
                    }
                }
                
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    
                    if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                        bullets.splice(i, 1);
                        continue;
                    }
                    
                    for (let j = walls.length - 1; j >= 0; j--) {
                        const wall = walls[j];
                        if (Math.abs(bullet.x - wall.x) < TILE_SIZE/2 && Math.abs(bullet.y - wall.y) < TILE_SIZE/2) {
                            if (wall.destructible && bullet.owner === 'player') {
                                wall.health--;
                                if (wall.health <= 0) {
                                    walls.splice(j, 1);
                                    createExplosion(wall.x, wall.y, 25);
                                }
                            }
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                    
                    if (i < 0 || i >= bullets.length) continue;
                    
                    if (bullet.owner === 'player') {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            if (checkCollision(bullet, enemies[j], bullet.size, enemies[j].size)) {
                                enemies[j].health -= bullet.damage;
                                bullets.splice(i, 1);
                                
                                if (enemies[j].health <= 0) {
                                    createExplosion(enemies[j].x, enemies[j].y, enemies[j].size + 10);
                                    player.money += enemies[j].reward;
                                    
                                    if (enemies[j].type === 'base') {
                                        mission.basesDestroyed++;
                                    } else if (enemies[j].type !== 'base') {
                                        mission.enemiesKilled++;
                                    }
                                    
                                    enemies.splice(j, 1);
                                }
                                break;
                            }
                        }
                    } else {
                        if (checkCollision(bullet, player, bullet.size, player.size)) {
                            const actualDamage = Math.max(1, bullet.damage - player.armor);
                            player.health -= actualDamage;
                            bullets.splice(i, 1);
                            createExplosion(player.x, player.y, 20);
                            
                            if (player.health <= 0) {
                                endGame();
                                return;
                            }
                        }
                    }
                }
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    
                    if (enemy.type === 'base') {
                        enemy.spawnTimer++;
                        if (enemy.spawnTimer > enemy.spawnRate && enemies.filter(e => e.type !== 'base').length < 20) {
                            enemy.spawnTimer = 0;
                            const beforeCount = enemies.filter(e => e.type !== 'base').length;
                            spawnEnemies(1);
                            const afterCount = enemies.filter(e => e.type !== 'base').length;
                            mission.enemiesTarget += (afterCount - beforeCount); // Increase target for spawned enemies
                        }
                        continue;
                    }
                    
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    enemy.turretAngle = Math.atan2(dy, dx);
                    
                    if (dist < enemy.alertRange && dist > enemy.shootRange - 50) {
                        const newX = enemy.x + (dx / dist) * enemy.speed;
                        const newY = enemy.y + (dy / dist) * enemy.speed;
                        
                        if (canMoveTo(newX, newY, enemy.size)) {
                            enemy.x = newX;
                            enemy.y = newY;
                            enemy.angle = Math.atan2(dy, dx);
                        }
                    }
                    
                    const now = Date.now();
                    if (now - enemy.lastShot > enemy.fireRate && dist < enemy.shootRange) {
                        enemy.lastShot = now;
                        bullets.push({
                            x: enemy.x + Math.cos(enemy.turretAngle) * 20,
                            y: enemy.y + Math.sin(enemy.turretAngle) * 20,
                            vx: Math.cos(enemy.turretAngle) * 7,
                            vy: Math.sin(enemy.turretAngle) * 7,
                            damage: enemy.damage,
                            owner: 'enemy',
                            size: 5,
                            color: '#ff4444'
                        });
                    }
                }
                
                // Check mission complete - either reached targets OR killed all enemies and bases
                const allBasesDestroyed = mission.basesDestroyed >= mission.basesTarget;
                const allEnemiesKilled = mission.enemiesKilled >= mission.enemiesTarget;
                const noEnemiesLeft = enemies.filter(e => e.type !== 'base').length === 0;
                const noBasesLeft = enemies.filter(e => e.type === 'base').length === 0;
                
                if (!missionComplete && ((allBasesDestroyed && allEnemiesKilled) || (noBasesLeft && noEnemiesLeft))) {
                    missionComplete = true;
                    level++;
                    // Less healing each level - only 30 HP (was 50)
                    player.health = Math.min(player.maxHealth, player.health + 30);
                    // Less money bonus - only 30 (was 50)
                    player.money += 30;
                    
                    // Don't auto-open shop or generate level - wait for player
                }
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].x += particles[i].vx;
                    particles[i].y += particles[i].vy;
                    particles[i].vy += 0.3;
                    particles[i].life--;
                    if (particles[i].life <= 0) particles.splice(i, 1);
                }
                
                for (let i = explosions.length - 1; i >= 0; i--) {
                    explosions[i].radius += 2;
                    explosions[i].life--;
                    if (explosions[i].life <= 0) explosions.splice(i, 1);
                }
                
                walls.forEach(wall => {
                    ctx.fillStyle = wall.destructible ? '#8B7355' : '#444';
                    ctx.fillRect(wall.x - TILE_SIZE/2, wall.y - TILE_SIZE/2, TILE_SIZE, TILE_SIZE);
                    
                    if (wall.destructible) {
                        ctx.strokeStyle = wall.health === 1 ? '#ff4444' : 'rgba(0,0,0,0.3)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(wall.x - TILE_SIZE/2, wall.y - TILE_SIZE/2, TILE_SIZE, TILE_SIZE);
                    }
                });
                
                enemies.forEach(enemy => {
                    if (enemy.type === 'base') {
                        ctx.fillStyle = enemy.color;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff0000';
                        ctx.fillRect(enemy.x - enemy.size/2, enemy.y - enemy.size/2, enemy.size, enemy.size);
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        ctx.rotate(enemy.angle);
                        ctx.fillStyle = enemy.color;
                        ctx.fillRect(-enemy.size/2, -enemy.size/2, enemy.size, enemy.size);
                        ctx.restore();
                        
                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        ctx.rotate(enemy.turretAngle);
                        ctx.fillStyle = '#aa0000';
                        ctx.fillRect(0, -5, 18, 10);
                        ctx.restore();
                    }
                    
                    const barWidth = enemy.size * 1.5;
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size/2 - 12, barWidth, 5);
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size/2 - 12, barWidth * (enemy.health / enemy.maxHealth), 5);
                });
                
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.angle);
                ctx.fillStyle = tankTypes[currentTank].color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = tankTypes[currentTank].color;
                ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
                ctx.shadowBlur = 0;
                ctx.restore();
                
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.turretAngle);
                ctx.fillStyle = tankTypes[currentTank].turretColor;
                ctx.fillRect(0, -7, 28, 14);
                ctx.restore();
                
                bullets.forEach(bullet => {
                    ctx.fillStyle = bullet.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = bullet.color;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
                
                particles.forEach(p => {
                    ctx.globalAlpha = p.life / 30;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                });
                ctx.globalAlpha = 1;
                
                explosions.forEach(exp => {
                    ctx.globalAlpha = exp.life / 20;
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
                
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(10, 10, 280, 120);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Level: ' + level, 20, 35);
                ctx.fillText('Money: $' + player.money, 20, 60);
                
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(20, 75, 250, 20);
                const healthPercent = player.health / player.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.25 ? '#ffff00' : '#ff4444';
                ctx.fillRect(20, 75, 250 * healthPercent, 20);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(20, 75, 250, 20);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.floor(player.health) + ' / ' + player.maxHealth, 145, 90);
                
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Armor: ' + player.armor, 20, 115);
                
                // Mission UI - Dynamic width based on content
                const missionText1 = 'Enemies: ' + mission.enemiesKilled + '/' + mission.enemiesTarget;
                const missionText2 = 'Bases: ' + mission.basesDestroyed + '/' + mission.basesTarget;
                ctx.font = '14px Arial';
                const text1Width = ctx.measureText(missionText1).width;
                const text2Width = ctx.measureText(missionText2).width;
                const maxTextWidth = Math.max(text1Width, text2Width, 100);
                const boxWidth = maxTextWidth + 40;
                
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(canvas.width - boxWidth - 10, 10, boxWidth, 90);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('MISSION:', canvas.width - boxWidth, 30);
                ctx.font = '14px Arial';
                const enemyColor = mission.enemiesKilled >= mission.enemiesTarget ? '#00ff88' : 'white';
                ctx.fillStyle = enemyColor;
                ctx.fillText(missionText1, canvas.width - boxWidth, 55);
                const baseColor = mission.basesDestroyed >= mission.basesTarget ? '#00ff88' : 'white';
                ctx.fillStyle = baseColor;
                ctx.fillText(missionText2, canvas.width - boxWidth, 78);
                
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(canvas.width - 150, canvas.height - 60, 130, 40);
                ctx.fillStyle = 'black';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SHOP (U)', canvas.width - 85, canvas.height - 33);
                
                if (missionComplete && !showShop) {
                    ctx.fillStyle = 'rgba(0,0,0,0.85)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#00ff88';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('MISSION COMPLETE!', canvas.width/2, canvas.height/2 - 80);
                    ctx.font = '28px Arial';
                    ctx.fillStyle = 'white';
                    ctx.fillText('Level ' + level, canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '24px Arial';
                    ctx.fillText('Bonus: $30 | +30 HP', canvas.width/2, canvas.height/2 + 10);
                    
                    // Continue button
                    ctx.fillStyle = '#00ff88';
                    ctx.fillRect(canvas.width/2 - 220, canvas.height/2 + 60, 200, 60);
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('CONTINUE', canvas.width/2 - 120, canvas.height/2 + 98);
                    
                    // Shop button
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(canvas.width/2 + 20, canvas.height/2 + 60, 200, 60);
                    ctx.fillStyle = 'black';
                    ctx.fillText('SHOP', canvas.width/2 + 120, canvas.height/2 + 98);
                }
                
                if (showShop) {
                    ctx.fillStyle = 'rgba(0,0,0,0.95)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 36px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('SHOP & UPGRADES', canvas.width/2, 50);
                    ctx.font = '20px Arial';
                    ctx.fillText('Money: $' + player.money, canvas.width/2, 85);
                    
                    // Tank selection section
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillText('üéñÔ∏è SELECT TANK:', 20, 120);
                    
                    const tankNames = Object.keys(tankTypes);
                    tankNames.forEach((tankName, i) => {
                        const tank = tankTypes[tankName];
                        const btnX = 20 + (i % 3) * 260;
                        const btnY = 130 + Math.floor(i / 3) * 90;
                        const isSelected = currentTank === tankName;
                        const canAfford = player.money >= tank.cost;
                        
                        // Tank card
                        if (isSelected) {
                            ctx.fillStyle = 'rgba(0,255,136,0.3)';
                        } else if (tank.unlocked) {
                            ctx.fillStyle = 'rgba(100,100,100,0.3)';
                        } else if (canAfford) {
                            ctx.fillStyle = 'rgba(255,170,0,0.2)';
                        } else {
                            ctx.fillStyle = 'rgba(50,50,50,0.5)';
                        }
                        ctx.fillRect(btnX, btnY, 250, 80);
                        
                        ctx.strokeStyle = isSelected ? '#00ff88' : (tank.unlocked ? 'white' : (canAfford ? '#ffaa00' : '#444'));
                        ctx.lineWidth = isSelected ? 3 : 2;
                        ctx.strokeRect(btnX, btnY, 250, 80);
                        
                        // Tank preview (colored square)
                        ctx.fillStyle = tank.color;
                        ctx.fillRect(btnX + 10, btnY + 15, 50, 50);
                        
                        // Tank name
                        ctx.fillStyle = tank.unlocked || canAfford ? 'white' : '#666';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(tank.name, btnX + 70, btnY + 25);
                        
                        // Tank stats
                        ctx.font = '11px Arial';
                        ctx.fillText('SPD:' + tank.speed + ' DMG:' + tank.damage, btnX + 70, btnY + 45);
                        ctx.fillText('HP:' + tank.health + ' ARM:' + tank.armor, btnX + 70, btnY + 60);
                        
                        // Status
                        if (isSelected) {
                            ctx.fillStyle = '#00ff88';
                            ctx.font = 'bold 12px Arial';
                            ctx.fillText('ACTIVE', btnX + 180, btnY + 45);
                        } else if (tank.unlocked) {
                            ctx.fillStyle = '#aaa';
                            ctx.font = '12px Arial';
                            ctx.fillText('Click to use', btnX + 165, btnY + 45);
                        } else {
                            ctx.fillStyle = canAfford ? '#ffff00' : '#666';
                            ctx.font = 'bold 14px Arial';
                            ctx.fillText('$' + tank.cost, btnX + 190, btnY + 45);
                        }
                    });
                    
                    // Upgrades section
                    const upgradesStartY = 130 + Math.ceil(tankNames.length / 3) * 90 + 20;
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = '#4444ff';
                    ctx.fillText('‚ö° UPGRADES:', 20, upgradesStartY + 20);
                    
                    const upgrades = [
                        {type: 'damage', name: 'Damage', desc: 'Increase bullet damage'},
                        {type: 'fireRate', name: 'Fire Rate', desc: 'Shoot faster'},
                        {type: 'armor', name: 'Armor', desc: 'Reduce damage taken'},
                        {type: 'speed', name: 'Speed', desc: 'Move faster'},
                        {type: 'health', name: 'Max Health', desc: 'Increase health pool'}
                    ];
                    
                    const costs = {
                        damage: [50, 100, 200, 400, 800],
                        fireRate: [50, 100, 200, 400, 800],
                        armor: [75, 150, 300, 600, 1200],
                        speed: [40, 80, 160, 320, 640],
                        health: [60, 120, 240, 480, 960]
                    };
                    
                    upgrades.forEach((upgrade, i) => {
                        const btnX = canvas.width/2 - 180;
                        const btnY = upgradesStartY + 40 + i * 80;
                        const lv = player.upgrades[upgrade.type];
                        const maxed = lv >= 5;
                        const cost = maxed ? 0 : costs[upgrade.type][lv];
                        const canAfford = player.money >= cost && !maxed;
                        
                        ctx.fillStyle = canAfford ? 'rgba(0,255,136,0.2)' : 'rgba(50,50,50,0.8)';
                        ctx.fillRect(btnX, btnY, 360, 60);
                        
                        ctx.strokeStyle = canAfford ? '#00ff88' : '#666';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(btnX, btnY, 360, 60);
                        
                        ctx.fillStyle = canAfford ? 'white' : '#888';
                        ctx.font = 'bold 18px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(upgrade.name, btnX + 15, btnY + 25);
                        ctx.font = '14px Arial';
                        ctx.fillText(upgrade.desc, btnX + 15, btnY + 45);
                        
                        ctx.textAlign = 'right';
                        ctx.fillText('Level: ' + lv + '/5', btnX + 345, btnY + 25);
                        
                        if (!maxed) {
                            ctx.fillStyle = canAfford ? '#ffff00' : '#666';
                            ctx.font = 'bold 16px Arial';
                            ctx.fillText('$' + cost, btnX + 345, btnY + 50);
                        } else {
                            ctx.fillStyle = '#00ff88';
                            ctx.font = 'bold 16px Arial';
                            ctx.fillText('MAX', btnX + 345, btnY + 50);
                        }
                    });
                    
                    // Close button
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(canvas.width - 120, 20, 100, 40);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('CLOSE', canvas.width - 70, 45);
                }
                
                if (!showShop) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.textAlign = 'center';
                    ctx.fillText('WASD: Move | Mouse: Aim | Click: Shoot | U: Shop', canvas.width/2, canvas.height - 10);
                }
                
                animationId = requestAnimationFrame(gameLoop);
            }
            
            generateLevel();
            gameLoop();
        }

        // GAME 16: TOWER DEFENSE - Like Blooket TD2 with LOTS of towers!
        function initTowerDefense() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const LANES = 3;
            const LANE_HEIGHT = 150;
            const LANE_Y_START = 100;
            
            let towers = [];
            let enemies = [];
            let projectiles = [];
            let particles = [];
            let gold = 100; // Start with less money
            let lives = 25;
            let wave = 1;
            let waveInProgress = false;
            let enemiesSpawned = 0;
            let enemiesPerWave = 0;
            let lastSpawn = 0;
            let gameOver = false;
            let selectedTowerType = null;
            let selectedTowerForUpgrade = null;
            let animationId = null;
            
            // 10+ Tower types with emojis (like Blooket TD2)
            const towerTypes = {
                dart: {
                    name: 'Dart',
                    cost: 30,
                    damage: 3,
                    range: 120,
                    fireRate: 800,
                    emoji: 'üéØ',
                    color: '#4499ff',
                    description: 'Basic tower',
                    upgrades: [
                        {cost: 40, damage: 5, range: 140, fireRate: 700, name: 'Sharp Darts'},
                        {cost: 80, damage: 8, range: 160, fireRate: 600, name: 'Triple Darts', multishot: 3},
                        {cost: 150, damage: 12, range: 180, fireRate: 500, name: 'Plasma Darts', multishot: 3}
                    ]
                },
                tack: {
                    name: 'Tack',
                    cost: 40,
                    damage: 2,
                    range: 80,
                    fireRate: 600,
                    emoji: 'üìå',
                    multishot: 8,
                    color: '#ff9944',
                    description: 'Shoots 8 tacks',
                    upgrades: [
                        {cost: 50, damage: 3, range: 100, fireRate: 500, multishot: 8, name: 'Faster Tacks'},
                        {cost: 100, damage: 5, range: 120, fireRate: 400, multishot: 10, name: 'More Tacks'},
                        {cost: 200, damage: 8, range: 140, fireRate: 300, multishot: 12, name: 'Blade Shooter'}
                    ]
                },
                ice: {
                    name: 'Ice',
                    cost: 60,
                    damage: 1,
                    range: 100,
                    fireRate: 1200,
                    emoji: '‚ùÑÔ∏è',
                    slow: 0.4,
                    slowDuration: 2000,
                    color: '#44ffff',
                    description: 'Slows enemies',
                    upgrades: [
                        {cost: 70, damage: 2, range: 120, fireRate: 1000, slow: 0.5, slowDuration: 2500, name: 'Cold Snap'},
                        {cost: 140, damage: 3, range: 150, fireRate: 800, slow: 0.6, slowDuration: 3000, name: 'Deep Freeze'},
                        {cost: 250, damage: 5, range: 180, fireRate: 600, slow: 0.7, slowDuration: 4000, name: 'Arctic Wind'}
                    ]
                },
                bomb: {
                    name: 'Bomb',
                    cost: 90,
                    damage: 12,
                    range: 110,
                    fireRate: 1800,
                    emoji: 'üí£',
                    splash: 50,
                    color: '#ff4444',
                    description: 'Splash damage',
                    upgrades: [
                        {cost: 100, damage: 18, range: 130, fireRate: 1600, splash: 60, name: 'Bigger Bombs'},
                        {cost: 200, damage: 25, range: 150, fireRate: 1400, splash: 75, name: 'Cluster Bomb'},
                        {cost: 350, damage: 40, range: 170, fireRate: 1200, splash: 100, name: 'MOAB Mauler'}
                    ]
                },
                sniper: {
                    name: 'Sniper',
                    cost: 70,
                    damage: 15,
                    range: 250,
                    fireRate: 2500,
                    emoji: 'üéØ',
                    color: '#ff44ff',
                    description: 'Long range',
                    upgrades: [
                        {cost: 80, damage: 25, range: 300, fireRate: 2200, name: 'Full Metal'},
                        {cost: 160, damage: 40, range: 350, fireRate: 2000, name: 'Deadly Precision'},
                        {cost: 300, damage: 70, range: 999, fireRate: 1800, name: 'Elite Sniper'}
                    ]
                },
                wizard: {
                    name: 'Wizard',
                    cost: 100,
                    damage: 8,
                    range: 130,
                    fireRate: 1000,
                    emoji: 'üßô',
                    pierce: 3,
                    color: '#9944ff',
                    description: 'Pierce 3 enemies',
                    upgrades: [
                        {cost: 120, damage: 12, range: 150, fireRate: 900, pierce: 4, name: 'Fireball'},
                        {cost: 240, damage: 18, range: 170, fireRate: 800, pierce: 6, name: 'Lightning Bolt'},
                        {cost: 400, damage: 30, range: 200, fireRate: 700, pierce: 10, name: 'Archmage'}
                    ]
                },
                super: {
                    name: 'Super',
                    cost: 200,
                    damage: 20,
                    range: 150,
                    fireRate: 400,
                    emoji: '‚≠ê',
                    color: '#ffff44',
                    description: 'Fast & powerful',
                    upgrades: [
                        {cost: 250, damage: 30, range: 170, fireRate: 350, name: 'Laser Vision'},
                        {cost: 500, damage: 45, range: 200, fireRate: 300, name: 'Plasma Blasts'},
                        {cost: 800, damage: 70, range: 250, fireRate: 250, name: 'Sun God'}
                    ]
                },
                ninja: {
                    name: 'Ninja',
                    cost: 80,
                    damage: 5,
                    range: 140,
                    fireRate: 500,
                    emoji: 'ü•∑',
                    color: '#444444',
                    description: 'Fast attacks',
                    upgrades: [
                        {cost: 90, damage: 8, range: 160, fireRate: 450, name: 'Sharp Shurikens'},
                        {cost: 180, damage: 12, range: 180, fireRate: 400, multishot: 2, name: 'Double Shot'},
                        {cost: 320, damage: 20, range: 200, fireRate: 350, multishot: 3, name: 'Grandmaster'}
                    ]
                },
                farm: {
                    name: 'Farm',
                    cost: 120,
                    damage: 0,
                    range: 0,
                    fireRate: 99999,
                    emoji: 'üåæ',
                    income: 3,
                    color: '#44ff44',
                    description: '+$3 per wave',
                    upgrades: [
                        {cost: 100, income: 5, name: 'Bigger Farm'},
                        {cost: 200, income: 8, name: 'Mega Farm'},
                        {cost: 400, income: 15, name: 'Factory'}
                    ]
                },
                spike: {
                    name: 'Spike',
                    cost: 50,
                    damage: 20,
                    range: 30,
                    fireRate: 99999,
                    emoji: 'üî±',
                    color: '#888888',
                    trap: true,
                    uses: 5,
                    description: 'Trap on path',
                    upgrades: [
                        {cost: 40, damage: 30, uses: 8, name: 'Sharper Spikes'},
                        {cost: 80, damage: 50, uses: 12, name: 'Mega Spikes'},
                        {cost: 160, damage: 80, uses: 20, name: 'Spike Storm'}
                    ]
                },
                glue: {
                    name: 'Glue',
                    cost: 55,
                    damage: 0,
                    range: 100,
                    fireRate: 1500,
                    emoji: 'ü´ß',
                    slow: 0.3,
                    slowDuration: 3000,
                    color: '#ff99ff',
                    description: 'Strong slow',
                    upgrades: [
                        {cost: 60, range: 120, fireRate: 1300, slow: 0.4, slowDuration: 3500, name: 'Sticky Glue'},
                        {cost: 120, range: 140, fireRate: 1100, slow: 0.5, slowDuration: 4000, name: 'Super Glue'},
                        {cost: 240, range: 170, fireRate: 900, slow: 0.6, slowDuration: 5000, name: 'Glue Storm'}
                    ]
                },
                laser: {
                    name: 'Laser',
                    cost: 150,
                    damage: 6,
                    range: 180,
                    fireRate: 200,
                    emoji: 'üîÜ',
                    color: '#ffaa00',
                    description: 'Very fast fire',
                    upgrades: [
                        {cost: 180, damage: 10, range: 200, fireRate: 180, name: 'Powerful Laser'},
                        {cost: 360, damage: 15, range: 220, fireRate: 160, pierce: 2, name: 'Plasma Laser'},
                        {cost: 600, damage: 25, range: 250, fireRate: 140, pierce: 4, name: 'Ray of Doom'}
                    ]
                }
            };
            
            // Enemy types with emojis
            const enemyTypes = {
                basic: {
                    health: 5,
                    speed: 1.2,
                    reward: 2,
                    emoji: 'üî¥',
                    size: 15
                },
                fast: {
                    health: 3,
                    speed: 2.0,
                    reward: 3,
                    emoji: 'üü°',
                    size: 12
                },
                strong: {
                    health: 15,
                    speed: 0.8,
                    reward: 5,
                    emoji: 'üîµ',
                    size: 20
                },
                armored: {
                    health: 30,
                    speed: 0.6,
                    reward: 8,
                    emoji: '‚ö´',
                    size: 22
                },
                boss: {
                    health: 100,
                    speed: 0.4,
                    reward: 20,
                    emoji: 'üëë',
                    size: 30
                }
            };
            
            function getWaveComposition(waveNum) {
                // Progressive difficulty
                if (waveNum === 1) return {basic: 8, fast: 0, strong: 0, armored: 0, boss: 0};
                if (waveNum === 2) return {basic: 12, fast: 3, strong: 0, armored: 0, boss: 0};
                if (waveNum === 3) return {basic: 15, fast: 5, strong: 2, armored: 0, boss: 0};
                if (waveNum === 4) return {basic: 18, fast: 8, strong: 4, armored: 0, boss: 0};
                if (waveNum === 5) return {basic: 10, fast: 10, strong: 5, armored: 2, boss: 1};
                if (waveNum <= 10) {
                    return {
                        basic: 15 + waveNum * 3,
                        fast: 5 + waveNum * 2,
                        strong: 3 + waveNum,
                        armored: Math.floor(waveNum / 2),
                        boss: waveNum % 5 === 0 ? 2 : 0
                    };
                }
                return {
                    basic: 30 + waveNum * 4,
                    fast: 15 + waveNum * 3,
                    strong: 10 + waveNum * 2,
                    armored: 5 + waveNum,
                    boss: waveNum % 5 === 0 ? 3 : 1
                };
            }
            
            function startWave() {
                waveInProgress = true;
                enemiesSpawned = 0;
                lastSpawn = 0;
                
                const composition = getWaveComposition(wave);
                enemiesPerWave = composition.basic + composition.fast + composition.strong + 
                                 composition.armored + composition.boss;
            }
            
            function spawnEnemy() {
                const now = Date.now();
                if (now - lastSpawn < 800) return;
                if (enemiesSpawned >= enemiesPerWave) return;
                
                lastSpawn = now;
                enemiesSpawned++;
                
                const composition = getWaveComposition(wave);
                const total = enemiesPerWave;
                const basicCount = composition.basic;
                const fastCount = composition.fast;
                const strongCount = composition.strong;
                const armoredCount = composition.armored;
                
                let type = 'basic';
                if (enemiesSpawned > basicCount + fastCount + strongCount + armoredCount) {
                    type = 'boss';
                } else if (enemiesSpawned > basicCount + fastCount + strongCount) {
                    type = 'armored';
                } else if (enemiesSpawned > basicCount + fastCount) {
                    type = 'strong';
                } else if (enemiesSpawned > basicCount) {
                    type = 'fast';
                }
                
                const enemyData = enemyTypes[type];
                const lane = Math.floor(Math.random() * LANES);
                
                enemies.push({
                    x: 0,
                    y: LANE_Y_START + lane * LANE_HEIGHT + LANE_HEIGHT/2,
                    lane: lane,
                    type: type,
                    health: enemyData.health * Math.pow(1.15, wave - 1),
                    maxHealth: enemyData.health * Math.pow(1.15, wave - 1),
                    speed: enemyData.speed,
                    baseSpeed: enemyData.speed,
                    reward: enemyData.reward,
                    emoji: enemyData.emoji,
                    size: enemyData.size,
                    slowUntil: 0
                });
            }
            
            function createParticles(x, y, color, count = 8) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 20,
                        color: color,
                        size: Math.random() * 3 + 1
                    });
                }
            }
            
            function clickHandler(e) {
                if (gameOver) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check if clicking upgrade button (if tower selected)
                if (selectedTowerForUpgrade) {
                    const upgBtn = {x: canvas.width - 220, y: canvas.height - 135, w: 200, h: 50};
                    if (mouseX >= upgBtn.x && mouseX <= upgBtn.x + upgBtn.w &&
                        mouseY >= upgBtn.y && mouseY <= upgBtn.y + upgBtn.h) {
                        
                        const baseType = towerTypes[selectedTowerForUpgrade.type];
                        if (selectedTowerForUpgrade.upgradeLevel < 3) {
                            const upgrade = baseType.upgrades[selectedTowerForUpgrade.upgradeLevel];
                            if (gold >= upgrade.cost) {
                                gold -= upgrade.cost;
                                selectedTowerForUpgrade.upgradeLevel++;
                                
                                // Apply upgrade stats
                                Object.keys(upgrade).forEach(key => {
                                    if (key !== 'cost' && key !== 'name') {
                                        selectedTowerForUpgrade[key] = upgrade[key];
                                    }
                                });
                            }
                        }
                        return;
                    }
                    
                    // Check if clicking delete button
                    const delBtn = {x: canvas.width - 220, y: canvas.height - 195, w: 200, h: 35};
                    if (mouseX >= delBtn.x && mouseX <= delBtn.x + delBtn.w &&
                        mouseY >= delBtn.y && mouseY <= delBtn.y + delBtn.h) {
                        
                        // Sell tower for 70% of total cost
                        const baseType = towerTypes[selectedTowerForUpgrade.type];
                        let totalCost = baseType.cost;
                        for (let i = 0; i < selectedTowerForUpgrade.upgradeLevel; i++) {
                            totalCost += baseType.upgrades[i].cost;
                        }
                        const sellValue = Math.floor(totalCost * 0.7);
                        gold += sellValue;
                        
                        // Remove tower
                        towers.splice(towers.indexOf(selectedTowerForUpgrade), 1);
                        selectedTowerForUpgrade = null;
                        return;
                    }
                }
                
                // Check start wave button
                if (!waveInProgress && mouseX >= canvas.width - 160 && mouseX <= canvas.width - 20 &&
                    mouseY >= 20 && mouseY <= 70) {
                    startWave();
                    return;
                }
                
                // Check tower buttons
                const btnY = canvas.height - 110;
                if (mouseY >= btnY && mouseY <= btnY + 100) {
                    const types = Object.keys(towerTypes);
                    const btnWidth = 65;
                    const btnSpacing = 66;
                    
                    for (let i = 0; i < types.length; i++) {
                        const btnX = 5 + i * btnSpacing;
                        if (mouseX >= btnX && mouseX <= btnX + btnWidth) {
                            const tower = towerTypes[types[i]];
                            if (gold >= tower.cost) {
                                selectedTowerType = types[i];
                                selectedTowerForUpgrade = null;
                            }
                            return;
                        }
                    }
                }
                
                // Check if clicking on existing tower to select it
                for (let tower of towers) {
                    const dist = Math.sqrt((tower.x - mouseX)**2 + (tower.y - mouseY)**2);
                    if (dist < 25) {
                        selectedTowerForUpgrade = tower;
                        selectedTowerType = null;
                        return;
                    }
                }
                
                // Place tower
                if (selectedTowerType) {
                    const tower = towerTypes[selectedTowerType];
                    
                    if (mouseY > LANE_Y_START - 50 && mouseY < LANE_Y_START + LANES * LANE_HEIGHT + 50) {
                        // Check if on path (can only place spike traps on path)
                        let onPath = false;
                        for (let lane = 0; lane < LANES; lane++) {
                            const laneY = LANE_Y_START + lane * LANE_HEIGHT + LANE_HEIGHT/2;
                            if (Math.abs(mouseY - laneY) < 40) {
                                onPath = true;
                                break;
                            }
                        }
                        
                        // Spike traps MUST be on path, other towers CANNOT be on path
                        if (tower.trap && !onPath) return;
                        if (!tower.trap && onPath) return;
                        
                        // Check distance from other towers
                        let tooClose = false;
                        for (let t of towers) {
                            const dist = Math.sqrt((t.x - mouseX)**2 + (t.y - mouseY)**2);
                            if (dist < 50) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose && gold >= tower.cost) {
                            towers.push({
                                x: mouseX,
                                y: mouseY,
                                type: selectedTowerType,
                                lastShot: 0,
                                uses: tower.uses || 999,
                                upgradeLevel: 0,
                                ...tower
                            });
                            gold -= tower.cost;
                            selectedTowerType = null;
                        }
                    } else {
                        // Clicked outside valid area, deselect
                        selectedTowerType = null;
                        selectedTowerForUpgrade = null;
                    }
                } else {
                    // Clicked on nothing, deselect tower
                    selectedTowerForUpgrade = null;
                }
            }
            
            canvas.addEventListener('click', clickHandler);
            
            function endGame(won = false) {
                gameOver = true;
                canvas.removeEventListener('click', clickHandler);
                if (animationId) cancelAnimationFrame(animationId);
                
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,0,0,0.9)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    
                    if (won) {
                        ctx.fillStyle = '#00ff88';
                        ctx.fillText('VICTORY!', canvas.width/2, canvas.height/2 - 40);
                    } else {
                        ctx.fillStyle = '#ff4444';
                        ctx.fillText('DEFEATED!', canvas.width/2, canvas.height/2 - 40);
                    }
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText('Wave: ' + wave, canvas.width/2, canvas.height/2 + 10);
                    ctx.font = '24px Arial';
                    ctx.fillText('Gold: $' + gold, canvas.width/2, canvas.height/2 + 50);
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Click to play again', canvas.width/2, canvas.height/2 + 90);
                    
                    const restartHandler = (e) => {
                        e.stopPropagation();
                        canvas.removeEventListener('click', restartHandler);
                        initTowerDefense();
                    };
                    canvas.addEventListener('click', restartHandler);
                }, 100);
                
                checkQuests(16, {wave: wave, gold: gold});
            }
            
            function gameLoop() {
                if (gameOver) return;
                
                // Background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98D8C8');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw lanes
                for (let i = 0; i < LANES; i++) {
                    const y = LANE_Y_START + i * LANE_HEIGHT;
                    
                    ctx.fillStyle = i % 2 === 0 ? '#7CB342' : '#8BC34A';
                    ctx.fillRect(0, y, canvas.width, LANE_HEIGHT);
                    
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(0, y + LANE_HEIGHT/2 - 40, canvas.width, 80);
                    
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(0, y + LANE_HEIGHT/2);
                    ctx.lineTo(canvas.width, y + LANE_HEIGHT/2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Spawn enemies
                if (waveInProgress) {
                    spawnEnemy();
                }
                
                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    
                    const now = Date.now();
                    enemy.speed = enemy.slowUntil > now ? enemy.baseSpeed * (1 - 0.7) : enemy.baseSpeed;
                    
                    enemy.x += enemy.speed;
                    
                    if (enemy.x > canvas.width) {
                        lives--;
                        enemies.splice(i, 1);
                        
                        if (lives <= 0) {
                            endGame(false);
                            return;
                        }
                        continue;
                    }
                }
                
                // Towers shoot
                const now = Date.now();
                towers.forEach(tower => {
                    if (tower.type === 'farm') return;
                    if (tower.trap && tower.uses <= 0) return;
                    if (now - tower.lastShot < tower.fireRate) return;
                    
                    // Find enemy in range
                    let target = null;
                    let maxProgress = -1;
                    
                    for (let enemy of enemies) {
                        const dist = Math.sqrt((enemy.x - tower.x)**2 + (enemy.y - tower.y)**2);
                        if (dist <= tower.range && enemy.x > maxProgress) {
                            maxProgress = enemy.x;
                            target = enemy;
                        }
                    }
                    
                    if (target) {
                        tower.lastShot = now;
                        
                        if (tower.trap) {
                            // Spike trap hits immediately
                            target.health -= tower.damage;
                            tower.uses--;
                            createParticles(target.x, target.y, '#888', 10);
                            
                            if (target.health <= 0) {
                                gold += target.reward;
                                createParticles(target.x, target.y, '#ffff00', 15);
                                enemies.splice(enemies.indexOf(target), 1);
                            }
                        } else if (tower.multishot) {
                            // Tack shooter shoots in 8 directions
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                                projectiles.push({
                                    x: tower.x,
                                    y: tower.y,
                                    vx: Math.cos(a) * 8,
                                    vy: Math.sin(a) * 8,
                                    speed: 8,
                                    damage: tower.damage,
                                    emoji: 'üìç',
                                    type: tower.type,
                                    pierce: tower.pierce || 0,
                                    pierceCount: 0
                                });
                            }
                        } else {
                            projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                targetX: target.x,
                                targetY: target.y,
                                speed: 12,
                                damage: tower.damage,
                                emoji: tower.emoji,
                                target: target,
                                type: tower.type,
                                splash: tower.splash,
                                slow: tower.slow,
                                slowDuration: tower.slowDuration,
                                pierce: tower.pierce || 0,
                                pierceCount: 0
                            });
                        }
                    }
                });
                
                // Update projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const proj = projectiles[i];
                    
                    if (proj.vx !== undefined) {
                        // Non-homing projectile (tack)
                        proj.x += proj.vx;
                        proj.y += proj.vy;
                        
                        if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                            projectiles.splice(i, 1);
                            continue;
                        }
                        
                        // Check collision with any enemy
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            const dist = Math.sqrt((proj.x - enemy.x)**2 + (proj.y - enemy.y)**2);
                            
                            if (dist < 15) {
                                enemy.health -= proj.damage;
                                proj.pierceCount++;
                                
                                if (enemy.health <= 0) {
                                    gold += enemy.reward;
                                    createParticles(enemy.x, enemy.y, '#ffff00', 10);
                                    enemies.splice(j, 1);
                                }
                                
                                if (proj.pierceCount > proj.pierce) {
                                    projectiles.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    } else {
                        // Homing projectile
                        const dx = proj.target.x - proj.x;
                        const dy = proj.target.y - proj.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < 10 || !enemies.includes(proj.target)) {
                            if (enemies.includes(proj.target)) {
                                // Splash damage
                                if (proj.splash) {
                                    for (let enemy of enemies) {
                                        const eDist = Math.sqrt((enemy.x - proj.target.x)**2 + (enemy.y - proj.target.y)**2);
                                        if (eDist < proj.splash) {
                                            enemy.health -= proj.damage * 0.5;
                                            createParticles(enemy.x, enemy.y, '#ff8800', 5);
                                            
                                            if (enemy.health <= 0) {
                                                gold += enemy.reward;
                                                enemies.splice(enemies.indexOf(enemy), 1);
                                            }
                                        }
                                    }
                                    createParticles(proj.target.x, proj.target.y, '#ff4444', 15);
                                }
                                
                                // Slow effect
                                if (proj.slow) {
                                    proj.target.slowUntil = Date.now() + proj.slowDuration;
                                }
                                
                                proj.target.health -= proj.damage;
                                
                                if (proj.target.health <= 0) {
                                    gold += proj.target.reward;
                                    createParticles(proj.target.x, proj.target.y, '#ffff00', 10);
                                    enemies.splice(enemies.indexOf(proj.target), 1);
                                }
                            }
                            projectiles.splice(i, 1);
                        } else {
                            proj.x += (dx / dist) * proj.speed;
                            proj.y += (dy / dist) * proj.speed;
                        }
                    }
                }
                
                // Check wave complete
                if (waveInProgress && enemiesSpawned >= enemiesPerWave && enemies.length === 0) {
                    waveInProgress = false;
                    
                    // Give income from farms
                    let farmIncome = 0;
                    towers.forEach(t => {
                        if (t.type === 'farm') farmIncome += t.income;
                    });
                    gold += 30 + wave * 5 + farmIncome;
                    
                    wave++;
                    
                    if (wave > 20) {
                        endGame(true);
                        return;
                    }
                }
                
                // Update particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].x += particles[i].vx;
                    particles[i].y += particles[i].vy;
                    particles[i].life--;
                    if (particles[i].life <= 0) particles.splice(i, 1);
                }
                
                // Draw towers
                towers.forEach(tower => {
                    // Range indicator
                    if (selectedTowerType && !tower.trap) {
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = tower.color;
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                    
                    // Selection highlight
                    if (selectedTowerForUpgrade === tower) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, 30, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Show range when selected
                        if (!tower.trap) {
                            ctx.globalAlpha = 0.2;
                            ctx.fillStyle = tower.color;
                            ctx.beginPath();
                            ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }
                    
                    if (tower.trap && tower.uses <= 0) {
                        ctx.globalAlpha = 0.3;
                    }
                    
                    // Tower emoji
                    ctx.font = tower.type === 'super' ? '40px Arial' : '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(tower.emoji, tower.x, tower.y);
                    
                    // Upgrade level stars
                    if (tower.upgradeLevel > 0) {
                        const stars = '‚≠ê'.repeat(tower.upgradeLevel);
                        ctx.font = '14px Arial';
                        ctx.fillStyle = '#ffff00';
                        ctx.fillText(stars, tower.x, tower.y - 25);
                    }
                    
                    ctx.globalAlpha = 1;
                });
                
                // Draw enemies
                enemies.forEach(enemy => {
                    if (enemy.slowUntil > Date.now()) {
                        ctx.globalAlpha = 0.3;
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('‚ùÑÔ∏è', enemy.x, enemy.y - 20);
                        ctx.globalAlpha = 1;
                    }
                    
                    ctx.font = enemy.size + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(enemy.emoji, enemy.x, enemy.y);
                    
                    // Health bar
                    const barWidth = enemy.size * 1.5;
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size/2 - 10, barWidth, 4);
                    ctx.fillStyle = '#00ff88';
                    ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size/2 - 10, barWidth * (enemy.health / enemy.maxHealth), 4);
                });
                
                // Draw projectiles
                projectiles.forEach(proj => {
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(proj.emoji, proj.x, proj.y);
                });
                
                // Draw particles
                particles.forEach(p => {
                    ctx.globalAlpha = p.life / 20;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                });
                ctx.globalAlpha = 1;
                
                // UI - Top bar
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, canvas.width, 90);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('üí∞ ' + gold, 20, 35);
                ctx.fillText('‚ù§Ô∏è ' + lives, 20, 70);
                
                ctx.textAlign = 'center';
                ctx.fillText('üåä Wave ' + wave, canvas.width/2, 35);
                ctx.font = '18px Arial';
                ctx.fillText(enemies.length + ' enemies', canvas.width/2, 65);
                
                // Start wave button
                if (!waveInProgress) {
                    ctx.fillStyle = '#00ff88';
                    ctx.fillRect(canvas.width - 160, 20, 140, 50);
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('START WAVE', canvas.width - 90, 50);
                }
                
                // Upgrade UI panel (when tower selected)
                if (selectedTowerForUpgrade) {
                    const baseType = towerTypes[selectedTowerForUpgrade.type];
                    const upgradeLevel = selectedTowerForUpgrade.upgradeLevel;
                    
                    // Calculate total investment and sell value
                    let totalCost = baseType.cost;
                    for (let i = 0; i < upgradeLevel; i++) {
                        totalCost += baseType.upgrades[i].cost;
                    }
                    const sellValue = Math.floor(totalCost * 0.7);
                    
                    // Panel background
                    ctx.fillStyle = 'rgba(0,0,0,0.9)';
                    ctx.fillRect(canvas.width - 230, canvas.height - 250, 220, 140);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width - 230, canvas.height - 250, 220, 140);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(selectedTowerForUpgrade.emoji + ' ' + baseType.name, canvas.width - 220, canvas.height - 230);
                    
                    ctx.font = '12px Arial';
                    ctx.fillText('Level: ' + upgradeLevel + '/3', canvas.width - 220, canvas.height - 210);
                    
                    // Delete/Sell button
                    const delBtnX = canvas.width - 220;
                    const delBtnY = canvas.height - 195;
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(delBtnX, delBtnY, 200, 35);
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(delBtnX, delBtnY, 200, 35);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üóëÔ∏è SELL FOR $' + sellValue, delBtnX + 100, delBtnY + 22);
                    
                    ctx.textAlign = 'left';
                    
                    if (upgradeLevel < 3) {
                        const upgrade = baseType.upgrades[upgradeLevel];
                        const canAfford = gold >= upgrade.cost;
                        
                        ctx.font = '11px Arial';
                        ctx.fillStyle = '#aaa';
                        ctx.fillText('Next: ' + upgrade.name, canvas.width - 220, canvas.height - 150);
                        
                        // Upgrade button
                        const btnX = canvas.width - 220;
                        const btnY = canvas.height - 135;
                        ctx.fillStyle = canAfford ? '#00ff88' : '#333';
                        ctx.fillRect(btnX, btnY, 200, 50);
                        ctx.strokeStyle = canAfford ? '#00ff88' : '#666';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(btnX, btnY, 200, 50);
                        
                        ctx.fillStyle = canAfford ? 'black' : '#666';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚¨ÜÔ∏è UPGRADE', btnX + 100, btnY + 20);
                        ctx.font = '12px Arial';
                        ctx.fillText('$' + upgrade.cost, btnX + 100, btnY + 38);
                    } else {
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#ffff00';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚≠ê MAX LEVEL ‚≠ê', canvas.width - 120, canvas.height - 145);
                    }
                    
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#888';
                    ctx.textAlign = 'left';
                    ctx.fillText('Click tower to select', canvas.width - 220, canvas.height - 115);
                }
                
                // Tower buttons
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, canvas.height - 110, canvas.width, 110);
                
                const types = Object.keys(towerTypes);
                const btnWidth = 65;
                const btnSpacing = 66;
                
                types.forEach((type, i) => {
                    const tower = towerTypes[type];
                    const btnX = 5 + i * btnSpacing;
                    const btnY = canvas.height - 105;
                    const canAfford = gold >= tower.cost;
                    const isSelected = selectedTowerType === type;
                    
                    ctx.fillStyle = isSelected ? tower.color : (canAfford ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.5)');
                    ctx.fillRect(btnX, btnY, btnWidth, 100);
                    
                    ctx.strokeStyle = isSelected ? tower.color : (canAfford ? 'white' : '#444');
                    ctx.lineWidth = isSelected ? 3 : 2;
                    ctx.strokeRect(btnX, btnY, btnWidth, 100);
                    
                    ctx.font = '36px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(tower.emoji, btnX + btnWidth/2, btnY + 35);
                    
                    ctx.fillStyle = canAfford ? 'white' : '#666';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(tower.name, btnX + btnWidth/2, btnY + 65);
                    ctx.font = '10px Arial';
                    ctx.fillText('$' + tower.cost, btnX + btnWidth/2, btnY + 82);
                    ctx.font = '9px Arial';
                    ctx.fillStyle = canAfford ? '#aaa' : '#444';
                    ctx.fillText(tower.description.substring(0, 10), btnX + btnWidth/2, btnY + 95);
                });
                
                animationId = requestAnimationFrame(gameLoop);
            }
            
            gameLoop();
        }

        // GAME 17: PIXEL PAINTER - Create pixel art!
        function initPixelPainter() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const GRID_SIZE = 32; // 32x32 pixel grid
            const PIXEL_SIZE = Math.floor(Math.min(canvas.width, canvas.height - 180) / GRID_SIZE);
            const GRID_OFFSET_X = (canvas.width - GRID_SIZE * PIXEL_SIZE) / 2;
            const GRID_OFFSET_Y = 50;
            
            let grid = [];
            let currentColor = '#000000';
            let isDrawing = false;
            let animationId = null;
            let showSaveMenu = false;
            let showLoadMenu = false;
            let saveName = '';
            let savedDrawings = [];
            let username = localStorage.getItem('pixelPainterUsername') || '';
            
            // Color palette
            const colors = [
                '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF',
                '#FFFF00', '#FF00FF', '#00FFFF', '#FF8800', '#8800FF',
                '#00FF88', '#FF0088', '#88FF00', '#0088FF', '#8888FF',
                '#FF8888', '#888888', '#444444', '#FFA500', '#A52A2A'
            ];
            
            // Initialize empty grid
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid[y][x] = '#FFFFFF';
                }
            }
            
            function loadSavedDrawings() {
                if (!username) return;
                const saved = localStorage.getItem(`pixelPainter_${username}`);
                if (saved) {
                    try {
                        savedDrawings = JSON.parse(saved);
                    } catch (e) {
                        savedDrawings = [];
                    }
                }
            }
            
            function saveDrawing(name) {
                if (!username) {
                    alert('Please set a username first!');
                    return;
                }
                
                const drawing = {
                    name: name,
                    grid: JSON.parse(JSON.stringify(grid)),
                    date: new Date().toISOString()
                };
                
                // Check if name exists, replace it
                const existingIndex = savedDrawings.findIndex(d => d.name === name);
                if (existingIndex >= 0) {
                    savedDrawings[existingIndex] = drawing;
                } else {
                    savedDrawings.push(drawing);
                }
                
                localStorage.setItem(`pixelPainter_${username}`, JSON.stringify(savedDrawings));
                showSaveMenu = false;
                saveName = '';
            }
            
            function loadDrawing(index) {
                if (index >= 0 && index < savedDrawings.length) {
                    grid = JSON.parse(JSON.stringify(savedDrawings[index].grid));
                    showLoadMenu = false;
                }
            }
            
            function deleteDrawing(index) {
                if (index >= 0 && index < savedDrawings.length) {
                    if (confirm('Delete "' + savedDrawings[index].name + '"?')) {
                        savedDrawings.splice(index, 1);
                        localStorage.setItem(`pixelPainter_${username}`, JSON.stringify(savedDrawings));
                    }
                }
            }
            
            function clearGrid() {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        grid[y][x] = '#FFFFFF';
                    }
                }
            }
            
            function getGridPos(mouseX, mouseY) {
                const x = Math.floor((mouseX - GRID_OFFSET_X) / PIXEL_SIZE);
                const y = Math.floor((mouseY - GRID_OFFSET_Y) / PIXEL_SIZE);
                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                    return {x, y};
                }
                return null;
            }
            
            function mouseMoveHandler(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                if (isDrawing && !showSaveMenu && !showLoadMenu) {
                    const pos = getGridPos(mouseX, mouseY);
                    if (pos) {
                        grid[pos.y][pos.x] = currentColor;
                    }
                }
            }
            
            function mouseDownHandler(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Handle save menu
                if (showSaveMenu) {
                    // Close button
                    if (mouseX > canvas.width/2 + 140 && mouseX < canvas.width/2 + 190 &&
                        mouseY > canvas.height/2 - 120 && mouseY < canvas.height/2 - 80) {
                        showSaveMenu = false;
                        saveName = '';
                        return;
                    }
                    
                    // Save button
                    if (mouseX > canvas.width/2 - 60 && mouseX < canvas.width/2 + 60 &&
                        mouseY > canvas.height/2 + 60 && mouseY < canvas.height/2 + 100 && saveName.length > 0) {
                        saveDrawing(saveName);
                        return;
                    }
                    return;
                }
                
                // Handle load menu
                if (showLoadMenu) {
                    // Close button
                    if (mouseX > canvas.width/2 + 240 && mouseX < canvas.width/2 + 290 &&
                        mouseY > 30 && mouseY < 70) {
                        showLoadMenu = false;
                        return;
                    }
                    
                    // Drawing cards
                    const startY = 100;
                    const cardHeight = 80;
                    const cardSpacing = 10;
                    
                    for (let i = 0; i < savedDrawings.length; i++) {
                        const cardY = startY + i * (cardHeight + cardSpacing);
                        
                        // Load button
                        if (mouseX > canvas.width/2 - 280 && mouseX < canvas.width/2 - 160 &&
                            mouseY > cardY + 20 && mouseY < cardY + 60) {
                            loadDrawing(i);
                            return;
                        }
                        
                        // Delete button
                        if (mouseX > canvas.width/2 + 200 && mouseX < canvas.width/2 + 280 &&
                            mouseY > cardY + 20 && mouseY < cardY + 60) {
                            deleteDrawing(i);
                            return;
                        }
                    }
                    return;
                }
                
                // Check color palette
                const paletteY = canvas.height - 120;
                const colorSize = 35;
                const colorsPerRow = 10;
                
                for (let i = 0; i < colors.length; i++) {
                    const row = Math.floor(i / colorsPerRow);
                    const col = i % colorsPerRow;
                    const colorX = 20 + col * (colorSize + 5);
                    const colorY = paletteY + row * (colorSize + 5);
                    
                    if (mouseX >= colorX && mouseX <= colorX + colorSize &&
                        mouseY >= colorY && mouseY <= colorY + colorSize) {
                        currentColor = colors[i];
                        return;
                    }
                }
                
                // Check buttons
                const btnY = canvas.height - 35;
                
                // Clear button
                if (mouseX >= canvas.width/2 - 200 && mouseX <= canvas.width/2 - 80 &&
                    mouseY >= btnY && mouseY <= btnY + 30) {
                    if (confirm('Clear canvas?')) clearGrid();
                    return;
                }
                
                // Save button
                if (mouseX >= canvas.width/2 - 60 && mouseX <= canvas.width/2 + 60 &&
                    mouseY >= btnY && mouseY <= btnY + 30) {
                    if (!username) {
                        const newUsername = prompt('Enter a username to save:');
                        if (newUsername && newUsername.trim()) {
                            username = newUsername.trim();
                            localStorage.setItem('pixelPainterUsername', username);
                            loadSavedDrawings();
                        } else {
                            alert('Username required to save!');
                            return;
                        }
                    }
                    showSaveMenu = true;
                    saveName = '';
                    return;
                }
                
                // Load button
                if (mouseX >= canvas.width/2 + 80 && mouseX <= canvas.width/2 + 200 &&
                    mouseY >= btnY && mouseY <= btnY + 30) {
                    if (!username) {
                        alert('Please set a username first!');
                        return;
                    }
                    loadSavedDrawings();
                    showLoadMenu = true;
                    return;
                }
                
                // Draw on grid
                const pos = getGridPos(mouseX, mouseY);
                if (pos) {
                    isDrawing = true;
                    grid[pos.y][pos.x] = currentColor;
                }
            }
            
            function mouseUpHandler(e) {
                isDrawing = false;
            }
            
            function keyDownHandler(e) {
                if (showSaveMenu && e.key.length === 1 && saveName.length < 20) {
                    saveName += e.key;
                } else if (showSaveMenu && e.key === 'Backspace') {
                    saveName = saveName.slice(0, -1);
                } else if (showSaveMenu && e.key === 'Enter' && saveName.length > 0) {
                    saveDrawing(saveName);
                } else if (showSaveMenu && e.key === 'Escape') {
                    showSaveMenu = false;
                    saveName = '';
                } else if (showLoadMenu && e.key === 'Escape') {
                    showLoadMenu = false;
                }
            }
            
            canvas.addEventListener('mousemove', mouseMoveHandler);
            canvas.addEventListener('mousedown', mouseDownHandler);
            canvas.addEventListener('mouseup', mouseUpHandler);
            document.addEventListener('keydown', keyDownHandler);
            
            loadSavedDrawings();
            
            function gameLoop() {
                // Background
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Title
                ctx.fillStyle = 'black';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üé® Pixel Painter', canvas.width/2, 30);
                
                if (username) {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#666';
                    ctx.fillText('User: ' + username, canvas.width - 80, 30);
                }
                
                // Draw grid
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        ctx.fillStyle = grid[y][x];
                        ctx.fillRect(
                            GRID_OFFSET_X + x * PIXEL_SIZE,
                            GRID_OFFSET_Y + y * PIXEL_SIZE,
                            PIXEL_SIZE,
                            PIXEL_SIZE
                        );
                    }
                }
                
                // Grid lines
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                for (let i = 0; i <= GRID_SIZE; i++) {
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(GRID_OFFSET_X + i * PIXEL_SIZE, GRID_OFFSET_Y);
                    ctx.lineTo(GRID_OFFSET_X + i * PIXEL_SIZE, GRID_OFFSET_Y + GRID_SIZE * PIXEL_SIZE);
                    ctx.stroke();
                    
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(GRID_OFFSET_X, GRID_OFFSET_Y + i * PIXEL_SIZE);
                    ctx.lineTo(GRID_OFFSET_X + GRID_SIZE * PIXEL_SIZE, GRID_OFFSET_Y + i * PIXEL_SIZE);
                    ctx.stroke();
                }
                
                // Color palette
                const paletteY = canvas.height - 120;
                const colorSize = 35;
                const colorsPerRow = 10;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(10, paletteY - 10, canvas.width - 20, 90);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, paletteY - 10, canvas.width - 20, 90);
                
                for (let i = 0; i < colors.length; i++) {
                    const row = Math.floor(i / colorsPerRow);
                    const col = i % colorsPerRow;
                    const colorX = 20 + col * (colorSize + 5);
                    const colorY = paletteY + row * (colorSize + 5);
                    
                    ctx.fillStyle = colors[i];
                    ctx.fillRect(colorX, colorY, colorSize, colorSize);
                    
                    if (colors[i] === currentColor) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(colorX - 2, colorY - 2, colorSize + 4, colorSize + 4);
                    }
                    
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(colorX, colorY, colorSize, colorSize);
                }
                
                // Buttons
                const btnY = canvas.height - 35;
                
                // Clear button
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(canvas.width/2 - 200, btnY, 120, 30);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width/2 - 200, btnY, 120, 30);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üóëÔ∏è Clear', canvas.width/2 - 140, btnY + 20);
                
                // Save button
                ctx.fillStyle = username ? '#00ff88' : '#888';
                ctx.fillRect(canvas.width/2 - 60, btnY, 120, 30);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(canvas.width/2 - 60, btnY, 120, 30);
                ctx.fillStyle = 'black';
                ctx.fillText(username ? 'üíæ Save' : 'üíæ Save (Login)', canvas.width/2, btnY + 20);
                
                // Load button
                ctx.fillStyle = username ? '#4499ff' : '#888';
                ctx.fillRect(canvas.width/2 + 80, btnY, 120, 30);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(canvas.width/2 + 80, btnY, 120, 30);
                ctx.fillStyle = 'white';
                ctx.fillText(username ? 'üìÇ Load' : 'üìÇ Load (Login)', canvas.width/2 + 140, btnY + 20);
                
                // Save menu
                if (showSaveMenu) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = 'white';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 120, 400, 240);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 200, canvas.height/2 - 120, 400, 240);
                    
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('Save Drawing', canvas.width/2, canvas.height/2 - 80);
                    
                    ctx.font = '16px Arial';
                    ctx.fillText('Enter name:', canvas.width/2, canvas.height/2 - 40);
                    
                    // Input box
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 10, 300, 40);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 - 150, canvas.height/2 - 10, 300, 40);
                    
                    ctx.fillStyle = 'black';
                    ctx.font = '18px Arial';
                    ctx.fillText(saveName + '|', canvas.width/2, canvas.height/2 + 18);
                    
                    // Save button
                    ctx.fillStyle = saveName.length > 0 ? '#00ff88' : '#ccc';
                    ctx.fillRect(canvas.width/2 - 60, canvas.height/2 + 60, 120, 40);
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(canvas.width/2 - 60, canvas.height/2 + 60, 120, 40);
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('Save', canvas.width/2, canvas.height/2 + 85);
                    
                    // Close button
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(canvas.width/2 + 140, canvas.height/2 - 120, 50, 40);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('‚úï', canvas.width/2 + 165, canvas.height/2 - 90);
                }
                
                // Load menu
                if (showLoadMenu) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = 'white';
                    ctx.fillRect(canvas.width/2 - 300, 20, 600, canvas.height - 40);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 300, 20, 600, canvas.height - 40);
                    
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Load Drawing', canvas.width/2, 60);
                    
                    // Close button
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(canvas.width/2 + 240, 30, 50, 40);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('‚úï', canvas.width/2 + 265, 55);
                    
                    if (savedDrawings.length === 0) {
                        ctx.fillStyle = '#666';
                        ctx.font = '18px Arial';
                        ctx.fillText('No saved drawings yet!', canvas.width/2, canvas.height/2);
                    } else {
                        const startY = 100;
                        const cardHeight = 80;
                        const cardSpacing = 10;
                        
                        for (let i = 0; i < savedDrawings.length; i++) {
                            const drawing = savedDrawings[i];
                            const cardY = startY + i * (cardHeight + cardSpacing);
                            
                            // Card background
                            ctx.fillStyle = '#f5f5f5';
                            ctx.fillRect(canvas.width/2 - 280, cardY, 560, cardHeight);
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(canvas.width/2 - 280, cardY, 560, cardHeight);
                            
                            // Drawing name
                            ctx.fillStyle = 'black';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(drawing.name, canvas.width/2 - 260, cardY + 30);
                            
                            // Date
                            ctx.font = '12px Arial';
                            ctx.fillStyle = '#666';
                            const date = new Date(drawing.date);
                            ctx.fillText(date.toLocaleDateString(), canvas.width/2 - 260, cardY + 55);
                            
                            // Load button
                            ctx.fillStyle = '#4499ff';
                            ctx.fillRect(canvas.width/2 - 280, cardY + 20, 120, 40);
                            ctx.strokeStyle = 'black';
                            ctx.strokeRect(canvas.width/2 - 280, cardY + 20, 120, 40);
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 14px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('Load', canvas.width/2 - 220, cardY + 45);
                            
                            // Delete button
                            ctx.fillStyle = '#ff4444';
                            ctx.fillRect(canvas.width/2 + 200, cardY + 20, 80, 40);
                            ctx.strokeStyle = 'black';
                            ctx.strokeRect(canvas.width/2 + 200, cardY + 20, 80, 40);
                            ctx.fillStyle = 'white';
                            ctx.fillText('Delete', canvas.width/2 + 240, cardY + 45);
                        }
                    }
                }
                
                animationId = requestAnimationFrame(gameLoop);
            }
            
            gameLoop();
        }

        function initDefaultGame() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '30px Arial';
            ctx.fillText('This game is coming soon!', canvas.width/2 - 200, canvas.height/2);
            ctx.fillText(`Playing: ${currentGame.name}`, canvas.width/2 - 150, canvas.height/2 + 50);
            ctx.font = '20px Arial';
            ctx.fillText('(Game #' + currentGame.id + ' - Under Development)', canvas.width/2 - 200, canvas.height/2 + 100);
        }

        // Tab Cloak System
        const cloaks = {
            'google-classroom': {
                title: 'Classes',
                favicon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAABE0lEQVR4nO2WMQ6DMBBE3yQFJT0lR+AI3IArUHIKOkoqJEr+YmTJWLAm2ML5pZE2Gh3P7NqrJEmSJPnPADbACagBa7wGuAMH4Ay0wA1YhdvugQNwBlrGDwJ/4QAAAABJREFU1zXgDlw/dRtwXQNeAC1wHeFVH/L1q9ztlWRJkiRJkiT5V5gkSZIkSZL8M1zI7fOhHEbEWq2APXDe/eFWaRX2wGVErNVaCV6BSYhYq7UK+8klRKzVWoVd5BIi1mqtwi5yCRFrtVZhF7mEiLVaq7CLXELEWq1V2EUuIWKt1irsIpcQsVZrFXaRS4hYq7UKu8glRKzVWoVd5BIi1mqtwi5yCRFrtVZhF7mEiLVaq7CLXELEWq1VAAD//0ESURBAA==',
            },
            'google-drive': {
                title: 'My Drive - Google Drive',
                favicon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVR4nO3WMQqAMAxAUY/jcVz6HMZdHEQQRKS0KZT/YJZAwkuTJEmSJEmSpCdgBRagBU7gBA7gBhZgBjpgAE5g/8XvADawAid/FoAV6IAJmIENeIAR6IEJWIANGLdmYG0G1mZgbQbWZmBtBtZmYG0G1mZgbQbWZmBtBtZmYG0G1mZgbQbWZmBtBtYAAA=',
            },
            'google-docs': {
                title: 'Google Docs',
                favicon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhklEQVR4nO3WMQ6AIAxAUY/jcVz6HMZdHEQMJPRPQ/9LmNCU8molSZIkSZIkSXoCRuAAGqAFDuAEDmABOqAHJmABNmDcmoG1GVibgbUZWJuBtRlYm4G1GVibgbUZWJuBtRlYm4G1GVibgbUZWJuBtRlYm4G1GVibgbUZWJuBtRlYAAAAAMAPsAEXnQwCuwAAAABJRU5ErkJggg==',
            },
            'canvas': {
                title: 'Dashboard',
                favicon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVR4nO3WMQqAIBiG4ffwOC59DuMuDiJI0KD9Uvg/mEMQPP2pJEmSJEmSpCdgBVZgAU7gBA5gBRZgATqgB07g+MVvARswAyd/FoANaIAJmIEN6IEB6IEJWIANGLdmYG0G1mZgbQbWZmBtBtZmYG0G1mZgbQbWZmBtBtZmYG0G1mZgbQbWZmBtBtYAAA==',
            },
            'schoology': {
                title: 'Home | Schoology',
                favicon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAe0lEQVR4nO3WMQqAMBBE0X/wOC59DuMuDiKI0GCym8L/oBYWwo5JkiRJkiRJ0hMwAidwARtwAidwABcwAw3QAydw/OK3gA2YgYs/C8AG1MAEzMAG9MAANMAELMAGjFszsDYDazOwNgNrM7A2A2szsDYDazOwNgNrM7A2AwD4AThcFwIA',
            }
        };

        function openCloakMenu() {
            document.getElementById('cloakModal').classList.add('active');
        }

        function closeCloakMenu() {
            document.getElementById('cloakModal').classList.remove('active');
        }

        // Update Log System
        function openUpdateLog() {
            document.getElementById('updateLogModal').classList.add('active');
        }

        function closeUpdateLog() {
            document.getElementById('updateLogModal').classList.remove('active');
        }

        // Advanced Calculator System
        let calcCurrentInput = '0';
        let calcPreviousInput = '';
        let calcHistory = [];
        let calcMemory = 0;
        let calcAngleMode = 'DEG'; // DEG or RAD
        let calcAdvancedMode = false;
        let calcVariables = {}; // Store custom variables

        function openCalculator() {
            document.getElementById('calculatorModal').classList.add('active');
            calcCurrentInput = '0';
            calcPreviousInput = '';
            updateCalcDisplay();
            loadCalcHistory();
            loadVariables();
        }

        function closeCalculator() {
            document.getElementById('calculatorModal').classList.remove('active');
        }

        function updateCalcDisplay() {
            document.getElementById('calcDisplay').textContent = calcCurrentInput;
            document.getElementById('calcSecondary').textContent = calcPreviousInput;
        }

        function toggleCalcMode() {
            calcAdvancedMode = !calcAdvancedMode;
            const panel = document.getElementById('advancedPanel');
            const btn = document.getElementById('calcModeBtn');
            
            if (calcAdvancedMode) {
                panel.style.display = 'block';
                btn.textContent = 'Basic Mode';
                btn.style.background = 'rgba(0,255,136,0.2)';
                btn.style.borderColor = '#00ff88';
                btn.style.color = '#00ff88';
            } else {
                panel.style.display = 'none';
                btn.textContent = 'Advanced Mode';
                btn.style.background = 'rgba(0,212,255,0.2)';
                btn.style.borderColor = '#00d4ff';
                btn.style.color = '#00d4ff';
            }
        }

        function calcInput(value) {
            if (calcCurrentInput === '0' || calcCurrentInput === 'Error' || calcCurrentInput === 'Infinity') {
                calcCurrentInput = value;
            } else {
                calcCurrentInput += value;
            }
            updateCalcDisplay();
        }

        function calcClear() {
            calcCurrentInput = '0';
            calcPreviousInput = '';
            updateCalcDisplay();
        }

        function calcDelete() {
            if (calcCurrentInput.length > 1) {
                calcCurrentInput = calcCurrentInput.slice(0, -1);
            } else {
                calcCurrentInput = '0';
            }
            updateCalcDisplay();
        }

        function calcToggleSign() {
            if (calcCurrentInput !== '0' && calcCurrentInput !== 'Error') {
                if (calcCurrentInput.startsWith('-')) {
                    calcCurrentInput = calcCurrentInput.substring(1);
                } else {
                    calcCurrentInput = '-' + calcCurrentInput;
                }
                updateCalcDisplay();
            }
        }

        function calcEquals() {
            try {
                calcPreviousInput = calcCurrentInput;
                const expression = calcCurrentInput;
                
                // Replace display symbols with JS operators
                let jsExpression = expression
                    .replace(/√ó/g, '*')
                    .replace(/√∑/g, '/')
                    .replace(/‚àí/g, '-')
                    .replace(/œÄ/g, String(Math.PI))
                    .replace(/e(?![0-9])/g, String(Math.E));
                
                const result = eval(jsExpression);
                
                // Add to history
                addCalcHistory(`${expression} = ${result}`);
                
                calcCurrentInput = result.toString();
                calcPreviousInput = expression + ' =';
                updateCalcDisplay();
            } catch (error) {
                calcCurrentInput = 'Error';
                updateCalcDisplay();
                setTimeout(() => {
                    calcCurrentInput = '0';
                    calcPreviousInput = '';
                    updateCalcDisplay();
                }, 2000);
            }
        }

        // Scientific Functions
        function calcFunc(func) {
            try {
                let num = parseFloat(calcCurrentInput);
                let result;
                
                // Convert angle if needed for trig functions
                if (['sin', 'cos', 'tan', 'asin', 'acos', 'atan'].includes(func)) {
                    if (calcAngleMode === 'DEG' && ['sin', 'cos', 'tan'].includes(func)) {
                        num = num * (Math.PI / 180); // Convert to radians
                    }
                }
                
                switch(func) {
                    case 'sin':
                        result = Math.sin(num);
                        calcPreviousInput = `sin(${calcCurrentInput})`;
                        break;
                    case 'cos':
                        result = Math.cos(num);
                        calcPreviousInput = `cos(${calcCurrentInput})`;
                        break;
                    case 'tan':
                        result = Math.tan(num);
                        calcPreviousInput = `tan(${calcCurrentInput})`;
                        break;
                    case 'asin':
                        result = Math.asin(num);
                        if (calcAngleMode === 'DEG') result = result * (180 / Math.PI);
                        calcPreviousInput = `sin‚Åª¬π(${calcCurrentInput})`;
                        break;
                    case 'acos':
                        result = Math.acos(num);
                        if (calcAngleMode === 'DEG') result = result * (180 / Math.PI);
                        calcPreviousInput = `cos‚Åª¬π(${calcCurrentInput})`;
                        break;
                    case 'atan':
                        result = Math.atan(num);
                        if (calcAngleMode === 'DEG') result = result * (180 / Math.PI);
                        calcPreviousInput = `tan‚Åª¬π(${calcCurrentInput})`;
                        break;
                    case 'log':
                        result = Math.log10(num);
                        calcPreviousInput = `log(${calcCurrentInput})`;
                        break;
                    case 'ln':
                        result = Math.log(num);
                        calcPreviousInput = `ln(${calcCurrentInput})`;
                        break;
                    case 'exp':
                        result = Math.exp(num);
                        calcPreviousInput = `e^${calcCurrentInput}`;
                        break;
                    case 'sqrt':
                        result = Math.sqrt(num);
                        calcPreviousInput = `‚àö${calcCurrentInput}`;
                        break;
                    case 'cbrt':
                        result = Math.cbrt(num);
                        calcPreviousInput = `‚àõ${calcCurrentInput}`;
                        break;
                    case 'pow10':
                        result = Math.pow(10, num);
                        calcPreviousInput = `10^${calcCurrentInput}`;
                        break;
                    case 'fact':
                        result = factorial(Math.floor(num));
                        calcPreviousInput = `${Math.floor(num)}!`;
                        break;
                    default:
                        result = num;
                }
                
                addCalcHistory(`${calcPreviousInput} = ${result}`);
                calcCurrentInput = result.toString();
                updateCalcDisplay();
            } catch (error) {
                calcCurrentInput = 'Error';
                updateCalcDisplay();
                setTimeout(() => {
                    calcCurrentInput = '0';
                    calcPreviousInput = '';
                    updateCalcDisplay();
                }, 2000);
            }
        }

        function factorial(n) {
            if (n < 0) return NaN;
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }

        // Memory Functions
        function memoryStore() {
            calcMemory = parseFloat(calcCurrentInput) || 0;
            document.getElementById('memoryIndicator').style.display = 'inline';
            showNotification('Memory stored!');
        }

        function memoryRecall() {
            calcCurrentInput = calcMemory.toString();
            updateCalcDisplay();
        }

        function memoryClear() {
            calcMemory = 0;
            document.getElementById('memoryIndicator').style.display = 'none';
            showNotification('Memory cleared!');
        }

        function memoryAdd() {
            calcMemory += parseFloat(calcCurrentInput) || 0;
            document.getElementById('memoryIndicator').style.display = 'inline';
            showNotification('Added to memory!');
        }

        function toggleAngle() {
            calcAngleMode = calcAngleMode === 'DEG' ? 'RAD' : 'DEG';
            document.getElementById('angleMode').textContent = calcAngleMode;
            document.getElementById('angleBtn').textContent = calcAngleMode === 'DEG' ? 'RAD' : 'DEG';
        }

        function addCalcHistory(entry) {
            calcHistory.unshift(entry);
            if (calcHistory.length > 20) calcHistory.pop();
            
            // Save to localStorage
            localStorage.setItem('calcHistory', JSON.stringify(calcHistory));
            
            renderCalcHistory();
        }

        function renderCalcHistory() {
            const historyDiv = document.getElementById('calcHistory');
            if (calcHistory.length === 0) {
                historyDiv.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No calculations yet</div>';
            } else {
                historyDiv.innerHTML = calcHistory.map((h, i) => 
                    `<div style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); color: ${i === 0 ? '#00ff88' : '#ccc'}; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(0,212,255,0.1)'" onmouseout="this.style.background='transparent'" onclick="calcCurrentInput='${h.split('=')[1].trim()}'; updateCalcDisplay();">${h}</div>`
                ).join('');
            }
        }

        function loadCalcHistory() {
            const saved = localStorage.getItem('calcHistory');
            if (saved) {
                calcHistory = JSON.parse(saved);
                renderCalcHistory();
            }
        }

        function clearCalcHistory() {
            if (confirm('Clear all calculation history?')) {
                calcHistory = [];
                localStorage.removeItem('calcHistory');
                renderCalcHistory();
            }
        }

        // Variable Management System
        function showVariableInput() {
            document.getElementById('variableInput').style.display = 'block';
            document.getElementById('varName').focus();
        }

        function hideVariableInput() {
            document.getElementById('variableInput').style.display = 'none';
            document.getElementById('varName').value = '';
            document.getElementById('varValue').value = '';
        }

        function addVariable() {
            const name = document.getElementById('varName').value.trim();
            const value = document.getElementById('varValue').value.trim();
            
            if (!name) {
                alert('Please enter a variable name!');
                return;
            }
            
            // Validate variable name (letters, numbers, underscore only)
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
                alert('Variable name must start with a letter or underscore and contain only letters, numbers, and underscores!');
                return;
            }
            
            if (!value) {
                alert('Please enter a value!');
                return;
            }
            
            try {
                // Evaluate the value (can be an expression)
                const evaluatedValue = eval(value.replace(/√ó/g, '*').replace(/√∑/g, '/').replace(/‚àí/g, '-'));
                
                calcVariables[name] = evaluatedValue;
                saveVariables();
                renderVariables();
                hideVariableInput();
                showNotification(`Variable ${name} = ${evaluatedValue} saved!`);
            } catch (error) {
                alert('Invalid value! Please enter a valid number or expression.');
            }
        }

        function deleteVariable(name) {
            if (confirm(`Delete variable "${name}"?`)) {
                delete calcVariables[name];
                saveVariables();
                renderVariables();
                showNotification(`Variable ${name} deleted!`);
            }
        }

        function useVariable(name) {
            calcInput(name);
        }

        function saveVariables() {
            localStorage.setItem('calcVariables', JSON.stringify(calcVariables));
        }

        function loadVariables() {
            const saved = localStorage.getItem('calcVariables');
            if (saved) {
                calcVariables = JSON.parse(saved);
            }
            renderVariables();
        }

        function renderVariables() {
            const list = document.getElementById('variablesList');
            const vars = Object.keys(calcVariables);
            
            if (vars.length === 0) {
                list.innerHTML = '<div style="color: #888; text-align: center; padding: 15px; grid-column: span 2; font-size: 0.85em;">No variables yet</div>';
            } else {
                list.innerHTML = vars.map(name => `
                    <div style="background: rgba(138,43,226,0.2); padding: 10px; border-radius: 8px; border: 1px solid rgba(138,43,226,0.4); display: flex; flex-direction: column; gap: 5px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #ba55d3; font-weight: bold; font-family: 'Courier New', monospace; font-size: 1.1em;">${name}</span>
                            <button onclick="deleteVariable('${name}')" style="background: rgba(255,68,68,0.3); border: 1px solid #ff4444; color: #ff4444; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-size: 0.75em;">‚úï</button>
                        </div>
                        <div style="color: #ddd; font-family: 'Courier New', monospace; font-size: 0.9em;">= ${calcVariables[name]}</div>
                        <button onclick="useVariable('${name}')" style="background: rgba(138,43,226,0.3); border: 1px solid #ba55d3; color: #ba55d3; padding: 5px; border-radius: 5px; cursor: pointer; font-size: 0.8em; margin-top: 5px;">Use in Calc</button>
                    </div>
                `).join('');
            }
        }

        // Update calcEquals to support variables
        const originalCalcEquals = calcEquals;
        calcEquals = function() {
            try {
                calcPreviousInput = calcCurrentInput;
                let expression = calcCurrentInput;
                
                // Replace variables with their values
                Object.keys(calcVariables).forEach(varName => {
                    const regex = new RegExp('\\b' + varName + '\\b', 'g');
                    expression = expression.replace(regex, calcVariables[varName]);
                });
                
                // Replace display symbols with JS operators
                let jsExpression = expression
                    .replace(/√ó/g, '*')
                    .replace(/√∑/g, '/')
                    .replace(/‚àí/g, '-')
                    .replace(/œÄ/g, String(Math.PI))
                    .replace(/e(?![0-9])/g, String(Math.E));
                
                const result = eval(jsExpression);
                
                // Add to history
                addCalcHistory(`${calcCurrentInput} = ${result}`);
                
                calcCurrentInput = result.toString();
                calcPreviousInput = calcCurrentInput.split('=')[0] + ' =';
                updateCalcDisplay();
            } catch (error) {
                calcCurrentInput = 'Error';
                updateCalcDisplay();
                setTimeout(() => {
                    calcCurrentInput = '0';
                    calcPreviousInput = '';
                    updateCalcDisplay();
                }, 2000);
            }
        };

        // Keyboard support for calculator
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('calculatorModal');
            if (!modal.classList.contains('active')) return;
            
            if (e.key >= '0' && e.key <= '9') calcInput(e.key);
            else if (e.key === '.') calcInput('.');
            else if (e.key === '+') calcInput('+');
            else if (e.key === '-') calcInput('-');
            else if (e.key === '*') calcInput('*');
            else if (e.key === '/') { e.preventDefault(); calcInput('/'); }
            else if (e.key === '(' || e.key === ')') calcInput(e.key);
            else if (e.key === '%') calcInput('%');
            else if (e.key === 'Enter') { e.preventDefault(); calcEquals(); }
            else if (e.key === 'Escape') closeCalculator();
            else if (e.key === 'Backspace') { e.preventDefault(); calcDelete(); }
            else if (e.key === 'c' || e.key === 'C') { e.preventDefault(); calcClear(); }
        });

        function setCloak(type) {
            if (type === 'reset') {
                // Reset to normal
                document.title = 'Ultimate Game Hub - 50+ Games';
                const favicon = document.querySelector("link[rel*='icon']") || document.createElement('link');
                favicon.type = 'image/x-icon';
                favicon.rel = 'shortcut icon';
                favicon.href = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üéÆ</text></svg>';
                document.getElementsByTagName('head')[0].appendChild(favicon);
                
                // Reset URL to original path
                window.history.pushState({}, '', window.location.pathname);
                
                showNotification('Tab reset to normal! üéÆ');
            } else {
                // URL mappings for each cloak type
                const urls = {
                    'google-classroom': 'https://classroom.google.com/u/0/h',
                    'google-drive': 'https://drive.google.com/drive/my-drive',
                    'google-docs': 'https://docs.google.com/document/u/0/',
                    'canvas': '/canvas',
                    'schoology': '/schoology'
                };
                
                const cloak = cloaks[type];
                if (cloak) {
                    // Change title
                    document.title = cloak.title;
                    
                    // Change favicon
                    const favicon = document.querySelector("link[rel*='icon']") || document.createElement('link');
                    favicon.type = 'image/x-icon';
                    favicon.rel = 'shortcut icon';
                    favicon.href = cloak.favicon;
                    document.getElementsByTagName('head')[0].appendChild(favicon);
                    
                    // Change URL in address bar (same-origin only for security)
                    try {
                        if (urls[type]) {
                            window.history.pushState({}, cloak.title, urls[type]);
                        }
                    } catch (e) {
                        console.log('Could not change URL (security restriction)');
                        // Just change title and favicon - that's enough!
                    }
                    
                    showNotification(`Tab cloaked as ${cloak.title}! üé≠`);
                }
            }
            closeCloakMenu();
        }

        // Initialize
        renderGames();
    </script>
</body>
</html>
